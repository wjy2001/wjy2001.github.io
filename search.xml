<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ubuntu安装etcd及部署集群</title>
      <link href="/2022/05/08/ubuntu%E5%AE%89%E8%A3%85etcd%E5%8F%8A%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/05/08/ubuntu%E5%AE%89%E8%A3%85etcd%E5%8F%8A%E9%83%A8%E7%BD%B2%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu安装etcd及部署集群"><a href="#ubuntu安装etcd及部署集群" class="headerlink" title="ubuntu安装etcd及部署集群"></a>ubuntu安装etcd及部署集群</h1><h2 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h2><p>首先去github下载程序包<a href="https://github.com/etcd-io/etcd/releases">https://github.com/etcd-io/etcd/releases</a></p><p><img src="/images/image-20220508190151818.png" alt="image-20220508190151818"></p><p>然后拷贝到ubuntu中</p><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xzvf etcd-v3.5.4-linux-amd64.tar.gz</span></span><br></pre></td></tr></table></figure><p>进入到对应文件夹，拷贝。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> etcd-v3.5.4-linux-amd64</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp etcd etcdctl /usr/<span class="built_in">local</span>/bin</span></span><br></pre></td></tr></table></figure><p>检验是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl version</span></span><br></pre></td></tr></table></figure> <span id="more"></span><h2 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>阿里云服务器一台，</p><p>公网ip：101.200.87.232 ，内网ip：172.25.39.58</p><p>腾讯云服务器一台，</p><p>公网ip：101.43.208.214 ，内网ip：10.0.16.12</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><h4 id="静态部署"><a href="#静态部署" class="headerlink" title="静态部署"></a>静态部署</h4><blockquote><p>如果在启动前我们知道集群成员，他们的地址和集群的大小，我们可以使用通过设置 <code>initial-cluster</code> 标记来离线启动配置。</p><p>如果使用同样的配置启动多个集群(或者创建并部署单个集群)用于测试目的，强烈推荐每个集群给予一个唯一的 <code>initial-cluster-token</code>。这样做之后，etcd 可以为集群生成唯一的集群 ID 和成员 ID，甚至他们有完全一样的配置。这可以将 etcd 从可能让集群孵化的跨集群交互中保护起来。</p><p>etcd 在 <a href=""><code>listen-client-urls</code></a> 上接收客户端访问。etcd 成员将 <a href=""><code>advertise-client-urls</code></a> 指定的 URl 上通告给其他成员，代理和客户端。常见的错误是设置 <code>advertise-client-urls</code> 为 localhost 或者留空为默认值，如果远程客户端可以达到 etcd。</p><p>注意： 在 <code>initial-cluster</code> 中指定的 URL 是 <em>advertised peer URLs</em> ，例如，他们将匹配对应节点的 <code>initial-advertise-peer-urls</code> 的值。</p></blockquote><p>阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcd --name etcd0 --initial-advertise-peer-urls http://101.200.87.232:2380 \</span></span><br><span class="line"><span class="bash">  --listen-peer-urls http://172.25.39.58:2380 \</span></span><br><span class="line"><span class="bash">  --listen-client-urls http://127.0.0.1:2379,http://172.25.39.58:2379 \</span></span><br><span class="line"><span class="bash">  --advertise-client-urls http://127.0.0.1:2379,http://101.200.87.232:2379 \</span></span><br><span class="line"><span class="bash">  --initial-cluster etcd0=http://101.200.87.232:2380,etcd1=http://101.43.208.214:2380 \</span></span><br><span class="line"><span class="bash">  --initial-cluster-state new \</span></span><br><span class="line"><span class="bash">  --initial-cluster-token etcd-cluster</span></span><br></pre></td></tr></table></figure><p>腾讯云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcd --name etcd1 --initial-advertise-peer-urls http://101.43.208.214:2380 \</span></span><br><span class="line"><span class="bash">  --listen-peer-urls http://10.0.16.12:2380 \</span></span><br><span class="line"><span class="bash">  --listen-client-urls http://127.0.0.1:2379,http://10.0.16.12:2379 \</span></span><br><span class="line"><span class="bash">  --advertise-client-urls http://127.0.0.1:2379,http://101.43.208.214:2379 \</span></span><br><span class="line"><span class="bash">  --initial-cluster etcd0=http://101.200.87.232:2380,etcd1=http://101.43.208.214:2380 \</span></span><br><span class="line"><span class="bash">  --initial-cluster-state new \</span></span><br><span class="line"><span class="bash">  --initial-cluster-token etcd-cluster</span></span><br></pre></td></tr></table></figure><h4 id="动态部署"><a href="#动态部署" class="headerlink" title="动态部署"></a>动态部署</h4><blockquote><p>在一些案例中，集群伙伴的 IP 可能无法提前知道。当使用云提供商或者网络使用 DHCP 时比较常见。在这些情况下，相比指定静态配置，可以使用已经存在的 etcd 集群来启动一个新的。我们称这个过程为”发现”。</p></blockquote><h5 id="公共-etcd-发现服务"><a href="#公共-etcd-发现服务" class="headerlink" title="公共 etcd 发现服务"></a>公共 etcd 发现服务</h5><p>如果没有现成的集群可用，可以使用托管在 <code>discovery.etcd.io</code> 的公共发现服务。为了使用”new” endpoint来创建私有发现URL，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://discovery.etcd.io/new?size=2//这里的size是集群的大小，默认是3</span></span><br><span class="line">https://discovery.etcd.io/160770a95d8bdef7a625b605494eb98b//返回值</span><br></pre></td></tr></table></figure><p>阿里云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcd --name etcd0 --initial-advertise-peer-urls http://101.200.87.232:2380 \</span></span><br><span class="line"><span class="bash">  --listen-peer-urls http://172.25.39.58:2380 \</span></span><br><span class="line"><span class="bash">  --listen-client-urls http://127.0.0.1:2379,http://172.25.39.58:2379 \</span></span><br><span class="line"><span class="bash">  --advertise-client-urls http://127.0.0.1:2379,http://101.200.87.232:2379 \</span></span><br><span class="line"><span class="bash">  --discovery https://discovery.etcd.io/160770a95d8bdef7a625b605494eb98b</span></span><br></pre></td></tr></table></figure><p>腾讯云</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcd --name etcd1 --initial-advertise-peer-urls http://101.43.208.214:2380 \</span></span><br><span class="line"><span class="bash">  --listen-peer-urls http://10.0.16.12:2380 \</span></span><br><span class="line"><span class="bash">  --listen-client-urls http://127.0.0.1:2379,http://10.0.16.12:2379 \</span></span><br><span class="line"><span class="bash">  --advertise-client-urls http://127.0.0.1:2379,http://101.43.208.214:2379 \</span></span><br><span class="line"><span class="bash">  --discovery https://discovery.etcd.io/160770a95d8bdef7a625b605494eb98b</span></span><br></pre></td></tr></table></figure><h3 id="检测是否成功"><a href="#检测是否成功" class="headerlink" title="检测是否成功"></a>检测是否成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl member list</span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20220527120558430.png" alt="image-20220527120558430"></p><p>检查集群中的数据是否一致</p><p>在阿里云中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl put aaa bbb</span></span><br></pre></td></tr></table></figure><p>在腾讯云中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> etcdctl get aaa</span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20220527120804548.png" alt="image-20220527120804548"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> etcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精妙的算法</title>
      <link href="/2022/05/04/%E7%B2%BE%E5%A6%99%E7%9A%84%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/04/%E7%B2%BE%E5%A6%99%E7%9A%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="精妙的算法"><a href="#精妙的算法" class="headerlink" title="精妙的算法"></a>精妙的算法</h1><h2 id="Brian-Kernighan算法"><a href="#Brian-Kernighan算法" class="headerlink" title="Brian Kernighan算法"></a>Brian Kernighan算法</h2><p>统计一个数字的二进制中的1的个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">onesCount</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(ones <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//x是被统计是数字</span></span><br><span class="line">    <span class="keyword">for</span> ; x &gt; <span class="number">0</span>; x &amp;= x - <span class="number">1</span> &#123;</span><br><span class="line">        ones++</span><br><span class="line">        <span class="comment">//ones是1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp;是或运算，只有对应位都是1才得1，否则为0。</p><p>x-1的效果，则是将最末尾的1以及后面的0都取反。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>,<span class="number">011</span>,<span class="number">010</span></span><br><span class="line"><span class="comment">//x-1后</span></span><br><span class="line"><span class="number">100</span>,<span class="number">011</span>,<span class="number">001</span></span><br><span class="line"><span class="comment">//进行或运算后</span></span><br><span class="line"><span class="number">100</span>,<span class="number">011</span>,<span class="number">000</span></span><br><span class="line"><span class="comment">//此时ones为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x-1后</span></span><br><span class="line"><span class="number">100</span>,<span class="number">010</span>,<span class="number">111</span></span><br><span class="line"><span class="comment">//进行或运算后</span></span><br><span class="line"><span class="number">100</span>,<span class="number">010</span>,<span class="number">000</span></span><br><span class="line"><span class="comment">//此时ones为2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x-1后</span></span><br><span class="line"><span class="number">100</span>,<span class="number">001</span>,<span class="number">111</span></span><br><span class="line"><span class="comment">//进行或运算后</span></span><br><span class="line"><span class="number">100</span>,<span class="number">000</span>,<span class="number">000</span></span><br><span class="line"><span class="comment">//此时ones为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//x-1后</span></span><br><span class="line"><span class="number">011</span>,<span class="number">111</span>,<span class="number">111</span></span><br><span class="line"><span class="comment">//进行或运算后</span></span><br><span class="line"><span class="number">000</span>,<span class="number">000</span>,<span class="number">000</span></span><br><span class="line"><span class="comment">//此时ones为4</span></span><br><span class="line"><span class="comment">//不满足x&gt;0,输出ones.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/01/etcd%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/05/01/etcd%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text添加到鼠标右键菜单</title>
      <link href="/2022/05/01/Sublime%20Text%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
      <url>/2022/05/01/Sublime%20Text%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Sublime-Text添加到鼠标右键菜单"><a href="#Sublime-Text添加到鼠标右键菜单" class="headerlink" title="Sublime Text添加到鼠标右键菜单"></a>Sublime Text添加到鼠标右键菜单</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h2><h3 id="1-win-R-打开运行，并输入regedit。"><a href="#1-win-R-打开运行，并输入regedit。" class="headerlink" title="1.win+R 打开运行，并输入regedit。"></a>1.win+R 打开运行，并输入regedit。</h3><p><img src="/images/image-20220501145535611.png" alt="image-20220501145535611"></p><span id="more"></span><h3 id="2-在左侧依次打开HKEY-CLASSES-ROOT-shell"><a href="#2-在左侧依次打开HKEY-CLASSES-ROOT-shell" class="headerlink" title="2.在左侧依次打开HKEY_CLASSES_ROOT*\shell"></a>2.在左侧依次打开HKEY_CLASSES_ROOT*\shell</h3><p><img src="/images/image-20220501145627585.png" alt="image-20220501145627585"></p><h3 id="3-在shell下新建“Sublime-Text”项，在右侧窗口的“默认”键值栏内输入“用Sublime-Text打开”。项的名称和键值可以任意，最好是和程序关联起来。其中键值将显示在右键菜单中。后面的Icon是图标，地址是运行程序的地址加上“-0”。"><a href="#3-在shell下新建“Sublime-Text”项，在右侧窗口的“默认”键值栏内输入“用Sublime-Text打开”。项的名称和键值可以任意，最好是和程序关联起来。其中键值将显示在右键菜单中。后面的Icon是图标，地址是运行程序的地址加上“-0”。" class="headerlink" title="3.在shell下新建“Sublime Text”项，在右侧窗口的“默认”键值栏内输入“用Sublime Text打开”。项的名称和键值可以任意，最好是和程序关联起来。其中键值将显示在右键菜单中。后面的Icon是图标，地址是运行程序的地址加上“,0”。"></a>3.在shell下新建“Sublime Text”项，在右侧窗口的“默认”键值栏内输入“用Sublime Text打开”。项的名称和键值可以任意，最好是和程序关联起来。其中键值将显示在右键菜单中。后面的Icon是图标，地址是运行程序的地址加上“,0”。</h3><p><img src="/images/image-20220501145741376.png" alt="image-20220501145741376"></p><h3 id="4-在“用Sublime-Text打开”下再新建Command项，在右侧窗口的“默认”键值栏内输入Sublime-Text程序所在的路径-在路径后添加-1。-1表示要打开的文件参数。"><a href="#4-在“用Sublime-Text打开”下再新建Command项，在右侧窗口的“默认”键值栏内输入Sublime-Text程序所在的路径-在路径后添加-1。-1表示要打开的文件参数。" class="headerlink" title="4.在“用Sublime Text打开”下再新建Command项，在右侧窗口的“默认”键值栏内输入Sublime Text程序所在的路径,在路径后添加 %1。%1表示要打开的文件参数。"></a>4.在“用Sublime Text打开”下再新建Command项，在右侧窗口的“默认”键值栏内输入Sublime Text程序所在的路径,在路径后添加 %1。%1表示要打开的文件参数。</h3><p><img src="/images/image-20220501145903736.png" alt="image-20220501145903736"></p><h3 id="5-关闭注册表窗口，立即生效。（如图）"><a href="#5-关闭注册表窗口，立即生效。（如图）" class="headerlink" title="5.关闭注册表窗口，立即生效。（如图）"></a>5.关闭注册表窗口，立即生效。（如图）</h3><p><img src="/images/image-20220501150014323.png" alt="image-20220501150014323"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发相关</title>
      <link href="/2022/04/23/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/04/23/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="mongo-driver"><a href="#mongo-driver" class="headerlink" title="mongo-driver"></a>mongo-driver</h1><h1 id="并发相关"><a href="#并发相关" class="headerlink" title="并发相关"></a>并发相关</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><blockquote><p>线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。</p></blockquote><p>golang中的context是线程安全的，可以放心的在多个Goroutine 中传递。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo-driver</title>
      <link href="/2022/04/15/mongo-driver/"/>
      <url>/2022/04/15/mongo-driver/</url>
      
        <content type="html"><![CDATA[<h1 id="mongo-driver"><a href="#mongo-driver" class="headerlink" title="mongo-driver"></a>mongo-driver</h1><h2 id="Find"><a href="#Find" class="headerlink" title="Find()"></a>Find()</h2><p>使用golang操作mongoDB中 find中option参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option.Find()</span><br></pre></td></tr></table></figure><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SetLimit(i <span class="keyword">int64</span>)</span><br><span class="line"><span class="comment">//要返回的最大文档数。默认值为0。</span></span><br><span class="line"></span><br><span class="line">SetSkip(i <span class="keyword">int64</span>)</span><br><span class="line"><span class="comment">//将文档添加到结果之前要跳过的文档数。默认值为0。</span></span><br><span class="line"></span><br><span class="line">SetSort(sort <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//一种文件，指定文件的归还顺序。如果排序参数是多键映射，则驱动程序将返回一个错误。</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="所有"><a href="#所有" class="headerlink" title="所有"></a>所有</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">SetAllowDiskUse(b <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//如果为true，服务器可以在执行查找操作时将临时数据写入磁盘。此选项仅适用于MongoDB版本&gt;=4.4</span></span><br><span class="line"><span class="comment">//如果指定了此选项，服务器版本&gt;=3.2将报告错误。对于服务器版本&lt;3.2，驱动程序将返回客户端错误。</span></span><br><span class="line"><span class="comment">//默认值是false。</span></span><br><span class="line"></span><br><span class="line">SetAllowPartialResults(b <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//如果为true，则如果某些碎片已关闭而不是已关闭，则对碎片群集的操作可能会返回部分结果</span></span><br><span class="line"><span class="comment">//返回一个错误。默认值为false。</span></span><br><span class="line"></span><br><span class="line">SetBatchSize(i <span class="keyword">int32</span>)</span><br><span class="line"><span class="comment">//服务器返回的每个批中包含的最大文档数。</span></span><br><span class="line"></span><br><span class="line">SetCollation(collation *collation)</span><br><span class="line"><span class="comment">//指定操作期间用于字符串比较的排序规则。此选项仅对MongoDB有效</span></span><br><span class="line"><span class="comment">//版本&gt;=3.4。对于以前的服务器版本，如果使用此选项，驱动程序将返回错误。这个</span></span><br><span class="line"><span class="comment">//默认值为nil，这意味着将使用集合的默认排序规则。</span></span><br><span class="line"></span><br><span class="line">SetComment(comment <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">//一个字符串，将包含在服务器日志、分析日志和currentOp查询中，以帮助跟踪操作。</span></span><br><span class="line"><span class="comment">//默认值为空字符串，这意味着日志中不会包含任何注释。</span></span><br><span class="line"></span><br><span class="line">SetCursorType(ct CursorType)</span><br><span class="line"><span class="comment">//指定应为操作创建的光标类型。默认值是不可跟踪的，这意味着</span></span><br><span class="line"><span class="comment">//检索最后一批文档时，服务器将关闭光标。</span></span><br><span class="line"></span><br><span class="line">SetHint(hint <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//用于操作的索引。这应该是作为字符串的索引名或索引规范</span></span><br><span class="line"><span class="comment">//作为文件。如果提示参数是多键映射，驱动程序将返回一个错误。默认值为nil，</span></span><br><span class="line"><span class="comment">//这意味着不会发送任何提示。</span></span><br><span class="line"></span><br><span class="line">SetLet(let <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//指定查找表达式的参数。需要mongo版本大于等于5.0</span></span><br><span class="line"></span><br><span class="line">SetLimit(i <span class="keyword">int64</span>)</span><br><span class="line"><span class="comment">//要返回的最大文档数。默认值为0。</span></span><br><span class="line"></span><br><span class="line">SetMax(max <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//指定特定索引的排他性上界的文档。默认值为nil，这意味着没有最大值。</span></span><br><span class="line"></span><br><span class="line">SetMaxAwaitTime(d time.Duration)</span><br><span class="line"><span class="comment">//服务器等待新文档满足可定制游标查询的最长时间。</span></span><br><span class="line"><span class="comment">//此选项仅适用于可定制的等待游标（有关更多信息，请参阅游标类型选项）和</span></span><br><span class="line"><span class="comment">//MongoDB版本&gt;=3.2。对于其他游标类型或以前的服务器版本，此选项将被忽略。</span></span><br><span class="line"></span><br><span class="line">SetMaxTime(d time.Duration)</span><br><span class="line"><span class="comment">//查询可以在服务器上运行的最长时间。默认值为nil，这意味着</span></span><br><span class="line"><span class="comment">//查询执行没有时间限制。</span></span><br><span class="line"></span><br><span class="line">SetMin(min <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//指定特定索引的包含下限的文档。默认值为0，这意味着</span></span><br><span class="line"><span class="comment">//没有最小值。</span></span><br><span class="line"></span><br><span class="line">SetNoCursorTimeout(b <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//如果为true，则操作创建的光标在一段时间不活动后不会超时。默认值为false</span></span><br><span class="line"></span><br><span class="line">SetOplogReplay(b <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//此选项仅供内部复制使用，不应设置。</span></span><br><span class="line"><span class="comment">//已弃用：此选项在MongoDB 4.4版中已弃用，如果使用，服务器将忽略它</span></span><br><span class="line"></span><br><span class="line">SetProjection(projection <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//描述操作返回的文档中将包含哪些字段的文档。默认值</span></span><br><span class="line"><span class="comment">//是nil，这意味着将包括所有字段。</span></span><br><span class="line"></span><br><span class="line">SetReturnKey(b <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//如果为true，操作返回的文档将只包含与所用索引对应的字段。这个</span></span><br><span class="line"><span class="comment">//默认值为false。</span></span><br><span class="line"></span><br><span class="line">SetShowRecordID(b <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//如果为true，则操作返回的文档中将包含带有记录标识符的$recordId字段。</span></span><br><span class="line"><span class="comment">//默认值为false。</span></span><br><span class="line"></span><br><span class="line">SetSkip(i <span class="keyword">int64</span>)</span><br><span class="line"><span class="comment">//将文档添加到结果之前要跳过的文档数。默认值为0。</span></span><br><span class="line"></span><br><span class="line">SetSnapshot(b <span class="keyword">bool</span>)</span><br><span class="line"><span class="comment">//如果为true，则由于中间的写入操作，光标不会多次返回文档。这个默认值为false。</span></span><br><span class="line"><span class="comment">//已弃用：此选项在MongoDB 3.6版中已弃用，并在MongoDB 4.0版中删除。</span></span><br><span class="line"></span><br><span class="line">SetSort(sort <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//一种文件，指定文件的归还顺序。如果排序参数是多键映射，则驱动程序将返回一个错误。</span></span><br></pre></td></tr></table></figure><h2 id="Update"><a href="#Update" class="headerlink" title="Update()"></a>Update()</h2><h3 id="rename"><a href="#rename" class="headerlink" title="$rename"></a>$rename</h3><blockquote><p>修改字段名</p></blockquote><p><strong>官方写法</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.students.updateOne(</span><br><span class="line">   &#123; _id: <span class="number">1</span> &#125;,</span><br><span class="line">   &#123; $rename: &#123; &#x27;nickname&#x27;: &#x27;alias&#x27;, &#x27;cell&#x27;: &#x27;mobile&#x27; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>golang写法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo.Api.UpdateMany(context.Background(), bson.M&#123;&#125;, bson.M&#123;<span class="string">&quot;$rename&quot;</span>: bson.M&#123;<span class="string">&quot;explain&quot;</span>: <span class="string">&quot;group&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="Aggregate"><a href="#Aggregate" class="headerlink" title="Aggregate()"></a>Aggregate()</h2><h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><blockquote><p>修改字段</p></blockquote><p><strong>官方写法</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $project: &#123; &lt;specification(s)&gt; &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>golang写法</strong></p><p>基础版本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter := []bson.D&#123;</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;group&quot;</span>, <span class="string">&quot;$_id&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;apis&quot;</span>, <span class="number">1</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">collection.Aggregate(context.Background(), filter)</span><br></pre></td></tr></table></figure><p><strong>修改对象里面的</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter := []bson.D&#123;</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;group&quot;</span>, <span class="string">&quot;$_id&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;apis&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;group&quot;</span>, <span class="number">0</span>&#125;&#125;&#125;&#125;,<span class="comment">//展示apis对象里面除group之外的，写1的话就是只展示group</span></span><br><span class="line">&#125;</span><br><span class="line">collection.Aggregate(context.Background(), filter)</span><br></pre></td></tr></table></figure><p><strong>修改数组对象里面的</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">filter := []bson.D&#123;</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;group&quot;</span>, <span class="string">&quot;$_id&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;apis&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;group&quot;</span>, <span class="number">1</span>&#125;&#125;&#125;&#125;,<span class="comment">//只展示apis数组的对象里面的group,不允许写0使用排除</span></span><br><span class="line">&#125;</span><br><span class="line">collection.Aggregate(context.Background(), filter)</span><br></pre></td></tr></table></figure><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><blockquote><p>分组</p></blockquote><p><strong>官方写法</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $group:</span><br><span class="line">    &#123;</span><br><span class="line">      _id: &lt;expression&gt;, <span class="comment">// 按表达式分组</span></span><br><span class="line">      &lt;field1&gt;: &#123; &lt;accumulator1&gt; : &lt;expression1&gt; &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>golang写法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filter := []bson.D&#123;</span><br><span class="line">&#123;&#123;<span class="string">&quot;$group&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, bson.D&#123;<span class="comment">//这里的_id是分组的依据</span></span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="string">&quot;$_id&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;devicename&quot;</span>, <span class="string">&quot;$devicename&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;$createTime&quot;</span>&#125;,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;$push&quot;</span>, <span class="string">&quot;$key&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arrayToObject"><a href="#arrayToObject" class="headerlink" title="arrayToObject"></a>arrayToObject</h3><p>将数组转化成对象</p><p><strong>前提</strong></p><blockquote><p>一个双元素数组的数组，其中第一个元素是字段名称，第二个元素是字段值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ <span class="string">&quot;item&quot;</span>, <span class="string">&quot;abc123&quot;</span>], [ <span class="string">&quot;qty&quot;</span>, <span class="number">25</span> ] ]</span><br></pre></td></tr></table></figure><p><strong>或</strong></p><p>包含两个字段的文档数组，</p><p>该字段包含字段名称。k<br>该字段包含该字段的值。v</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; <span class="attr">&quot;k&quot;</span>: <span class="string">&quot;item&quot;</span>, <span class="attr">&quot;v&quot;</span>: <span class="string">&quot;abc123&quot;</span>&#125;, &#123; <span class="attr">&quot;k&quot;</span>: <span class="string">&quot;qty&quot;</span>, <span class="attr">&quot;v&quot;</span>: <span class="number">25</span> &#125; ]</span><br></pre></td></tr></table></figure></blockquote><p><strong>官方写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $arrayToObject: &lt;expression&gt; &#125;</span><br></pre></td></tr></table></figure><p>可以使用在$addFields，$project中</p><p>$project</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   $project: &#123;</span><br><span class="line">      item: <span class="number">1</span>,</span><br><span class="line">      dimensions: &#123; $arrayToObject: <span class="string">&quot;$dimensions&quot;</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$addFields</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; $addFields: &#123; instock: &#123; $arrayToObject: <span class="string">&quot;$instock&quot;</span> &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><p><strong>golang写法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter := []bson.D&#123;</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;$_id.createTime&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;devicename&quot;</span>, <span class="string">&quot;$_id.devicename&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;$arrayToObject&quot;</span>, <span class="string">&quot;$key&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊情况记录</strong></p><p>如何把一个数组对象中对象的值作为键值对</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把下面数组中name作为key，value作为value,组成键值对。</span></span><br><span class="line"><span class="string">&quot;devicename&quot;</span>: <span class="string">&quot;单向Z1c8&quot;</span></span><br><span class="line"><span class="string">&quot;dataset1&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;合相有功功率&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;W&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="number">122866.4</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;合相无功功率&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;var&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="number">149897</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;电流互感器倍率&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;value&quot;</span>: <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">              ]</span><br></pre></td></tr></table></figure><p>使用的方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">filter := []bson.D&#123;</span><br><span class="line">&#123;&#123;<span class="string">&quot;$unwind&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;path&quot;</span>, <span class="string">&quot;$dataset1&quot;</span>&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;devicename&quot;</span>, <span class="string">&quot;$device.name&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key.k&quot;</span>, <span class="string">&quot;$dataset1.name&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key.v&quot;</span>, <span class="string">&quot;$dataset1.value&quot;</span>&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$group&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="string">&quot;$devicename&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;$push&quot;</span>, <span class="string">&quot;$key&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;devicename&quot;</span>, <span class="string">&quot;$_id.devicename&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;$arrayToObject&quot;</span>, <span class="string">&quot;$key&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;devicename&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;单向Z1c8&quot;</span></span><br><span class="line">],</span><br><span class="line"><span class="string">&quot;key&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;合相功率因数&quot;</span>: <span class="number">122866.4</span>,</span><br><span class="line">    <span class="attr">&quot;合相无功功率&quot;</span>: <span class="number">149897</span>,</span><br><span class="line">    <span class="attr">&quot;电流互感器倍率&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">filter := []bson.D&#123;</span><br><span class="line">&#123;&#123;<span class="string">&quot;$sort&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">-1</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$match&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;createTime&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;$gte&quot;</span>, time2&#125;, &#123;<span class="string">&quot;$lte&quot;</span>, now&#125;&#125;&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$skip&quot;</span>, skip&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$limit&quot;</span>, limit&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$lookup&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;from&quot;</span>, <span class="string">&quot;device&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;localField&quot;</span>, <span class="string">&quot;deviceId&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;foreignField&quot;</span>, <span class="string">&quot;_id&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;as&quot;</span>, <span class="string">&quot;device&quot;</span>&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$unwind&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;path&quot;</span>, <span class="string">&quot;$device&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;path&quot;</span>, <span class="string">&quot;$dataset1&quot;</span>&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;createTime&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;devicename&quot;</span>, <span class="string">&quot;$device.name&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key.k&quot;</span>, <span class="string">&quot;$dataset1.name&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key.v&quot;</span>, <span class="string">&quot;$dataset1.value&quot;</span>&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$group&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="string">&quot;$_id&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;devicename&quot;</span>, <span class="string">&quot;$devicename&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;$createTime&quot;</span>&#125;,</span><br><span class="line">&#125;&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;$push&quot;</span>, <span class="string">&quot;$key&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$sort&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id._id&quot;</span>, <span class="number">-1</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="string">&quot;$project&quot;</span>, bson.D&#123;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;createTime&quot;</span>, <span class="string">&quot;$_id.createTime&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;devicename&quot;</span>, <span class="string">&quot;$_id.devicename&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;key&quot;</span>, bson.D&#123;&#123;<span class="string">&quot;$arrayToObject&quot;</span>, <span class="string">&quot;$key&quot;</span>&#125;&#125;&#125;,</span><br><span class="line">&#125;&#125;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器脚本文件</title>
      <link href="/2022/04/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/"/>
      <url>/2022/04/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器脚本文件"><a href="#服务器脚本文件" class="headerlink" title="服务器脚本文件"></a>服务器脚本文件</h1><p>更新sh</p><p>写法一</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /root/working/test-frame;//项目地址</span><br><span class="line">pid=$(ps -ef | grep &quot;go-build&quot; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; |tail -n 3 | head -n 1);</span><br><span class="line">echo $pid</span><br><span class="line">kill $&#123;pid&#125;</span><br><span class="line">git pull </span><br><span class="line">go mod tidy</span><br><span class="line">nohup go run main.go &amp;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><span id="more"></span><p>写法二</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NR==1 第一行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">print</span> <span class="variable">$2</span> 输出第二个参数</span></span><br><span class="line">id=$(sudo lsof -i:7007|grep drone-golang-example|awk &#x27;NR==1&#123;print $2&#125;&#x27;)//如果是root账号不写sudo</span><br><span class="line">if [ ! $&#123;id&#125; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;项目未启动&quot;</span><br><span class="line">else</span><br><span class="line">    sudo kill -9 $id</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组使用切片</title>
      <link href="/2022/04/10/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E5%88%87%E7%89%87/"/>
      <url>/2022/04/10/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="二维数组使用切片"><a href="#二维数组使用切片" class="headerlink" title="二维数组使用切片"></a>二维数组使用切片</h1><p>在leecode做题时遇见</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;……&#125;</span><br></pre></td></tr></table></figure><p>本想着直接写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res:= [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">res[<span class="number">0</span>] = <span class="built_in">append</span>(res[<span class="number">0</span>], <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>结果报错为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: index out of range [0] with length 0</span><br><span class="line">//运行时错误：索引超出范围[0]，长度为0</span><br></pre></td></tr></table></figure><span id="more"></span><p>解决方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res:= [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, []<span class="keyword">int</span>&#123;&#125;)</span><br><span class="line">res[<span class="number">0</span>] = <span class="built_in">append</span>(res[<span class="number">0</span>], <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubantu安装lua和luarocks</title>
      <link href="/2022/04/09/ubantu%E5%AE%89%E8%A3%85lua%E5%92%8Cluarocks/"/>
      <url>/2022/04/09/ubantu%E5%AE%89%E8%A3%85lua%E5%92%8Cluarocks/</url>
      
        <content type="html"><![CDATA[<h1 id="ubantu安装lua和luarocks"><a href="#ubantu安装lua和luarocks" class="headerlink" title="ubantu安装lua和luarocks"></a>ubantu安装lua和luarocks</h1><p>为了安装apisix我在我的ubantu16.04上安装了lua环境，但过程很折磨，特地记录</p><h3 id="首先使用apt-get-安装"><a href="#首先使用apt-get-安装" class="headerlink" title="首先使用apt-get 安装"></a>首先使用apt-get 安装</h3><p>可以，但版本较低无法安装apisix</p><h3 id="使用编译安装"><a href="#使用编译安装" class="headerlink" title="使用编译安装"></a>使用编译安装</h3><h4 id="安装lua"><a href="#安装lua" class="headerlink" title="安装lua"></a>安装lua</h4><p>lua的安装包网站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make linux test</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><span id="more"></span><p>然后使用lua -v查看版本。</p><blockquote><p>注意，如果使用apt安装过后可能由于没有卸载干净会导致版本错误。</p></blockquote><h4 id="安装luarocks"><a href="#安装luarocks" class="headerlink" title="安装luarocks"></a>安装luarocks</h4><p>下载安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://luarocks.github.io/luarocks/releases/luarocks-2.4.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> luarocks-2.4.2</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/luarocks --with-lua=/usr/<span class="built_in">local</span>/lua/</span><br><span class="line">make build</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>增加luarocks的bin目录到系统里并生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/luarocks/bin/:$&#123;PATH&#125;&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>设置lua库的环境变量并生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export LUA_PATH=&#x27;/usr/local/lua/lib/lua/5.3/?.lua;/usr/local/luarocks/lib/lua/5.3/?.lua;/usr/local/luarocks/share/lua/5.3/?.lua;?.lua;;&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export LUA_CPATH=&#x27;/usr/local/lua/lib/lua/5.3/?.so;/usr/local/luarocks/lib/lua/5.3/?.so;/usr/local/luarocks/share/lua/5.3/?.so;?.so;;&#x27;&quot;</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>直到最后我的lua环境还是不完整，安装apisix时提示缺少组件。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的使用场景</title>
      <link href="/2022/04/09/redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2022/04/09/redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="redis的使用场景"><a href="#redis的使用场景" class="headerlink" title="redis的使用场景"></a>redis的使用场景</h1><p>主要是作为缓存，将一些更新不频繁的数据放在redis中，加快读取速度，同时减轻服务器的压力。</p><h4 id="典型的使用场景"><a href="#典型的使用场景" class="headerlink" title="典型的使用场景"></a>典型的使用场景</h4><ul><li><p><strong>缓存</strong></p><blockquote><p> 缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p></blockquote></li><li><p><strong>排行榜</strong></p><blockquote><p> 很多网站都有排行榜应用的，如淘宝的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。 </p></blockquote></li></ul><span id="more"></span><ul><li><p><strong>分布式会话</strong></p><blockquote><p> 集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p></blockquote></li><li><p><strong>分布式锁</strong></p><blockquote><p> 在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。 </p></blockquote></li><li><p><strong>社交网络</strong></p><blockquote><p> 点赞、踩、关注/被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。</p></blockquote></li><li><p><strong>最新列表</strong></p><blockquote><p> Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p></blockquote></li><li><p><strong>消息系统</strong></p><blockquote><p> 消息队列是大型网站必用<a href="https://cloud.tencent.com/product/tdmq?from=10680">中间件</a>，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布/订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p></blockquote></li></ul><h3 id="Redis的8个应用场景"><a href="#Redis的8个应用场景" class="headerlink" title="Redis的8个应用场景"></a><strong>Redis的8个应用场景</strong></h3><p><strong>一：缓存—热数据</strong></p><blockquote><p> 热点数据（经常会被查询，但是不经常被修改或者删除的数据），首选是使用redis缓存，毕竟强大到冒泡的QPS和极强的稳定性不是所有类似工具都有的，而且相比于memcached还提供了丰富的数据类型可以使用，另外，内存中的数据也提供了AOF和RDB等持久化机制可以选择，要冷、热的还是忽冷忽热的都可选。 </p></blockquote><p>结合具体应用需要注意一下：很多人用spring的AOP来构建redis缓存的自动生产和清除，过程可能如下：</p><blockquote><p> select 数据库前查询redis，有的话使用redis数据，放弃select 数据库，没有的话，select 数据库，然后将数据插入redis； update或者delete数据库钱，查询redis是否存在该数据，存在的话先删除redis中数据，然后再update或者delete数据库中的数据； </p></blockquote><p>上面这种操作，如果并发量很小的情况下基本没问题，但是高并发的情况请注意下面场景：</p><blockquote><p> 为了update先删掉了redis中的该数据，这时候另一个线程执行查询，发现redis中没有，瞬间执行了查询SQL，并且插入到redis中一条数据，回到刚才那个update语句，这个悲催的线程压根不知道刚才那个该死的select线程犯了一个弥天大错！于是这个redis中的错误数据就永远的存在了下去，直到下一个update或者delete。 </p></blockquote><p><strong>二：计数器</strong></p><blockquote><p>诸如统计点击数等应用。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能；</p><p>命令：INCRBY</p></blockquote><p><strong>三：队列</strong></p><blockquote><p>相当于消息系统，ActiveMQ，RocketMQ等工具类似，如果对于数据一致性要求高的话还是用RocketMQ等专业系统。</p><p>由于redis把数据添加到队列是返回添加元素在队列的第几位，所以可以做判断用户是第几个访问这种业务；队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用。</p></blockquote><p><strong>四：位操作（大数据处理）</strong></p><blockquote><p>用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等。</p><p>想想一下腾讯10亿用户，要几个毫秒内查询到某个用户是否在线，你能怎么做？这里要用到位操作——使用setbit、getbit、bitcount命令。</p></blockquote><p>原理是：</p><blockquote><p>redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统，上面我说的几个场景也就能够实现。用到的命令是：setbit、getbit、bitcount。</p></blockquote><p><strong>五：分布式锁与单线程机制</strong></p><blockquote><p>验证前端的重复请求（可以自由扩展类似情况），可以通过redis进行过滤：每次请求将request ip、参数、接口等hash作为key存储redis(幂等性请求)，设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复提交秒杀系统，基于redis是单线程特征，防止出现数据库’爆破’全局增量ID生成，类似’秒杀’。</p></blockquote><p><strong>六：最新列表</strong></p><blockquote><p>例如新闻列表页面最新的新闻列表，如果总数量很大的情况下，尽量不要使用select a from A limit 10这种low货，尝试redis的 LPUSH命令构建List，一个个顺序都塞进去就可以啦。不过万一内存清掉了咋办？也简单，查询不到存储key的话，用mysql查询并且初始化一个List到redis中就好了。</p></blockquote><p><strong>七：排行榜</strong></p><blockquote><p>谁得分高谁排名往上。命令：ZADD（有续集，sorted set）</p></blockquote><p><strong>八: 适用场景：</strong></p><blockquote><p>数据高并发的读写；</p><p>海量数据的读写；</p><p>对扩展性要求高的数据。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang使用redis（go-redis）</title>
      <link href="/2022/03/25/golang%E4%BD%BF%E7%94%A8redis%EF%BC%88go-redis%EF%BC%89/"/>
      <url>/2022/03/25/golang%E4%BD%BF%E7%94%A8redis%EF%BC%88go-redis%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="golang使用redis（go-redis）"><a href="#golang使用redis（go-redis）" class="headerlink" title="golang使用redis（go-redis）"></a>golang使用redis（go-redis）</h1><h3 id="使用的库为"><a href="#使用的库为" class="headerlink" title="使用的库为"></a>使用的库为</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br></pre></td></tr></table></figure><h3 id="redis连接"><a href="#redis连接" class="headerlink" title="redis连接"></a>redis连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rdb *redis.Client</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RedisSetup</span><span class="params">()</span></span>  &#123;</span><br><span class="line">rdb = redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">&quot;101.200.87.232:6379&quot;</span>,</span><br><span class="line">Password: <span class="string">&quot;sdl@admin&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">DB:       <span class="number">0</span>,           <span class="comment">// 使用的数据库名称</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="写入数据（string格式）"><a href="#写入数据（string格式）" class="headerlink" title="写入数据（string格式）"></a>写入数据（string格式）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">UserId <span class="keyword">string</span></span><br><span class="line">RoleId <span class="keyword">string</span></span><br><span class="line">IP     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data := global.Cookie&#123;one.ID.Hex(), one.RoleID.Hex(), c.ClientIP()&#125;</span><br><span class="line"><span class="comment">//将对象序列化，redis不能直接存入对象，必须经过这个转化</span></span><br><span class="line">data2, _ := json.Marshal(data)</span><br><span class="line"><span class="comment">//这里最后的参数必须使用time包，因为他的格式是time.Duration，并且如果没有使用time包，直接使用数字，不会报错，但不会存人redis中</span></span><br><span class="line">err := rdb.Set(context.Background(), one.ID.Hex(), data2, time.Minute*<span class="number">30</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        pianc(err)<span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取数据（string格式）"><a href="#读取数据（string格式）" class="headerlink" title="读取数据（string格式）"></a>读取数据（string格式）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data *global.Cookie</span><br><span class="line">val, err := rdb.Get(context.Background(), session).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">pianc(err)<span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal([]<span class="keyword">byte</span>(val), &amp;data); err != <span class="literal">nil</span> &#123;<span class="comment">//反序列化，将序列化的字节流转化成原来的对象</span></span><br><span class="line">pianc(err)<span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改时长"><a href="#修改时长" class="headerlink" title="修改时长"></a>修改时长</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdb.Expire(context.Background(), session, time.Hour*<span class="number">1</span>)<span class="comment">//其中session是key，后面的是修改后的有效时长。</span></span><br></pre></td></tr></table></figure><h3 id="hash散列"><a href="#hash散列" class="headerlink" title="hash散列"></a>hash散列</h3><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdb.HSet(context.Background(), <span class="string">&quot;key&quot;</span>, <span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)<span class="comment">//方式一</span></span><br><span class="line">rdb.HSet(context.Background(), <span class="string">&quot;key&quot;</span>, []<span class="keyword">string</span>&#123;<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>&#125;)<span class="comment">//方式二</span></span><br><span class="line">rdb.HSet(context.Background(), <span class="string">&quot;key&quot;</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;key1&quot;</span>: <span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>: <span class="string">&quot;value2&quot;</span>&#125;)<span class="comment">//方式三</span></span><br></pre></td></tr></table></figure><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdb.HGet(context.Background(), <span class="string">&quot;key&quot;</span>, <span class="string">&quot;key1&quot;</span>)<span class="comment">//读取hash中的单个数据，即得到value1</span></span><br><span class="line">rdb.HGetAll(context.Background(), <span class="string">&quot;key&quot;</span>)<span class="comment">//读取hash中的全部数据</span></span><br></pre></td></tr></table></figure><h3 id="list列表"><a href="#list列表" class="headerlink" title="list列表"></a>list列表</h3><h3 id="set集合"><a href="#set集合" class="headerlink" title="set集合"></a>set集合</h3><h3 id="zset有序集合"><a href="#zset有序集合" class="headerlink" title="zset有序集合"></a>zset有序集合</h3><h3 id="PubSub发布订阅"><a href="#PubSub发布订阅" class="headerlink" title="PubSub发布订阅"></a>PubSub发布订阅</h3><h4 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdb.Publish(context.Background(), <span class="string">&quot;testChannel&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//testChannel是channel的名称，hello是发送的消息</span></span><br></pre></td></tr></table></figure><h4 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;<span class="comment">//使用携程</span></span><br><span class="line">pubsub := rdb.Subscribe(context.Background(), <span class="string">&quot;testChannel&quot;</span>)</span><br><span class="line">ch := pubsub.Channel()</span><br><span class="line"><span class="comment">//同时接收消息的Go通道。该频道与PubSub一起关闭。如果Go频道被完全阻止30秒，消息被丢弃。创建通道后，无法使用、、Receive*API。</span></span><br><span class="line"><span class="keyword">for</span> msg := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(msg.Channel, msg.Payload)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h4 id="Redis发布订阅模式-与-消息中间件（rabbitmq）-进行对比"><a href="#Redis发布订阅模式-与-消息中间件（rabbitmq）-进行对比" class="headerlink" title="Redis发布订阅模式 与 消息中间件（rabbitmq） 进行对比"></a>Redis发布订阅模式 与 消息中间件（rabbitmq） 进行对比</h4><h5 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h5><p>Redis虽然可以实现发布订阅，其功能与常见的消息中间件类似（例如RabbitMQ），但是 <strong>Redis的发布订阅模式不支持持久化，而且发布者发布一条消息，没有对应的消费者时，消息会丢失。</strong></p><p>而RabbitMQ具有消息消费的确认机制，发布者发布一条消息，一直在队列中，直到消息被消费。</p><h5 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h5><p>Redis作为高效的缓存服务器，基于内存，发布的消息不需要持久化，具备更高的实时性。</p><h5 id="消费者的负载均衡"><a href="#消费者的负载均衡" class="headerlink" title="消费者的负载均衡"></a>消费者的负载均衡</h5><p>rabbitmq队列可以被多个消费者同时监控消费，但是每一条消息只能被消费一次，由于rabbitmq的消费确认机制，因此它能够根据消费者的消费能力而调整它的负载；</p><p><strong>redis发布订阅模式</strong>，一个队列可以被多个消费者同时订阅，当有消息到达时，会将该消息依次发送给每个订阅者；</p><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><p><strong>redis</strong>：redis的持久化是针对于整个redis缓存的内容，它有RDB和AOF两种持久化方式（redis持久化方式，后续更新），可以将整个redis实例持久化到磁盘，以此来做数据备份，防止异常情况下导致数据丢失。</p><p><strong>rabbitmq</strong>：队列，消息都可以选择性持久化，持久化粒度更小，更灵活；</p><h5 id="队列监控"><a href="#队列监控" class="headerlink" title="队列监控"></a>队列监控</h5><p><strong>rabbitmq实现了后台监控平台</strong>，可以在该平台上看到所有创建的队列的详细情况，良好的后台管理平台可以方面我们更好的使用；<strong>redis没有所谓的监控平台</strong>。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p><strong>redis</strong>： 轻量级，低延迟，高并发，低可靠性；</p><p><strong>rabbitmq</strong>：重量级，高可靠，异步，不保证实时；</p><p>rabbitmq是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-zero的学习</title>
      <link href="/2022/03/23/go-zero%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/03/23/go-zero%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="go-zero的学习"><a href="#go-zero的学习" class="headerlink" title="go-zero的学习"></a>go-zero的学习</h1><h3 id="在学习go-micro的过程中无意间看见了go-zero这个微服务框架。go-zero有着完善的文档"><a href="#在学习go-micro的过程中无意间看见了go-zero这个微服务框架。go-zero有着完善的文档" class="headerlink" title="在学习go micro的过程中无意间看见了go-zero这个微服务框架。go-zero有着完善的文档"></a>在学习go micro的过程中无意间看见了go-zero这个微服务框架。go-zero有着完善的文档</h3><p><a href="https://go-zero.dev/cn/">https://go-zero.dev/cn/</a></p><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><p>go-zero使用了etcd实现了服务发现与治理，使用grpc作为rpc框架，protoc作为rpc传输的格式。</p><p>还支持k8s集群，jenkins持续集成。</p><p>另外框架提供了一个辅助工具goctl，借助这个工具我们可以快速的完成微服务项目的搭建。</p><span id="more"></span><h3 id="微服务项目快速搭建"><a href="#微服务项目快速搭建" class="headerlink" title="微服务项目快速搭建"></a>微服务项目快速搭建</h3><p><a href="https://go-zero.dev/cn/micro-service.html">https://go-zero.dev/cn/micro-service.html</a> </p><h3 id="微服务思路"><a href="#微服务思路" class="headerlink" title="微服务思路"></a>微服务思路</h3><p>借助go-zero官网的例子，我对微服务的了解更加深刻了。</p><p>对于直接面向客户的模块就暴露api供客户使用，与其他模块之间的通信使用rpc。模块的切割需要慎重，最好是单向通信，不要有多余的耦合。</p><h3 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h3><ul><li>单一职责，此时项目专注于登录和注册</li><li>轻量级的通信，通信与平台和语言无关，http是轻量的，例如java的RMI属于重量的</li><li>隔离性，数据隔离</li><li>有自己的数据</li><li>技术多样性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin 中间件</title>
      <link href="/2022/03/13/gin%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2022/03/13/gin%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin-中间件"><a href="#Gin-中间件" class="headerlink" title="Gin 中间件"></a>Gin 中间件</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义中间件第1种定义方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CustomRouterMiddle1</span><span class="params">(c *gin.Context)</span></span>  &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是自定义中间件第1种定义方式---请求之前&quot;</span>)</span><br><span class="line"><span class="comment">//在gin上下文中定义一个变量</span></span><br><span class="line">c.Set(<span class="string">&quot;example&quot;</span>, <span class="string">&quot;CustomRouterMiddle1&quot;</span>)</span><br><span class="line"><span class="comment">//请求之前</span></span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是自定义中间件第1种定义方式---请求之后&quot;</span>)</span><br><span class="line"><span class="comment">//请求之后</span></span><br><span class="line"><span class="comment">//计算整个请求过程耗时</span></span><br><span class="line">t2 := time.Since(t)</span><br><span class="line">log.Println(t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义中间件第2种定义方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CustomRouterMiddle2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是自定义中间件第2种定义方式---请求之前&quot;</span>)</span><br><span class="line"><span class="comment">//在gin上下文中定义一个变量</span></span><br><span class="line">c.Set(<span class="string">&quot;example&quot;</span>, <span class="string">&quot;CustomRouterMiddle2&quot;</span>)</span><br><span class="line"><span class="comment">//请求之前</span></span><br><span class="line">c.Next()</span><br><span class="line">fmt.Println(<span class="string">&quot;我是自定义中间件第2种定义方式---请求之后&quot;</span>)</span><br><span class="line"><span class="comment">//请求之后</span></span><br><span class="line"><span class="comment">//计算整个请求过程耗时</span></span><br><span class="line">t2 := time.Since(t)</span><br><span class="line">log.Println(t2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在egg中写这个有滞后处理的中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">responseTime</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  ctx.set(<span class="string">&#x27;X-Response-Time&#x27;</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin Mode的选择</title>
      <link href="/2022/03/07/gin%20Mode%E7%9A%84%E9%80%89%E6%8B%A9/"/>
      <url>/2022/03/07/gin%20Mode%E7%9A%84%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="Gin-Mode的选择"><a href="#Gin-Mode的选择" class="headerlink" title="Gin Mode的选择"></a>Gin Mode的选择</h1><h4 id="我在阅读别人的代码的时候，发现下列这行代码。"><a href="#我在阅读别人的代码的时候，发现下列这行代码。" class="headerlink" title="我在阅读别人的代码的时候，发现下列这行代码。"></a>我在阅读别人的代码的时候，发现下列这行代码。</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gin.SetMode(gin.ReleaseMode)</span><br></pre></td></tr></table></figure><h4 id="本来不懂为什么需要设定模式，查看了gin源码，发现该框架提供了下列三种模式。"><a href="#本来不懂为什么需要设定模式，查看了gin源码，发现该框架提供了下列三种模式。" class="headerlink" title="本来不懂为什么需要设定模式，查看了gin源码，发现该框架提供了下列三种模式。"></a>本来不懂为什么需要设定模式，查看了gin源码，发现该框架提供了下列三种模式。</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// DebugMode indicates gin mode is debug.</span></span><br><span class="line">DebugMode = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">// ReleaseMode indicates gin mode is release.</span></span><br><span class="line">ReleaseMode = <span class="string">&quot;release&quot;</span></span><br><span class="line"><span class="comment">// TestMode indicates gin mode is test.</span></span><br><span class="line">TestMode = <span class="string">&quot;test&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="而且我们每次启动gin服务器，如果不加"><a href="#而且我们每次启动gin服务器，如果不加" class="headerlink" title="而且我们每次启动gin服务器，如果不加"></a>而且我们每次启动gin服务器，如果不加</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gin.SetMode(gin.ReleaseMode)</span><br></pre></td></tr></table></figure><h4 id="这一段，就会输出一段提示"><a href="#这一段，就会输出一段提示" class="headerlink" title="这一段，就会输出一段提示"></a>这一段，就会输出一段提示</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[WARNING] Running in <span class="string">&quot;debug&quot;</span> mode. Switch to <span class="string">&quot;release&quot;</span> mode in production.</span><br><span class="line"></span><br><span class="line"> - using env:   export GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br></pre></td></tr></table></figure><h4 id="所以，现在我们就可以明白了，这三种mode分别对应了不同的场景。在我们开发调试过程中，使用debug模式就可以了。在上线的时候，一定要选择release模式。而test可以用在测试场景中。"><a href="#所以，现在我们就可以明白了，这三种mode分别对应了不同的场景。在我们开发调试过程中，使用debug模式就可以了。在上线的时候，一定要选择release模式。而test可以用在测试场景中。" class="headerlink" title="所以，现在我们就可以明白了，这三种mode分别对应了不同的场景。在我们开发调试过程中，使用debug模式就可以了。在上线的时候，一定要选择release模式。而test可以用在测试场景中。"></a>所以，现在我们就可以明白了，这三种mode分别对应了不同的场景。在我们开发调试过程中，使用debug模式就可以了。在上线的时候，一定要选择release模式。而test可以用在测试场景中。</h4>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2022/03/06/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2022/03/06/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>算法：当数据量很大适宜采用该方法。采用二分法查找时，数据需是排好序的。</p><p>基本思想：假设数据是按升序排序的，对于给定值x，从序列的中间位置开始比较，如果当前位置值等于x，则查找成功；若x小于当前位置值，则在数列的前半段中查找；若x大于当前位置值则在数列的后半段中继续查找，直到找到为止。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">7</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">find := <span class="number">7</span></span><br><span class="line">low := <span class="number">0</span></span><br><span class="line">high := <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="comment">//int类型做除法会自动向下取整，结果还是int类型</span></span><br><span class="line"><span class="keyword">for</span> a[(low+high)/<span class="number">2</span>] != find &#123;</span><br><span class="line"><span class="keyword">if</span> a[(low+high)/<span class="number">2</span>] &gt; find &#123;</span><br><span class="line">high = (low + high) / <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = (low + high) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a[(low+high)/<span class="number">2</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h4><blockquote><p><strong>二叉树( Binary Tree )是n( n≥0 )个结点的有限集合，该集合或者空集( 称为空二叉树 )，或者由一个根节点和两棵互不相交的，分别称为根节点的左子树和右子树的二叉树组成。例如：图中就是一颗二叉树。</strong><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p></blockquote><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ul><li>每个结点最多有两棵子树。</li><li>左子树和右子树是有顺序的。</li><li>即使树中某结点只有一棵子树，也要区分左右。</li></ul><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况:"></a><strong>特殊情况:</strong></h4><ol><li> <strong>斜树：所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树 所以在极端情况下二叉树会退化成线性表（线性表是树的特殊表现形式），这种情况也称之为非平衡树。例如：</strong><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></li><li><strong>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树 满二叉树是一种平衡二叉树。例如：</strong><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_20,color_FFFFFF,t_70,g_se,x_16-16495757345303.png" alt="img"></li><li><strong>完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，( 即树中结点的分布从左到右依次布满 )则这颗二叉树称为完全二叉树 完全二叉树也是一种平衡二叉树。例如：</strong><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_19,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></li></ol><h4 id="二叉树的顺序存储结构："><a href="#二叉树的顺序存储结构：" class="headerlink" title="二叉树的顺序存储结构："></a><strong>二叉树的顺序存储结构：</strong></h4><p><strong>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现出之间的逻辑关系。如：</strong></p><p><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_20,color_FFFFFF,t_70,g_se,x_16-16495759995786.png" alt="img"></p><blockquote><p><em><strong>*但是顺序存储结构在极端情况下浪费空间，只适合平衡树的存储。*</strong></em></p></blockquote><p><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_20,color_FFFFFF,t_70,g_se,x_16-16495759995797.png" alt="img"></p><p><strong>二叉树的链式存储结构：</strong></p><p><strong>二叉树每个结点最多有两个孩子，所以设计为一个数据域和两个指针域的结点进行链接，这种链表也叫作二叉链表。</strong></p><p><strong>如图是二叉链表结点的定义：</strong></p><p><img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_20,color_FFFFFF,t_70,g_se,x_16-164957603032210.png" alt="img"></p><p><strong>如图是二叉树的链式存储结构：</strong> </p><p> <img src="/images/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATmFuY3lMQ0w=,size_20,color_FFFFFF,t_70,g_se,x_16-164957603032311.png" alt="img"></p><h4 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a><strong>遍历：</strong></h4><p><strong>主要分为两类：*<em>深度优先遍历DFS和广度优先遍历BFS*</em></strong>  </p><ol><li><strong>深度优先遍历：前序遍历，中序遍历，后序遍历</strong>      </li><li><strong>广度优先遍历：层序遍历</strong></li></ol><p><strong>链式存储的结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">Val   <span class="keyword">int</span></span><br><span class="line">Left  *TreeNode</span><br><span class="line">Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度优先遍历："><a href="#深度优先遍历：" class="headerlink" title="深度优先遍历："></a>深度优先遍历：</h4><ol><li><p><strong>前序遍历( DLR )：规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。</strong></p></li><li><p><strong>中序遍历( LDR )：规则是若二叉树为空，则空操作返回，否则从根结点开始，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。</strong></p></li><li><p><strong>后序遍历( LRD )：规则是若二叉树为空，则空操作返回，否则从根结点开始，后序遍历根节点的左子树，然后后序遍历右子树，最后访问根节点。</strong></p></li></ol><h4 id="广度优先遍历："><a href="#广度优先遍历：" class="headerlink" title="广度优先遍历："></a><strong>广度优先遍历：</strong></h4><p><strong>层序遍历：规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限管理之Casbin（二）</title>
      <link href="/2022/03/03/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E4%B9%8BCasbin%20(%E4%BA%8C)/"/>
      <url>/2022/03/03/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E4%B9%8BCasbin%20(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h1 id="权限管理之Casbin（二）"><a href="#权限管理之Casbin（二）" class="headerlink" title="权限管理之Casbin（二）"></a>权限管理之Casbin（二）</h1><p>在阅读gin-vue-admin的代码后发现完整的使用casbin再将其整合进原有的权限是一个繁琐的工作。</p><p>比如角色和用户的管理，在casbin中这个会使用专门的g来记录角色和用户之间的关系，但由于casbin的简约，单纯使用casbin无法获取到用户的角色的全部信息，需要同时使用casbin的api和自己实现的辅助的api，在这种方面，权限管理加上casbin反而会拖累编写速度。</p><p>Casbin官网：<a href="https://casbin.org/zh-CN/">Casbin</a>（有中文翻译）</p><h2 id="现在的想法"><a href="#现在的想法" class="headerlink" title="现在的想法"></a>现在的想法</h2><p>使用casbin记录角色与其拥有的权限，不在使用casbin记录角色和用户之间的关系。角色与用户由自己来实现关联。</p><p>并且casbin中有方法可以直接拿到用户所拥有的api列表。</p><blockquote><p><strong>GetFilteredPolicy()</strong></p><p>GetFilteredPolicy 获取策略中的所有授权规则，我们可以指定字段筛选器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filteredPolicy := e.GetFilteredPolicy(<span class="number">0</span>, <span class="string">&quot;alice&quot;</span>)</span><br></pre></td></tr></table></figure></blockquote><p>现在权限结构是</p><blockquote><p><strong>利用casbin来过滤请求和管理角色能调用的api</strong></p><p><strong>其他部分由用户自己实现</strong></p></blockquote><table><thead><tr><th>表名</th><th>作用</th></tr></thead><tbody><tr><td>casbin</td><td>记录角色和api之间的关系</td></tr><tr><td>role</td><td>记录role的名字</td></tr><tr><td>user</td><td>记录用户基本信息和角色的_id</td></tr><tr><td>api</td><td>记录api的基本信息</td></tr></tbody></table><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>casbin连接mongo</title>
      <link href="/2022/03/03/casbin%E8%BF%9E%E6%8E%A5mongo/"/>
      <url>/2022/03/03/casbin%E8%BF%9E%E6%8E%A5mongo/</url>
      
        <content type="html"><![CDATA[<h1 id="casbin连接mongo"><a href="#casbin连接mongo" class="headerlink" title="casbin连接mongo"></a>casbin连接mongo</h1><p>casbin中的Policy（策略）可以存储在数据库中</p><blockquote><p>其中连接mongodb的方式是第三方库</p><p>github.com/casbin/mongodb-adapter/v3</p></blockquote><h4 id="普通连接方式代码"><a href="#普通连接方式代码" class="headerlink" title="普通连接方式代码"></a>普通连接方式代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/casbin/casbin&quot;</span></span><br><span class="line">mongodbadapter <span class="string">&quot;github.com/casbin/mongodb-adapter&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> E *casbin.SyncedEnforcer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CasbinSetup</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 要使用自己定义的数据库rbac_db,最后的true很重要.默认为false,使用缺省的数据库名casbin,不存在则创建</span></span><br><span class="line"></span><br><span class="line">a := mongodbadapter.NewAdapter(<span class="string">&quot;127.0.0.1:27017/casbin&quot;</span>)</span><br><span class="line"></span><br><span class="line">E = casbin.NewSyncedEnforcer(<span class="string">&quot;./rbac_models.conf&quot;</span>, a)</span><br><span class="line"><span class="comment">//从DB加载策略</span></span><br><span class="line">_ = E.LoadPolicy()</span><br><span class="line"><span class="comment">//E.StartAutoLoadPolicy(time.Hour)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当尝试将连接mongodb的url替换成带有账号密码的url时报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: server returned error on SASL authentication step: Authentication failed.</span><br><span class="line"><span class="comment">//服务器在SASL身份验证步骤上返回错误：身份验证失败。</span></span><br></pre></td></tr></table></figure> <span id="more"></span><h4 id="高级的连接方式代码"><a href="#高级的连接方式代码" class="headerlink" title="高级的连接方式代码"></a>高级的连接方式代码</h4><p>使用这种连接方式时没有报错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/casbin/casbin/v2&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/casbin/mongodb-adapter/v3&quot;</span></span><br><span class="line">mongooptions <span class="string">&quot;go.mongodb.org/mongo-driver/mongo/options&quot;</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> E *casbin.SyncedEnforcer</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CasbinSetup</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">mongoClientOption := mongooptions.Client().ApplyURI(<span class="string">&quot;mongodb://admin:sdl%40admin@101.200.55.232:27017&quot;</span>)</span><br><span class="line">databaseName := <span class="string">&quot;ProjectProMax&quot;</span></span><br><span class="line">a,err := mongodbadapter.NewAdapterWithClientOption(mongoClientOption, databaseName)</span><br><span class="line"><span class="comment">// Or you can use NewAdapterWithCollectionName for custom collection name.</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E, err := casbin.NewSyncedEnforcer(<span class="string">&quot;./rbac_models.conf&quot;</span>, a)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E.LoadPolicy()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo-driver中objectid转换</title>
      <link href="/2022/03/03/mongo-driver%E4%B8%ADobjectid%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/03/03/mongo-driver%E4%B8%ADobjectid%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="mongo-driver中objectid转换"><a href="#mongo-driver中objectid转换" class="headerlink" title="mongo-driver中objectid转换"></a>mongo-driver中objectid转换</h1><p>由于每次都忘记，特地记录</p><p><strong>string-&gt;objectid</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectid, err := primitive.ObjectIDFromHex(strig)</span><br></pre></td></tr></table></figure><p><strong>objectid-&gt;string</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string=objectid.Hex()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用zap的问题</title>
      <link href="/2022/03/03/%E4%BD%BF%E7%94%A8zap%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/03/%E4%BD%BF%E7%94%A8zap%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="使用zap的问题"><a href="#使用zap的问题" class="headerlink" title="使用zap的问题"></a>使用zap的问题</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Println(<span class="keyword">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行之后会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get www.google.com: unsupported protocol scheme &quot;&quot;</span><br></pre></td></tr></table></figure><p>原因是</p><blockquote><p>Get的网址有误，应在其前面添加”http://“或”https://“，具体添加哪个要看你要打开的网站使用哪个协议</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux上运行编译后的go程序</title>
      <link href="/2021/12/29/linux%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84go%E7%A8%8B%E5%BA%8F/"/>
      <url>/2021/12/29/linux%E4%B8%8A%E8%BF%90%E8%A1%8C%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84go%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="linux上运行编译后的go程序"><a href="#linux上运行编译后的go程序" class="headerlink" title="linux上运行编译后的go程序"></a>linux上运行编译后的go程序</h1><p>go 在windows编译出linux上运行的二进制文件<br>先设置配置文件(再cmd中设置,只能起短暂左右,该cmd关闭就无效了,)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set GOARCH=amd64</span><br><span class="line">set GOOS=linux</span><br></pre></td></tr></table></figure><p>最后执行 go build</p><span id="more"></span><p>生成的就不是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序名称.exe</span><br></pre></td></tr></table></figure><p>而是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序名称</span><br></pre></td></tr></table></figure><p>上传到linux</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 程序名称</span><br><span class="line">nohup ./程序名称 &amp;</span><br><span class="line">//后面带&amp;是为了后台运行，防止终端关闭时程序退出。运行状态可以用 “jobs -l” 来查看。</span><br></pre></td></tr></table></figure><p>执行</p><p><img src="/images/image-20211229143503865.png" alt="image-20211229143503865"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限管理之Casbin</title>
      <link href="/2021/12/04/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E4%B9%8BCasbin/"/>
      <url>/2021/12/04/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E4%B9%8BCasbin/</url>
      
        <content type="html"><![CDATA[<h1 id="权限管理之Casbin"><a href="#权限管理之Casbin" class="headerlink" title="权限管理之Casbin"></a>权限管理之Casbin</h1><p>权限管理在几乎每个系统中都是必备的模块。如果项目开发每次都要实现一次权限管理，无疑会浪费开发时间，增加开发成本。因此，<code>casbin</code>库出现了。<code>casbin</code>是一个强大、高效的访问控制库。支持常用的多种访问控制模型，如<code>ACL/RBAC/ABAC</code>等。可以实现灵活的访问权限控制。同时，<code>casbin</code>支持多种编程语言，<code>Go/Java/Node/PHP/Python/.NET/Rust</code>。我们只需要<strong>一次学习，多处运用</strong>。</p><p>Casbin官网：<a href="https://casbin.org/zh-CN/">Casbin</a>（有中文翻译）</p><h2 id="官方对casbin的说法"><a href="#官方对casbin的说法" class="headerlink" title="官方对casbin的说法"></a>官方对casbin的说法</h2><span id="more"></span><p>Casbin可以做到：</p><ol><li>支持自定义请求的格式，默认的请求格式为<code>&#123;subject, object, action&#125;</code>。</li><li>具有访问控制模型model和策略policy两个核心概念。</li><li>支持RBAC中的多层角色继承，不止主体可以有角色，资源也可以具有角色。</li><li>支持超级用户，如<code>root</code>或<code>Administrator</code>，超级用户可以不受授权策略的约束访问任意资源。</li><li>支持多种内置的操作符，如<code>keyMatch</code>，方便对路径式的资源进行管理，如<code>/foo/bar</code>可以映射到<code>/foo*</code></li></ol><p>Casbin不能做到：</p><ol><li>身份认证 authentication（即验证用户的用户名、密码），casbin只负责访问控制。应该有其他专门的组件负责身份认证，然后由casbin进行访问控制，二者是相互配合的关系。</li><li>管理用户列表或角色列表。 Casbin 认为由项目自身来管理用户、角色列表更为合适， 用户通常有他们的密码，但是 Casbin 的设计思想并不是把它作为一个存储密码的容器。 而是存储RBAC方案中用户和角色之间的映射关系。</li></ol><blockquote><p>casbin只是完成了权限管理的方面，对于用户的身份认证，需要自己完成</p></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在 Casbin 中, 访问控制模型被抽象为基于 <strong>PERM (Policy, Effect, Request, Matcher)</strong> 的一个文件。 因此，切换或升级项目的授权机制与修改配置一样简单。 您可以通过组合可用的模型来定制您自己的访问控制模型。 例如，您可以在一个model中结合RBAC角色和ABAC属性，并共享一组policy规则。</p><p>PERM模式由四个基础（政策、效果、请求、匹配）组成，描述了资源与用户之间的关系。</p><h1 id="支持的Models"><a href="#支持的Models" class="headerlink" title="支持的Models"></a>支持的Models</h1><ol><li>ACL (Access Control List, 访问控制列表)</li><li><strong>具有 超级用户的 ACL</strong></li><li><strong>没有用户的 ACL</strong>: 对于没有身份验证或用户登录的系统尤其有用。</li><li><strong>没有资源的 ACL</strong>: 某些场景可能只针对资源的类型, 而不是单个资源, 诸如 <code>write-article</code>, <code>read-log</code>等权限。 它不控制对特定文章或日志的访问。</li><li>RBAC (基于角色的访问控制)</li><li><strong>支持资源角色的RBAC</strong>: 用户和资源可以同时具有角色 (或组)。</li><li><strong>支持域/租户的RBAC</strong>: 用户可以为不同的域/租户设置不同的角色集。</li><li>ABAC (基于属性的访问控制)**: 支持利用<code>resource.Owner</code>这种语法糖获取元素的属性。</li><li>**RESTful: 支持路径, 如 <code>/res/*</code>, <code>/res/: id</code> 和 HTTP 方法, 如 <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>。</li><li><strong>拒绝优先</strong>: 支持允许和拒绝授权, 拒绝优先于允许。</li><li><strong>优先级</strong>: 策略规则按照先后次序确定优先级，类似于防火墙规则。</li></ol><p>这些在casbin都有示例，直接使用就行</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于jwt和session对比</title>
      <link href="/2021/12/04/%E5%85%B3%E4%BA%8Ejwt%E5%92%8Csession%E5%AF%B9%E6%AF%94/"/>
      <url>/2021/12/04/%E5%85%B3%E4%BA%8Ejwt%E5%92%8Csession%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="关于jwt和session对比"><a href="#关于jwt和session对比" class="headerlink" title="关于jwt和session对比"></a>关于jwt和session对比</h1><p>在权限的理解中我提到了jwt和session两种认证的方法，现在我们来进行对比</p><h2 id="jwt的详细介绍"><a href="#jwt的详细介绍" class="headerlink" title="jwt的详细介绍"></a>jwt的详细介绍</h2><h3 id="JWT概念"><a href="#JWT概念" class="headerlink" title="JWT概念"></a>JWT概念</h3><p><code>JSON Web Token</code>（缩写 <code>JWT</code>）是目前最流行的跨域认证解决方案。</p><span id="more"></span><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>jwt的头部承载两部分信息：</p><ul><li>声明类型，这里是jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的头部就像下面这样的JSON：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;typ&#x27;: &#x27;JWT&#x27;,</span><br><span class="line">  &#x27;alg&#x27;: &#x27;HS256&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="playload"><a href="#playload" class="headerlink" title="playload"></a>playload</h3><p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p><ul><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ul><p><strong>标准中注册的声明 (建议但不强制使用) ：</strong></p><ul><li>iss: jwt签发者</li><li>sub: jwt所面向的用户</li><li>aud: 接收jwt的一方</li><li>exp: jwt的过期时间，这个过期时间必须要大于签发时间</li><li>nbf: 定义在什么时间之前，该jwt都是不可用的</li><li>iat: jwt的签发时间</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</li><li>aud：用户</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StandardClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">Audience  <span class="keyword">string</span> <span class="string">`json:&quot;aud,omitempty&quot;`</span><span class="comment">//jwt用户</span></span><br><span class="line">ExpiresAt <span class="keyword">int64</span>  <span class="string">`json:&quot;exp,omitempty&quot;`</span><span class="comment">// jwt的过期时间，这个过期时间必须要大于签发时间</span></span><br><span class="line">Id        <span class="keyword">string</span> <span class="string">`json:&quot;jti,omitempty&quot;`</span><span class="comment">//jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</span></span><br><span class="line">IssuedAt  <span class="keyword">int64</span>  <span class="string">`json:&quot;iat,omitempty&quot;`</span><span class="comment">//jwt的签发时间</span></span><br><span class="line">Issuer    <span class="keyword">string</span> <span class="string">`json:&quot;iss,omitempty&quot;`</span><span class="comment">//jwt签发者</span></span><br><span class="line">NotBefore <span class="keyword">int64</span>  <span class="string">`json:&quot;nbf,omitempty&quot;`</span><span class="comment">//定义在什么时间之前，该jwt都是不可用的</span></span><br><span class="line">Subject   <span class="keyword">string</span> <span class="string">`json:&quot;sub,omitempty&quot;`</span><span class="comment">//jwt所面向的用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>公共的声明</strong> ：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p><p><strong>私有的声明</strong> ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>定义一个payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h3><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>这个部分需要base64加密后的header和base64加密后的payload使用<code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐<code>secret</code>组合加密，然后就构成了jwt的第三部分。</p><blockquote><p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p></blockquote><h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><p>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>客户端收到服务器返回的 JWT，可以储存在 Cookie里面，也可以储存在 localStorage<br>放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息 Authorization 字段里面</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数<br>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑<br>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证</p><h2 id="session-cookie的详细介绍"><a href="#session-cookie的详细介绍" class="headerlink" title="session-cookie的详细介绍"></a>session-cookie的详细介绍</h2><blockquote><ol><li><p>session 在服务器端，cookie 在客户端（浏览器）</p></li><li><p> session 默认被存在在服务器的一个文件里（不是内存）</p></li><li><p> session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会</p></li></ol><p>   失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）</p><ol start="4"><li><p> session 可以放在 文件、数据库、或内存中都可以。</p></li><li><p> 用户验证这种场合一般会用 session</p></li></ol></blockquote><p><img src="/images/Center.png" alt="img"></p><p>在设置 Cookie 值的同时，协议还支持许多参数来配置这个 Cookie 的传输、存储和权限。</p><table><thead><tr><th>maxAge</th><th>Number</th><th>设置这个键值对在浏览器的最长保存时间。是一个从服务器当前时刻开始的毫秒数。</th></tr></thead><tbody><tr><td>expires</td><td>Date</td><td>设置这个键值对的失效时间，如果设置了 maxAge，expires 将会被覆盖。如果 maxAge 和 expires 都没设置，Cookie 将会在浏览器的会话失效（一般是关闭浏览器时）的时候失效。</td></tr><tr><td>path</td><td>String</td><td>设置键值对生效的 URL 路径，默认设置在根路径上（<code>/</code>），也就是当前域名下的所有 URL 都可以访问这个 Cookie。</td></tr><tr><td>domain</td><td>String</td><td>设置键值对生效的域名，默认没有配置，可以配置成只在指定域名才能访问。</td></tr><tr><td>httpOnly</td><td>Boolean</td><td>设置键值对是否可以被 js 访问，默认为 true，不允许被 js 访问。</td></tr><tr><td>secure</td><td>Boolean</td><td>设置键值对只在 HTTPS 连接上传输，框架会帮我们判断当前是否在 HTTPS 连接上自动设置 secure 的值。</td></tr></tbody></table><p><strong>默认的配置下，Cookie 是加签不加密的，浏览器可以看到明文，js 不能访问，不能被客户端（手工）篡改。</strong></p><h2 id="使用jwt的优点"><a href="#使用jwt的优点" class="headerlink" title="使用jwt的优点"></a>使用jwt的优点</h2><h3 id="天然支持分布式验证；"><a href="#天然支持分布式验证；" class="headerlink" title="天然支持分布式验证；"></a>天然支持分布式验证；</h3><p>由于jwt是直接发给客户端的，服务端并没有进行保存。只要同一了secret，就可以实现分布式。服务器端可以<strong>无限扩展</strong>，负载均衡器可以将<strong>用户传递到任何服务器</strong>，服务器都能知道用户信息，因为jwt里面包含了。</p><h3 id="高并发下降低服务器压力；"><a href="#高并发下降低服务器压力；" class="headerlink" title="高并发下降低服务器压力；"></a>高并发下降低服务器压力；</h3><p>因为token存储在客户端，服务器只负责解码。这样<strong>不需要占用服务器端资源</strong></p><h3 id="无状态和可扩展性；"><a href="#无状态和可扩展性；" class="headerlink" title="无状态和可扩展性；"></a>无状态和可扩展性；</h3><p>Tokens存储在客户端。完全无状态，可扩展。我们的负载均衡器可以将用户传递到任意服务器，因为在任何地方都没有状态或会话信息。</p><h3 id="更安全，可防止CSRF；（很大的误会）"><a href="#更安全，可防止CSRF；（很大的误会）" class="headerlink" title="更安全，可防止CSRF；（很大的误会）"></a>更安全，可防止CSRF；（很大的误会）</h3><blockquote><p>大部分文章声称：jwt放入请求头提交，很好的<strong>防止了csrf攻击</strong>，</p></blockquote><p>但这里面有很大的问题</p><p>首先来看cookie</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>cookie经常用来存储用户的会话信息。比如，用户登陆认证后的session，之后同域内发出的请求都会带上认证后的会话信息，非常方便。所以攻击者特别喜欢盗取cookie，这相当于盗取了在目标网站上的用户权限。</p><p>但是！</p><h5 id="Secure-Cookie机制"><a href="#Secure-Cookie机制" class="headerlink" title="Secure Cookie机制"></a>Secure Cookie机制</h5><p>Secure Cookie机制指的是设置了secure标志的cookie。Secure Cookie仅在https层面上安全传输，如果是http请求，就不会带上这个cookie。</p><p>这样能降低重要的cookie被中间人截获的风险。<br>不过，也不是说可以万无一失。因为<a href="https://www.zhihu.com/search?q=secure+cookie&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:65558789%7D">secure cookie</a>对于客户端脚本来说是可读可写的，可读就意味着secure cookie能被盗取，可写意味着能被篡改，所以还是存在一定的风险。</p><h5 id="HttpOnly属性"><a href="#HttpOnly属性" class="headerlink" title="HttpOnly属性"></a><strong>HttpOnly属性</strong></h5><p>Cookie的HttpOnly属性，指浏览器不要在除HTTP（和 HTTPS)请求之外暴露Cookie。</p><p>一个有HttpOnly属性的Cookie，不能通过非HTTP方式来访问，例如通过调用JavaScript(例如，引用document.cookie），因此，不可能通过<a href="https://www.zhihu.com/search?q=%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:65558789%7D">跨域脚本</a>（一种非常普通的攻击技术）来偷走这种Cookie。Facebook 和 Google 正在广泛地使用HttpOnly属性。<br>然而，目前的技术手段还是可以通过xss攻击获取httpOnly的cookie。有兴趣的朋友可以延伸阅读该篇：<a href="https://link.zhihu.com/?target=https://medium.com/@yassergersy/xss-to-session-hijack-6039e11e6a81">Stealing HttpOnly Cookie via XSS</a></p><h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h4><p>LocalStorage也是浏览器本地存储数据的一个地方，是HTML5的特性。目前已经十分普及了。然而，localStorage并不会像cookie那样可以设置数据存活的时间限制。</p><p>只要用户不主动删除，localstorage存储的数据就会永久存在。</p><p>因此不建议将敏感信息存储在localstorage中，尤其用于身份验证的数据。localStorage没有对xss攻击做任何防御机制，一旦出现xss漏洞，存储在localstorage的数据及其容易被获取到。</p><blockquote><p>（1）sessionStorage：客户端用于存储变量的，仅在当前会话下有效，关闭页面或浏览器后被清楚</p><p>（2）localStorage：除非被清除，否则永久保存</p></blockquote><h3 id="在移动设备上效果更好；"><a href="#在移动设备上效果更好；" class="headerlink" title="在移动设备上效果更好；"></a>在移动设备上效果更好；</h3><p>部分移动浏览器存在不支持cookie的情况（现在的手机浏览器貌似都支持了）</p><h3 id="适用于阻止-cookie-的用户。"><a href="#适用于阻止-cookie-的用户。" class="headerlink" title="适用于阻止 cookie 的用户。"></a>适用于阻止 cookie 的用户。</h3><p>因为可以放在cookie之外，可以适用于阻止cookie的用户</p><h2 id="使用jwt的缺点"><a href="#使用jwt的缺点" class="headerlink" title="使用jwt的缺点"></a>使用jwt的缺点</h2><h3 id="token失效问题"><a href="#token失效问题" class="headerlink" title="token失效问题"></a>token失效问题</h3><p>JWT方式最大的坏处就是<strong>无法主动让token失效</strong>，小伙伴们会说token不是有过期时间吗？是的，token本身是有过期时间，但<strong>token一旦发出，服务器就无法收回</strong>。</p><blockquote><p>如：一个jwt的token的失效时间是3天，但我们<strong>发现这个token有异常</strong>，有可能被人登录，那真实的用户可以修改密码。但是即使修改了密码，<strong>那个异常的token还是合法的</strong>，因为3天的失效时间未到，我们<strong>服务器是没法主动让异常token失效</strong>。</p></blockquote><h3 id="数据延时，不一致问题"><a href="#数据延时，不一致问题" class="headerlink" title="数据延时，不一致问题"></a>数据延时，不一致问题</h3><p>还有个问题就是因为jwt中<strong>包含了用户的部分信息</strong>，如果这些<strong>部分信息修改了</strong>，服务器获取的还是<strong>以前的jwt中的用户信息</strong>，导致数据不一致。</p><h2 id="使用session的优点"><a href="#使用session的优点" class="headerlink" title="使用session的优点"></a>使用session的优点</h2><ul><li>相比JWT，最大优势是可以主动清除session。</li><li>session保存在服务器端相对安全。</li><li>结合cookie使用，较为灵活，兼容性好</li><li>不需要和前端协同。浏览器的每个请求都会在请求头中携带上cookie</li></ul><h2 id="使用session的缺点"><a href="#使用session的缺点" class="headerlink" title="使用session的缺点"></a>使用session的缺点</h2><h3 id="跨服务器"><a href="#跨服务器" class="headerlink" title="跨服务器"></a>跨服务器</h3><p>看起来通过 cookie + session 的方式是解决了问题， 但是我们忽略了一个问题，上述情况能正常工作是因为我们假设 server 是单机工作的，但实际在生产上，为了保障高可用，一般服务器至少需要两台机器，通过负载均衡的方式来决定到底请求该打到哪台机器上。</p><p>假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。主要有以下三种解决方案</p><blockquote><p> 1、session 复制</p></blockquote><p>A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到，故不会有问题</p><p><img src="/images/v2-75d3d54a13e5ff882f55f932db4e6249_720w.jpg" alt="img"></p><p>这种方式虽然可行，但缺点也很明显：</p><ol><li>同一样的一份 session 保存了多份，数据冗余</li><li>如果节点少还好，但如果节点多的话，特别是像阿里，微信这种由于 DAU 上亿，可能需要部署成千上万台机器，这样节点增多复制造成的性能消耗也会很大。</li></ol><blockquote><p> 2、session 粘连</p></blockquote><p>这种方式是让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上，Nginx 的 sticky 模块可以支持这种方式，支持按 ip 或 cookie 粘连等等，如按 ip 粘连方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">　　ip_hash;</span><br><span class="line">　　server 10.1.1.107:88;</span><br><span class="line">　　server 10.1.1.132:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/50/v2-36bbaea261ab09dc07ce0fc33fa851b6_720w.jpg?source=1940ef5c" alt="img"></p><p>这样的话每个 client 请求到达 Nginx 后，只要它的 ip 不变，根据 ip hash 算出来的值会打到固定的机器上，也就不存在 session 找不到的问题了，当然不难看出这种方式缺点也是很明显，对应的机器挂了怎么办？</p><blockquote><p> 3、session 共享</p></blockquote><p>这种方式也是目前各大公司普遍采用的方案，将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session 即可。</p><p><img src="/images/v2-7c43c11f9679bb9267c72dfb028cada6_720w.jpg" alt="img"></p><p>缺点其实也不难发现，就是每个请求都要去 redis 取一下 session，多了一次内部连接，消耗了一点性能，另外为了保证 redis 的高可用，必须做集群，当然了对于大公司来说, redis 集群基本都会部署，所以这方案可以说是大公司的首选了。</p><h3 id="cookie跨域"><a href="#cookie跨域" class="headerlink" title="cookie跨域"></a>cookie跨域</h3><p>domain表示的是cookie所在的域，默认为请求的地址，如网址为<a href="http://www.jb51.net/test/test.aspx%EF%BC%8C%E9%82%A3%E4%B9%88domain%E9%BB%98%E8%AE%A4%E4%B8%BAwww.jb51.net%E3%80%82%E8%80%8C%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%A6%82%E5%9F%9FA%E4%B8%BAt1.test.com%EF%BC%8C%E5%9F%9FB%E4%B8%BAt2.test.com%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E5%9F%9FA%E7%94%9F%E4%BA%A7%E4%B8%80%E4%B8%AA%E4%BB%A4%E5%9F%9FA%E5%92%8C%E5%9F%9FB%E9%83%BD%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84cookie%E5%B0%B1%E8%A6%81%E5%B0%86%E8%AF%A5cookie%E7%9A%84domain%E8%AE%BE%E7%BD%AE%E4%B8%BA.test.com%EF%BC%9B%E5%A6%82%E6%9E%9C%E8%A6%81%E5%9C%A8%E5%9F%9FA%E7%94%9F%E4%BA%A7%E4%B8%80%E4%B8%AA%E4%BB%A4%E5%9F%9FA%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E8%80%8C%E5%9F%9FB%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84cookie%E5%B0%B1%E8%A6%81%E5%B0%86%E8%AF%A5cookie%E7%9A%84domain%E8%AE%BE%E7%BD%AE%E4%B8%BAt2.test.com%E3%80%82">www.jb51.net/test/test.aspx，那么domain默认为www.jb51.net。而跨域访问，如域A为t1.test.com，域B为t2.test.com，那么在域A生产一个令域A和域B都能访问的cookie就要将该cookie的domain设置为.test.com；如果要在域A生产一个令域A不能访问而域B能访问的cookie就要将该cookie的domain设置为t2.test.com。</a></p><p>很遗憾，浏览器对 Cookie 的跨域限制越来越严格。Chrome 浏览器还给 Cookie 新增了一个 SameSite 属性，此举几乎禁止了一切跨域请求的 Cookie 传递（超链接除外），并且只有当使用 HTTPs 协议时，才有可能被允许在 AJAX 跨域请求中接受服务器传来的 Cookie。</p><h3 id="用户能禁止cookie"><a href="#用户能禁止cookie" class="headerlink" title="用户能禁止cookie"></a>用户能禁止cookie</h3>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>权限管理的理解</title>
      <link href="/2021/12/01/%E5%85%B3%E4%BA%8E%E6%9D%83%E9%99%90%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/12/01/%E5%85%B3%E4%BA%8E%E6%9D%83%E9%99%90%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="权限管理的理解"><a href="#权限管理的理解" class="headerlink" title="权限管理的理解"></a>权限管理的理解</h1><p>什么是<strong>权限管理</strong>：对用户访问系统进行控制，按照安全规则、安全策略控制用户只能访问被授权的资源，一般包含<strong>认证</strong>和<strong>授权</strong>两部分。</p><p>权限管理基本流程图<br> <span id="more"></span><br><img src="/images/Center.png" alt="img"></p><p>用户认证：验证用户身份的合法性，即用户登录，常用的身份认证方法：1.帐号密码 2.指纹 3.证书</p><p>用户授权：简单理解为访问控制，具有某种资源对应的权限才可以访问该资源</p><p>我们的做法是</p><p>认证：用户登录（jwt）</p><p>授权：判断用户是否有操作该接口的权限（接口表和角色表）</p><p><img src="/images/Center-16383473337565.png" alt="img"></p><h2 id="认证的方式"><a href="#认证的方式" class="headerlink" title="认证的方式"></a>认证的方式</h2><p>常见的有jwt，session-cookie</p><h3 id="基于jwt的身份认证"><a href="#基于jwt的身份认证" class="headerlink" title="基于jwt的身份认证"></a>基于jwt的身份认证</h3><h4 id="JSON-Web-Token是什么"><a href="#JSON-Web-Token是什么" class="headerlink" title="JSON Web Token是什么"></a>JSON Web Token是什么</h4><blockquote><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p></blockquote><h4 id="JSON-Web-Token的结构是什么样的"><a href="#JSON-Web-Token的结构是什么样的" class="headerlink" title="JSON Web Token的结构是什么样的"></a>JSON Web Token的结构是什么样的</h4><p>JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：</p><ul><li>Header（头部）</li><li>Payload（载荷）</li><li>Signature（签名）</li></ul><p>因此，一个典型的JWT看起来是这个样子的：</p><blockquote><p>Header.Payload.Signature</p></blockquote><p><img src="/images/v2-5b8e7a496d1a44f0074331e7f7f1112f_720w.jpg" alt="img"></p><h4 id="基于Token的鉴权过程如下："><a href="#基于Token的鉴权过程如下：" class="headerlink" title="基于Token的鉴权过程如下："></a>基于Token的鉴权过程如下：</h4><ol><li>用户使用用户名密码来请求服务器；</li><li>服务器验证用户信息；</li><li>服务器通过验证后，生成一个token并发送给用户；</li><li>客户端存储token，并在每次请求时带上这个token值；</li><li>服务端验证token值，并返回数据；</li></ol><blockquote><p>这个token必须要在每次请求时传递给<a href="https://www.zhihu.com/search?q=%E6%9C%8D%E5%8A%A1%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:377723080%7D">服务端</a>，通常保存在请求头（Header）；</p></blockquote><blockquote><p>优点</p><p>可以随意存储，自由度很高</p></blockquote><blockquote><p>缺点</p><p>服务端无法主动使token失效</p></blockquote><h3 id="基于session的认证"><a href="#基于session的认证" class="headerlink" title="基于session的认证"></a>基于session的认证</h3><p>它的交互流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端的<br>sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数<br>据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了</p><h4 id="基于session的鉴权过程如下："><a href="#基于session的鉴权过程如下：" class="headerlink" title="基于session的鉴权过程如下："></a>基于session的鉴权过程如下：</h4><ol><li>用户使用用户名密码来请求服务器；</li><li>服务器验证用户信息；</li><li>服务器通过验证后，生成一个session_id并发送给客户端的cookie中；</li><li>客户端存储session_id，并在每次请求时带上这个session_id值；</li><li>服务端验证session_id是否有对应的session数据，并返回数据；</li></ol><blockquote><p>优点：</p><p>cookie中的数据会自动携带在请求中，不需要前端配合</p><p>可以在任意时刻销毁会话，实现服务对会话的控制。</p></blockquote><blockquote><p>缺点：不过，用户可以禁止使用cookie导致失效</p></blockquote><h2 id="授权的方式"><a href="#授权的方式" class="headerlink" title="授权的方式"></a>授权的方式</h2><h3 id="Oauth2-0"><a href="#Oauth2-0" class="headerlink" title="Oauth2.0"></a>Oauth2.0</h3><p><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">OAuth 2.0</a> 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p><p>举个例子，你想登录豆瓣去看看电影评论，但你从来没注册过豆瓣账号，又不想新注册一个再使用豆瓣，怎么办呢？不用担心，豆瓣已经做了准备，用你的qq号可以授权给豆瓣进行登录。</p><p>简单来说，上述例子中的豆瓣就是<strong>客户端</strong>，QQ就是<strong>认证服务器</strong>，OAuth2.0就是客户端和认证服务器之间由于相互<strong>不信任</strong>而产生的一个<strong>授权协议</strong>。</p><blockquote><p>官方解释：</p><p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p></blockquote><p><strong>OAuth 2.0 规定了四种获得令牌的流程</strong></p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials）</li></ul><h2 id="权限管理的设计模式"><a href="#权限管理的设计模式" class="headerlink" title="权限管理的设计模式"></a>权限管理的设计模式</h2><h3 id="自主访问控制（DAC-Discretionary-Access-Control）"><a href="#自主访问控制（DAC-Discretionary-Access-Control）" class="headerlink" title="自主访问控制（DAC: Discretionary Access Control）"></a>自主访问控制（DAC: Discretionary Access Control）</h3><blockquote><p>权限根据用户进行分配</p></blockquote><p>系统会识别用户，然后根据被操作对象（Subject）的权限控制列表（ACL: Access Control List）或者权限控制矩阵（ACL: Access Control Matrix）的信息来决定用户的是否能对其进行哪些操作，例如读取或修改。</p><p>而拥有对象权限的用户，又可以将该对象的权限分配给其他用户，所以称之为“自主（Discretionary）”控制。</p><p>这种设计最常见的应用就是文件系统的权限设计，如微软的NTFS。</p><p>DAC最大缺陷就是对权限控制比较分散，不便于管理，比如无法简单地将一组文件设置统一的权限开放给指定的一群用户。</p><h3 id="强制访问控制（MAC-Mandatory-Access-Control）"><a href="#强制访问控制（MAC-Mandatory-Access-Control）" class="headerlink" title="强制访问控制（MAC: Mandatory Access Control）"></a>强制访问控制（MAC: Mandatory Access Control）</h3><p>MAC是为了弥补DAC权限控制过于分散的问题而诞生的。在MAC的设计中，每一个对象都都有一些权限标识，每个用户同样也会有一些权限标识，而用户能否对该对象进行操作取决于双方的权限标识的关系，这个限制判断通常是由系统硬性限制的。比如在影视作品中我们经常能看到特工在查询机密文件时，屏幕提示需要“无法访问，需要一级安全许可”，这个例子中，文件上就有“一级安全许可”的权限标识，而用户并不具有。</p><p>MAC非常适合机密机构或者其他等级观念强烈的行业，但对于类似商业服务系统，则因为不够灵活而不能适用。</p><h3 id="基于角色的访问控制（RBAC-Role-Based-Access-Control"><a href="#基于角色的访问控制（RBAC-Role-Based-Access-Control" class="headerlink" title="基于角色的访问控制（RBAC: Role-Based Access Control)"></a>基于角色的访问控制（RBAC: Role-Based Access Control)</h3><p><strong>一个用户拥有一个角色</strong></p><p>在实际的团体业务中，都可以将用户分类。比如对于薪水管理系统，通常按照级别分类：经理、高级工程师、中级工程师、初级工程师。也就是按照一定的角色分类，通常具有同一角色的用户具有相同的权限。这样改变之后，就可以将针对用户赋权转换为针对角色赋权。</p><p><img src="/images/8ad4b31c8701a18bd607cbc3953fcb0d2938fe60.jpeg" alt="img"></p><p>一个用户拥有一个角色</p><p>一个用户有一个角色</p><p>一个角色有多个操作（菜单）权限</p><p>一个操作权限可以属于多个角色</p><p>** 一个用户一个或多个角色**</p><p>但是在实际的应用系统中，一个用户一个角色远远满足不了需求。如果我们希望一个用户既担任销售角色、又暂时担任副总角色。该怎么做呢？为了增加系统设计的适用性，我们通常设计：</p><p>一个用户有一个或多个角色</p><p>一个角色包含多个用户</p><p>一个角色有多种权限</p><p>一个权限属于多个角色</p><p><img src="/images/Center-16383473337565.png" alt="img"></p><p>我们可以用下图中的数据库设计模型，描述这样的关系。</p><p><img src="/images/6a63f6246b600c337c92989b155c9d0ad8f9a194.jpeg" alt="img"></p><p>一个用户一个或多个角色</p><p><em><strong>二、页面访问权限与操作权限</strong></em></p><p>**页面访问权限:**所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面访问权限。</p><p><strong>操作权限：</strong>用户在操作系统中的任何动作、交互都需要有操作权限，如增删改查等。比如：某个按钮，某个超链接用户是否可以点击，是否应该看见的权限。</p><p><img src="/images/2cf5e0fe9925bc31b23fe25a54cf41b4ca1370ac.jpeg" alt="img"></p><p>页面访问权限与操作权限分表存放</p><p>为了适应这种需求，我们可以把页面资源(菜单)和操作资源(按钮)分表存放，如上图。也可以把二者放到一个表里面存放，用一个字段进行标志区分。</p><p><em><strong>三、数据权限</strong></em></p><p>数据权限比较好理解，就是某个用户能够访问和操作哪些数据。</p><p>通常来说，数据权限由用户所属的组织来确定。比如：生产一部只能看自己部门的生产数据，生产二部只能看自己部门的生产数据；销售部门只能看销售数据，不能看财务部门的数据。而公司的总经理可以看所有的数据。</p><p>在实际的业务系统中，数据权限往往更加复杂。非常有可能销售部门可以看生产部门的数据，以确定销售策略、安排计划等。</p><p>所以为了面对复杂的需求，数据权限的控制通常是由程序员书写个性化的SQL来限制数据范围的，而不是交给权限模型或者Spring Security或shiro来控制。当然也可以从权限模型或者权限框架的角度去解决这个问题，但适用性有限。</p><h3 id="基于属性的权限验证（ABAC-Attribute-Based-Access-Control）"><a href="#基于属性的权限验证（ABAC-Attribute-Based-Access-Control）" class="headerlink" title="基于属性的权限验证（ABAC: Attribute-Based Access Control）"></a>基于属性的权限验证（ABAC: Attribute-Based Access Control）</h3><p>不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是通过动态计算一个或一组属性来是否满足某种条件来进行授权判断（可以编写简单的逻辑）。属性通常来说分为四类：用户属性（如用户年龄），环境属性（如当前时间），操作属性（如读取）和对象属性（如一篇文章，又称资源属性），所以理论上能够实现非常灵活的权限控制，几乎能满足所有类型的需求。</p><p>例如规则：“允许所有班主任在上课时间自由进出校门”这条规则，其中，“班主任”是用户的角色属性，“上课时间”是环境属性，“进出”是操作属性，而“校门”就是对象属性了。为了实现便捷的规则设置和规则判断执行，ABAC通常有配置文件（XML、YAML等）或DSL配合规则解析引擎使用。XACML（eXtensible Access Control Markup Language）是ABAC的一个实现，但是该设计过于复杂，我还没有完全理解，故不做介绍。</p><p>总结一下，ABAC有如下特点：</p><ol><li>集中化管理</li><li>可以按需实现不同颗粒度的权限控制</li><li>不需要预定义判断逻辑，减轻了权限系统的维护成本，特别是在需求经常变化的系统中</li><li>定义权限时，不能直观看出用户和对象间的关系</li><li>规则如果稍微复杂一点，或者设计混乱，会给管理者维护和追查带来麻烦</li><li>权限判断需要实时执行，规则过多会导致性能问题</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 权限管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>copy函数</title>
      <link href="/2021/12/01/copy%E5%87%BD%E6%95%B0/"/>
      <url>/2021/12/01/copy%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="copy函数"><a href="#copy函数" class="headerlink" title="copy函数"></a>copy函数</h1><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copy</span>(dst, src []<span class="type">Type</span>)</span> int</span><br><span class="line"><span class="comment">//dst 复制的切片</span></span><br><span class="line"><span class="comment">//src 被复制的切片</span></span><br></pre></td></tr></table></figure><p>基本认识：</p><ul><li>它只能用于切片，不能用于 map 等任何其他类型</li><li>它返回结果为一个 int 型值，表示 copy 的长度</li></ul><h2 id="坑位一：切片-dst-需要先初始化长度"><a href="#坑位一：切片-dst-需要先初始化长度" class="headerlink" title="坑位一：切片 dst 需要先初始化长度"></a>坑位一：切片 dst 需要先初始化长度</h2><p>不是你定义好类型，就能将 src 完全 copy 到 dst 的，你需要初始化长度。</p><ul><li>如果 dst 长度小于 src 的长度，则 copy 部分；</li><li>如果大于，则全部拷贝过来，只是没占满 dst 的坑位而已；</li><li>相等时刚好不多不少 copy 过来。</li></ul> <span id="more"></span><h2 id="坑位二：源切片中元素类型为引用类型时，拷贝的是引用"><a href="#坑位二：源切片中元素类型为引用类型时，拷贝的是引用" class="headerlink" title="坑位二：源切片中元素类型为引用类型时，拷贝的是引用"></a>坑位二：源切片中元素类型为引用类型时，拷贝的是引用</h2><p>由于只 copy 切片中的元素，所以如果切片元素的类型是引用类型，那么 copy 的也将是个引用。</p><p>如下面例子，matA 和 matB 地址不一样，但 matA[0] 和 matB[0] 的地址是一样的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wrongCopyMatrix</span><span class="params">()</span></span> &#123;</span><br><span class="line">    matA := [][]<span class="keyword">int</span>&#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    matB := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(matA))</span><br><span class="line">    <span class="built_in">copy</span>(matB, matA)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, matA, matA[<span class="number">0</span>]) <span class="comment">// 0xc0000c0000, 0xc0000c2000</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, matB, matB[<span class="number">0</span>]) <span class="comment">// 0xc0000c0050, 0xc0000c2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想 copy 多维切片中的每一个切片类型的元素，那么你需要将每个切片元素进行 <strong>初始化</strong> 并 <strong>拷贝</strong>。注意是两步：先 <strong>初始化</strong>，再 <strong>拷贝</strong>。</p><p>正确的拷贝一个多维数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rightCopyMatrix</span><span class="params">()</span></span> &#123;</span><br><span class="line">    matA := [][]<span class="keyword">int</span>&#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    matB := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(matA))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> matA &#123;</span><br><span class="line">        matB[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(matA[i])) <span class="comment">// 注意初始化长度</span></span><br><span class="line">        <span class="built_in">copy</span>(matB[i], matA[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, matA, matA[<span class="number">0</span>]) <span class="comment">// 0xc00005c050, 0xc000018560</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p, %p\n&quot;</span>, matB, matB[<span class="number">0</span>]) <span class="comment">// 0xc00005c0a0, 0xc0000185c0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github绑定自己的域名</title>
      <link href="/2021/12/01/github%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/"/>
      <url>/2021/12/01/github%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="github绑定自己的域名"><a href="#github绑定自己的域名" class="headerlink" title="github绑定自己的域名"></a>github绑定自己的域名</h1><h3 id="1-在项目里新建文件CNAME"><a href="#1-在项目里新建文件CNAME" class="headerlink" title="1.在项目里新建文件CNAME"></a>1.在项目里新建文件CNAME</h3><p><img src="/images/image-20211201143231682.png" alt="image-20211201143231682"></p><p>里面写要绑定的域名</p><span id="more"></span><p>使用代码上传</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="2-在github项目里面设置"><a href="#2-在github项目里面设置" class="headerlink" title="2.在github项目里面设置"></a>2.在github项目里面设置</h3><p><img src="/images/image-20211201143437940.png" alt="image-20211201143437940"></p><p><img src="/images/image-20211201143454351.png" alt="image-20211201143454351"></p><p><img src="/images/image-20211201143505650.png" alt="image-20211201143505650"></p><h2 id="3-添加域名解析"><a href="#3-添加域名解析" class="headerlink" title="3 添加域名解析"></a>3 添加域名解析</h2><p>ping你的<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a>域名，得到一个IP；</p><p><img src="/images/image-20211201143654499.png" alt="image-20211201143654499"></p><blockquote><p>ping 后面的-4是为了ipv4 的格式</p></blockquote><p><strong>向你的 DNS 配置中添加 2 条记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@          A             185.199.108.153（ping出来的）</span><br><span class="line">www      CNAME           username.github.io.</span><br></pre></td></tr></table></figure><p><img src="/images/image-20211201143818395.png" alt="image-20211201143818395"></p><p><strong>4. 启用 HTTPS</strong></p><p>自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。</p><p>配置也相当简单，只需要更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。</p><ul><li>185.199.108.153（不知道为何和我ping出来的地址一样）</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153</li></ul>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体的理解</title>
      <link href="/2021/12/01/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/12/01/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体的理解"><a href="#结构体的理解" class="headerlink" title="结构体的理解"></a>结构体的理解</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h2 id="1-1-类型别名和自定义类型"><a href="#1-1-类型别名和自定义类型" class="headerlink" title="1.1. 类型别名和自定义类型"></a>1.1. 类型别名和自定义类型</h2><h3 id="1-1-1-自定义类型"><a href="#1-1-1-自定义类型" class="headerlink" title="1.1.1. 自定义类型"></a>1.1.1. 自定义类型</h3><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将MyInt定义为int类型</span><br><span class="line">type MyInt int</span><br></pre></td></tr></table></figure> <span id="more"></span><p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p><h3 id="1-1-2-类型别名"><a href="#1-1-2-类型别名" class="headerlink" title="1.1.2. 类型别名"></a>1.1.2. 类型别名</h3><p>类型别名是Go1.9版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></table></figure><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></table></figure><h3 id="1-1-3-类型定义和类型别名的区别"><a href="#1-1-3-类型定义和类型别名的区别" class="headerlink" title="1.1.3. 类型定义和类型别名的区别"></a>1.1.3. 类型定义和类型别名的区别</h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a NewInt</span><br><span class="line">    <span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p><h2 id="1-2-结构体"><a href="#1-2-结构体" class="headerlink" title="1.2. 结构体"></a>1.2. 结构体</h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。</p><p>Go语言中通过struct来实现面向对象。</p><h3 id="1-2-1-结构体的定义"><a href="#1-2-1-结构体的定义" class="headerlink" title="1.2.1. 结构体的定义"></a>1.2.1. 结构体的定义</h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 类型名 struct &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类型名：标识自定义结构体的名称，在同一个包内不能重复。</span><br><span class="line">2.字段名：表示结构体字段名。结构体中的字段名必须唯一。</span><br><span class="line">3.字段类型：表示结构体字段的具体类型。</span><br></pre></td></tr></table></figure><p>举个例子，我们定义一个Person（人）结构体，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    city string</span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type person1 struct &#123;</span><br><span class="line">    name, city string</span><br><span class="line">    age        int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h3 id="1-2-2-结构体实例化"><a href="#1-2-2-结构体实例化" class="headerlink" title="1.2.2. 结构体实例化"></a>1.2.2. 结构体实例化</h3><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="1-2-3-基本实例化"><a href="#1-2-3-基本实例化" class="headerlink" title="1.2.3. 基本实例化"></a>1.2.3. 基本实例化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 person</span><br><span class="line">    p1.name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">    p1.age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;pprof.cn 北京 18&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p><h2 id="1-3-匿名结构体"><a href="#1-3-匿名结构体" class="headerlink" title="1.3. 匿名结构体"></a>1.3. 匿名结构体</h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-1-创建指针类型结构体"><a href="#1-3-1-创建指针类型结构体" class="headerlink" title="1.3.1. 创建指针类型结构体"></a>1.3.1. 创建指针类型结构体</h3><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 = new(person)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p2)     //*main.person</span><br><span class="line">fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出p2是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;测试&quot;</span></span><br><span class="line">p2.age = <span class="number">18</span></span><br><span class="line">p2.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;测试&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-取结构体的地址实例化"><a href="#1-3-2-取结构体的地址实例化" class="headerlink" title="1.3.2. 取结构体的地址实例化"></a>1.3.2. 取结构体的地址实例化</h3><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;博客&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;博客&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure><p>p3.name = “博客”其实在底层是(*p3).name = “博客”，这是Go语言帮我们实现的语法糖。</p><h3 id="1-3-3-结构体初始化"><a href="#1-3-3-结构体初始化" class="headerlink" title="1.3.3. 结构体初始化"></a>1.3.3. 结构体初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p4 person</span><br><span class="line">    fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-4-使用键值对初始化"><a href="#1-3-4-使用键值对初始化" class="headerlink" title="1.3.4. 使用键值对初始化"></a>1.3.4. 使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">    name: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) <span class="comment">//p5=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">    name: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p6=%#v\n&quot;</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p7=%#v\n&quot;</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-5-使用值的列表初始化"><a href="#1-3-5-使用值的列表初始化" class="headerlink" title="1.3.5. 使用值的列表初始化"></a>1.3.5. 使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.必须初始化结构体的所有字段。</span><br><span class="line">2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。</span><br><span class="line">3.该方式不能和键值初始化方式混用。</span><br></pre></td></tr></table></figure><h3 id="1-3-6-结构体内存布局"><a href="#1-3-6-结构体内存布局" class="headerlink" title="1.3.6. 结构体内存布局"></a>1.3.6. 结构体内存布局</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int8</span></span><br><span class="line">    b <span class="keyword">int8</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><h3 id="1-3-7-面试题"><a href="#1-3-7-面试题" class="headerlink" title="1.3.7. 面试题"></a>1.3.7. 面试题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">    stus := []student&#123;</span><br><span class="line">        &#123;name: <span class="string">&quot;pprof.cn&quot;</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">        &#123;name: <span class="string">&quot;测试&quot;</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">        &#123;name: <span class="string">&quot;博客&quot;</span>, age: <span class="number">28</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">        m[stu.name] = &amp;stu</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, v.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-8-构造函数"><a href="#1-3-8-构造函数" class="headerlink" title="1.3.8. 构造函数"></a>1.3.8. 构造函数</h3><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(<span class="string">&quot;pprof.cn&quot;</span>, <span class="string">&quot;测试&quot;</span>, <span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p9)</span><br></pre></td></tr></table></figure><h3 id="1-3-9-方法和接收者"><a href="#1-3-9-方法和接收者" class="headerlink" title="1.3.9. 方法和接收者"></a>1.3.9. 方法和接收者</h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p><p>方法的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</span><br><span class="line">2.接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</span><br><span class="line">3.方法名、参数列表、返回参数：具体格式与函数定义相同。</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="1-3-10-指针类型的接收者"><a href="#1-3-10-指针类型的接收者" class="headerlink" title="1.3.10. 指针类型的接收者"></a>1.3.10. 指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SetAge 设置p的年龄</span><br><span class="line">// 使用指针接收者</span><br><span class="line">func (p *Person) SetAge(newAge int8) &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1.SetAge(<span class="number">30</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-11-值类型的接收者"><a href="#1-3-11-值类型的接收者" class="headerlink" title="1.3.11. 值类型的接收者"></a>1.3.11. 值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-12-什么时候应该使用指针类型接收者"><a href="#1-3-12-什么时候应该使用指针类型接收者" class="headerlink" title="1.3.12. 什么时候应该使用指针类型接收者"></a>1.3.12. 什么时候应该使用指针类型接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.需要修改接收者中的值</span><br><span class="line">2.接收者是拷贝代价比较大的大对象</span><br><span class="line">3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</span><br></pre></td></tr></table></figure><h3 id="1-3-13-任意类型添加方法"><a href="#1-3-13-任意类型添加方法" class="headerlink" title="1.3.13. 任意类型添加方法"></a>1.3.13. 任意类型添加方法</h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m1 MyInt</span><br><span class="line">    m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">    m1 = <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h3 id="1-3-14-结构体的匿名字段"><a href="#1-3-14-结构体的匿名字段" class="headerlink" title="1.3.14. 结构体的匿名字段"></a>1.3.14. 结构体的匿名字段</h3><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">        <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span></span><br><span class="line">    fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//pprof.cn 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h3 id="1-3-15-嵌套结构体"><a href="#1-3-15-嵌套结构体" class="headerlink" title="1.3.15. 嵌套结构体"></a>1.3.15. 嵌套结构体</h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user1 := User&#123;</span><br><span class="line">        Name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            Province: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">            City:     <span class="string">&quot;哈尔滨&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-16-嵌套匿名结构体"><a href="#1-3-16-嵌套匿名结构体" class="headerlink" title="1.3.16. 嵌套匿名结构体"></a>1.3.16. 嵌套匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address <span class="comment">//匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user2 User</span><br><span class="line">    user2.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user2.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    user2.Address.Province = <span class="string">&quot;黑龙江&quot;</span>    <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">    user2.City = <span class="string">&quot;哈尔滨&quot;</span>                <span class="comment">//直接访问匿名结构体的字段名</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) <span class="comment">//user2=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h3 id="1-3-17-嵌套结构体的字段名冲突"><a href="#1-3-17-嵌套结构体的字段名冲突" class="headerlink" title="1.3.17. 嵌套结构体的字段名冲突"></a>1.3.17. 嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province   <span class="keyword">string</span></span><br><span class="line">    City       <span class="keyword">string</span></span><br><span class="line">    CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account    <span class="keyword">string</span></span><br><span class="line">    CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">    Gender <span class="keyword">string</span></span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user3 User</span><br><span class="line">    user3.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user3.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    <span class="comment">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span></span><br><span class="line">    user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">    user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-18-结构体的“继承”"><a href="#1-3-18-结构体的“继承”" class="headerlink" title="1.3.18. 结构体的“继承”"></a>1.3.18. 结构体的“继承”</h3><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="keyword">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-19-结构体字段的可见性"><a href="#1-3-19-结构体字段的可见性" class="headerlink" title="1.3.19. 结构体字段的可见性"></a>1.3.19. 结构体字段的可见性</h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h3 id="1-3-20-结构体与JSON序列化"><a href="#1-3-20-结构体与JSON序列化" class="headerlink" title="1.3.20. 结构体与JSON序列化"></a>1.3.20. 结构体与JSON序列化</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span></span><br><span class="line">    Gender <span class="keyword">string</span></span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title    <span class="keyword">string</span></span><br><span class="line">    Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := &amp;Class&#123;</span><br><span class="line">        Title:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">        Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        stu := &amp;Student&#123;</span><br><span class="line">            Name:   fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">            Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">            ID:     i,</span><br><span class="line">        &#125;</span><br><span class="line">        c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">    data, err := json.Marshal(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line">    <span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">    str := <span class="string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">    c1 := &amp;Class&#123;&#125;</span><br><span class="line">    err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-21-结构体标签（Tag）"><a href="#1-3-21-结构体标签（Tag）" class="headerlink" title="1.3.21. 结构体标签（Tag）"></a>1.3.21. 结构体标签（Tag）</h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。</p><p>Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">    Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">    name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;</span><br><span class="line">        ID:     <span class="number">1</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    data, err := json.Marshal(s1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;女&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-22-小练习："><a href="#1-3-22-小练习：" class="headerlink" title="1.3.22. 小练习："></a>1.3.22. 小练习：</h3><p>猜一下下列代码运行的结果是什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(ce []student)</span></span> &#123;</span><br><span class="line">    <span class="comment">//切片是引用传递，是可以改变值的</span></span><br><span class="line">    ce[<span class="number">1</span>].age = <span class="number">999</span></span><br><span class="line">    <span class="comment">// ce = append(ce, student&#123;3, &quot;xiaowang&quot;, 56&#125;)</span></span><br><span class="line">    <span class="comment">// return ce</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ce []student  <span class="comment">//定义一个切片类型的结构体</span></span><br><span class="line">    ce = []student&#123;</span><br><span class="line">        student&#123;<span class="number">1</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">22</span>&#125;,</span><br><span class="line">        student&#123;<span class="number">2</span>, <span class="string">&quot;xiaozhang&quot;</span>, <span class="number">33</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">    demo(ce)</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-23-删除map类型的结构体"><a href="#1-3-23-删除map类型的结构体" class="headerlink" title="1.3.23. 删除map类型的结构体"></a>1.3.23. 删除map类型的结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ce := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]student)</span><br><span class="line">    ce[<span class="number">1</span>] = student&#123;<span class="number">1</span>, <span class="string">&quot;xiaolizi&quot;</span>, <span class="number">22</span>&#125;</span><br><span class="line">    ce[<span class="number">2</span>] = student&#123;<span class="number">2</span>, <span class="string">&quot;wang&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">    <span class="built_in">delete</span>(ce, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-24-实现map有序输出-面试经常问到"><a href="#1-3-24-实现map有序输出-面试经常问到" class="headerlink" title="1.3.24. 实现map有序输出(面试经常问到)"></a>1.3.24. 实现map有序输出(面试经常问到)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line">    map1[<span class="number">1</span>] = <span class="string">&quot;www.topgoer.com&quot;</span></span><br><span class="line">    map1[<span class="number">2</span>] = <span class="string">&quot;rpc.topgoer.com&quot;</span></span><br><span class="line">    map1[<span class="number">5</span>] = <span class="string">&quot;ceshi&quot;</span></span><br><span class="line">    map1[<span class="number">3</span>] = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">    map1[<span class="number">4</span>] = <span class="string">&quot;xiaohuang&quot;</span></span><br><span class="line">    sli := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">        sli = <span class="built_in">append</span>(sli, k)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(sli)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(map1); i++ &#123;</span><br><span class="line">        fmt.Println(map1[sli[i]])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-25-小案例"><a href="#1-3-25-小案例" class="headerlink" title="1.3.25. 小案例"></a>1.3.25. 小案例</h3><p>采用切片类型的结构体接受查询数据库信息返回的参数</p><p>地址：<a href="https://github.com/lu569368/struct">https://github.com/lu569368/struct</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Slice(切片)的理解</title>
      <link href="/2021/12/01/Slice(%E5%88%87%E7%89%87)%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/12/01/Slice(%E5%88%87%E7%89%87)%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Slice-切片-的理解"><a href="#Slice-切片-的理解" class="headerlink" title="Slice(切片)的理解"></a>Slice(切片)的理解</h1><p>slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。（存疑）</span><br><span class="line">  2. 切片的长度可以改变，因此，切片是一个可变的数组。</span><br><span class="line">  3. 切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </span><br><span class="line">  4. cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</span><br><span class="line">  5. 切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。</span><br><span class="line">  6. 如果 slice == nil，那么 len、cap 结果都等于 0。</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="创建切片的各种方式"><a href="#创建切片的各种方式" class="headerlink" title="创建切片的各种方式"></a>创建切片的各种方式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s3 []<span class="keyword">int</span> = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)/s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 前包后不包</span></span><br><span class="line">s4 := arr[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">全局：</span><br><span class="line">var arr = [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="line">var slice0 []int = arr[start:end] </span><br><span class="line">var slice1 []int = arr[:end]        </span><br><span class="line">var slice2 []int = arr[start:]        </span><br><span class="line">var slice3 []int = arr[:] </span><br><span class="line">var slice4 = arr[:len(arr)-1]      //去掉切片的最后一个元素</span><br><span class="line">局部：</span><br><span class="line">arr2 := [...]int&#123;9, 8, 7, 6, 5, 4, 3, 2, 1, 0&#125;</span><br><span class="line">slice5 := arr[start:end]</span><br><span class="line">slice6 := arr[:end]        </span><br><span class="line">slice7 := arr[start:]     </span><br><span class="line">slice8 := arr[:]  </span><br><span class="line">slice9 := arr[:len(arr)-1] //去掉切片的最后一个元素</span><br></pre></td></tr></table></figure><p><img src="/images/0.jpg" alt="切片"></p><h3 id="通过make来创建切片"><a href="#通过make来创建切片" class="headerlink" title="通过make来创建切片"></a>通过make来创建切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line">slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/1.jpg" alt="切片"></p><p>切片的内存布局</p><p><img src="/images/2.jpg" alt="切片"></p><p>读写操作实际目标是底层数组，只需注意索引号的差别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    s := data[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    s[<span class="number">0</span>] += <span class="number">100</span></span><br><span class="line">    s[<span class="number">1</span>] += <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">    fmt.Println(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">102</span> <span class="number">203</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">102</span> <span class="number">203</span> <span class="number">4</span> <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>使用 make 动态创建slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    p := &amp;s[<span class="number">2</span>] <span class="comment">// *int, 获取底层数组元素指针。</span></span><br><span class="line">    *p += <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">102</span> <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。"><a href="#超出原-slice-cap-限制，就会重新分配底层数组，即便原数组并未填满。" class="headerlink" title="超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。"></a>超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    data := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>: <span class="number">0</span>&#125;</span><br><span class="line">    s := data[:<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">100</span>, <span class="number">200</span>) <span class="comment">// 一次 append 两个值，超出 s.cap 限制。</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(s, data)         <span class="comment">// 重新分配底层数组，与原数组无关。</span></span><br><span class="line">    fmt.Println(&amp;s[<span class="number">0</span>], &amp;data[<span class="number">0</span>]) <span class="comment">// 比对底层数组起始指针。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0 1 100 200] [0 1 2 3 4 0 0 0 0 0 0]</span><br><span class="line">0xc4200160f0 0xc420070060</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。</p><h3 id="slice中cap重新分配规律："><a href="#slice中cap重新分配规律：" class="headerlink" title="slice中cap重新分配规律："></a>slice中cap重新分配规律：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    c := <span class="built_in">cap</span>(s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">        s = <span class="built_in">append</span>(s, i)</span><br><span class="line">        <span class="keyword">if</span> n := <span class="built_in">cap</span>(s); n &gt; c &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;cap: %d -&gt; %d\n&quot;</span>, c, n)</span><br><span class="line">            c = n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cap: 1 -&gt; 2</span><br><span class="line">cap: 2 -&gt; 4</span><br><span class="line">cap: 4 -&gt; 8</span><br><span class="line">cap: 8 -&gt; 16</span><br><span class="line">cap: 16 -&gt; 32</span><br><span class="line">cap: 32 -&gt; 64</span><br></pre></td></tr></table></figure><h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h3><p>copy复制为值复制，改变原切片的值不会影响新切片。而等号复制为指针复制，改变原切片或新切片都会对另一个产生影响。copy复制会比等号复制慢(很好理解)。</p><p><strong>等号</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    s := a[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 1 2] [1]</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 11 2] [11]</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">12</span>)   <span class="comment">// 底层还是a的容量</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">13</span>)   <span class="comment">//再追加13之前s用的是a的部分空间，追加到13以后发生扩容搬家了</span></span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 11 12] [11 12 13]</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">21</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 11 12] [21 12 13]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>copy</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(s, a)</span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 1 2] [0 1 2]</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 1 2] [11 1 2]</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">12</span>)</span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">13</span>)</span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 1 2] [11 1 2 12 13]</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">21</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(a, s)   <span class="comment">// [0 1 2] [21 1 2 12 13]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go mod 的用法</title>
      <link href="/2021/11/30/go%20mod%20%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2021/11/30/go%20mod%20%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="go-mod-的用法"><a href="#go-mod-的用法" class="headerlink" title="go mod 的用法"></a>go mod 的用法</h1><h3 id="go-mod介绍"><a href="#go-mod介绍" class="headerlink" title="go mod介绍"></a>go mod介绍</h3><p>go modules 是 golang 1.11 新加的特性。现在1.12 已经发布了，是时候用起来了。Modules官方定义为：</p><blockquote><p>模块是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。<br> <span id="more"></span></p></blockquote><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>GO111MODULE 有三个值：off, on和auto（默认值）。</p><p>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。<br> GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。<br> GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前目录在GOPATH/src之外且该目录包含<span class="keyword">go</span>.mod文件</span><br><span class="line">当前文件在包含<span class="keyword">go</span>.mod文件的目录下面。</span><br></pre></td></tr></table></figure><p>当modules功能启用时，依赖包的存放位置变更为$GOPATH/pkg，允许同一个package多个版本并存，且多个项目可以共享缓存的 module</p><h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>golang 提供了 <code>go mod</code>命令来管理包。</p><p>go help mod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"></span><br><span class="line">Note that support <span class="keyword">for</span> modules is built into all the go commands,</span><br><span class="line">not just <span class="string">&#x27;go mod&#x27;</span>. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be <span class="keyword">done</span> using <span class="string">&#x27;go get&#x27;</span>.</span><br><span class="line">See <span class="string">&#x27;go help modules&#x27;</span> <span class="keyword">for</span> an overview of module functionality.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">    go mod &lt;<span class="built_in">command</span>&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">    download    download modules to <span class="built_in">local</span> cache</span><br><span class="line">    edit        edit go.mod from tools or scripts</span><br><span class="line">    graph       <span class="built_in">print</span> module requirement graph</span><br><span class="line">    init        initialize new module <span class="keyword">in</span> current directory</span><br><span class="line">    tidy        add missing and remove unused modules</span><br><span class="line">    vendor      make vendored copy of dependencies</span><br><span class="line">    verify      verify dependencies have expected content</span><br><span class="line">    why         explain why packages or modules are needed</span><br><span class="line"></span><br><span class="line">Use <span class="string">&quot;go help mod &lt;command&gt;&quot;</span> <span class="keyword">for</span> more information about a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure><p>go mod 有以下命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>download</td><td>download modules to local cache(下载依赖包)</td></tr><tr><td>edit</td><td>edit go.mod from tools or scripts（编辑go.mod)</td></tr><tr><td>graph</td><td>print module requirement graph (打印模块依赖图)</td></tr><tr><td>verify</td><td>initialize new module in current directory（在当前目录初始化mod）</td></tr><tr><td>tidy</td><td>add missing and remove unused modules(拉取缺少的模块，移除不用的模块)</td></tr><tr><td>vendor</td><td>make vendored copy of dependencies(将依赖复制到vendor下)</td></tr><tr><td>verify</td><td>verify dependencies have expected content (验证依赖是否正确）</td></tr><tr><td>why</td><td>explain why packages or modules are needed(解释为什么需要依赖)</td></tr></tbody></table><p>比较常用的是 <code>init</code>,<code>tidy</code>, <code>edit</code></p><h3 id="使用go-mod管理一个新项目"><a href="#使用go-mod管理一个新项目" class="headerlink" title="使用go mod管理一个新项目"></a>使用go mod管理一个新项目</h3><h4 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h4><p>可以随便找一个目录创建项目，我使用习惯用IDEA进行创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Gone</span><br><span class="line"><span class="built_in">cd</span> Gone</span><br><span class="line">go mod init Gone</span><br></pre></td></tr></table></figure><p>查看一下 go.mod文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。</p><p>go.mod 提供了module, require、replace和exclude 四个命令</p><ul><li><code>module</code> 语句指定包的名字（路径）</li><li><code>require</code> 语句指定的依赖项模块</li><li><code>replace</code> 语句可以替换依赖项模块</li><li><code>exclude</code> 语句可以忽略依赖项模块</li></ul><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2. 添加依赖"></a>2. 添加依赖</h4><p>创建 main.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 go run main.go 运行代码会发现 go mod 会自动查找依赖自动下载<br> 再查看 <code>go.mod</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require github.com/gin-gonic/gin v1.6.3</span><br></pre></td></tr></table></figure><p>go module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit</p><p>go 会自动生成一个 go.sum 文件来记录 dependency tree</p><p><img src="https://upload-images.jianshu.io/upload_images/1293367-6d16a0d961653490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>再次执行脚本 go run main.go发现跳过了检查并安装依赖的步骤。</p><p>可以使用命令 go list -m -u all 来检查可以升级的package，使用go get -u need-upgrade-package 升级后会将新的依赖版本更新到go.mod * 也可以使用 go get -u 升级所有依赖</p><h3 id="go-get升级"><a href="#go-get升级" class="headerlink" title="go get升级"></a>go get升级</h3><ul><li>运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li><li>运行 go get -u=patch 将会升级到最新的修订版本</li><li>运行 go get package@version 将会升级到指定的版本号version</li><li>运行go get如果有版本的更改，那么go.mod文件也会更改</li></ul><h3 id="使用replace替换无法直接获取的package"><a href="#使用replace替换无法直接获取的package" class="headerlink" title="使用replace替换无法直接获取的package"></a>使用replace替换无法直接获取的package</h3><p>由于某些已知的原因，并不是所有的package都能成功下载，比如：golang.org下的包。</p><p>modules 可以通过在 go.mod 文件中使用 replace 指令替换成github上对应的库，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">    golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="go-mod发布和使用"><a href="#go-mod发布和使用" class="headerlink" title="go mod发布和使用"></a>go mod发布和使用</h3><p>参考Roberto Selbach写的go mod入门文章，文末，我给出链接</p><h3 id="Creating-a-Module"><a href="#Creating-a-Module" class="headerlink" title="Creating a Module"></a>Creating a Module</h3><p>如果你设置好go mod了，那你就可以在任何目录下随便创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> gomodone</span><br><span class="line"><span class="variable">$cd</span> gomodone</span><br></pre></td></tr></table></figure><p>在这个目录下创建一个文件<code>say.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gomodone</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// say Hi to someone</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个 <code>go.mod</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init github.com/jacksonyoudi/gomodone</span><br><span class="line">go: creating new go.mod: module github.com/jacksonyoudi/gomodone</span><br></pre></td></tr></table></figure><p>查看 go.mod内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.com/jacksonyoudi/gomodone</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>下面我们要将这个module发布到github上，然后在另外一个程序使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> init</span><br><span class="line"><span class="variable">$vim</span> .gitiiignore</span><br><span class="line"><span class="variable">$git</span> commit -am <span class="string">&quot;init&quot;</span></span><br><span class="line">// github创建对应的repo</span><br><span class="line"><span class="variable">$git</span> remote add origin git@github.com:jacksonyoudi/gomodone.git</span><br><span class="line"><span class="variable">$git</span> push -u origin master</span><br></pre></td></tr></table></figure><p>执行完，上面我们就相当于发布完了。</p><p>如果有人需要使用，就可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/jacksonyoudi/gomodone</span><br></pre></td></tr></table></figure><p>这个时候没有加tag，所以，没有版本的控制。默认是v0.0.0后面接上时间和commitid。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gomodone@v0.0.0-20200517004046-ee882713fd1e</span><br></pre></td></tr></table></figure><p>官方不建议这样做，没有进行版本控制管理。</p><h3 id="module-versioning"><a href="#module-versioning" class="headerlink" title="module versioning"></a>module versioning</h3><p>使用tag，进行版本控制</p><h4 id="making-a-release"><a href="#making-a-release" class="headerlink" title="making a release"></a>making a release</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>操作完，我们的module就发布了一个v1.0.0的版本了。</p><p>推荐在这个状态下，再切出一个分支，用于后续v1.0.0的修复推送,不要直接在master分支修复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout -b v1</span><br><span class="line"><span class="variable">$git</span> push -u origin v1</span><br></pre></td></tr></table></figure><h3 id="use-our-module"><a href="#use-our-module" class="headerlink" title="use our module"></a>use our module</h3><p>上面已经发布了一个v1.0.0的版本，我们可以在另一个项目中使用，创建一个go的项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> Gone</span><br><span class="line"><span class="variable">$cd</span> Gone</span><br><span class="line"><span class="variable">$vim</span> main.go</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jacksonyoudi/gomodone&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(gomodone.SayHi(<span class="string">&quot;Roberto&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写好了，我们生成 go mod文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init Gone</span><br></pre></td></tr></table></figure><p>上面命令执行完，会生成 go mod文件<br> 看下mod文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/jacksonyoudi/gomodone v1.0.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> package github.com/jacksonyoudi/gomodone</span><br><span class="line">go: found github.com/jacksonyoudi/gomodone <span class="keyword">in</span> github.com/jacksonyoudi/gomodone v1.0.0</span><br></pre></td></tr></table></figure><p>同时还生成了go.sum, 其中包含软件包的哈希值，以确保我们具有正确的版本和文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github.com/jacksonyoudi/gomodone v1.0.1 h1:jFd+qZlAB0R3zqrC9kwO8IgPrAdayMUS0rSHMDc/uG8=</span><br><span class="line">github.com/jacksonyoudi/gomodone v1.0.1/go.mod h1:XWi+BLbuiuC2YM8Qz4yQzTSPtHt3T3hrlNN2pNlyA94=</span><br><span class="line">github.com/jacksonyoudi/gomodone/v2 v2.0.0 h1:GpzGeXCx/Xv2ueiZJ8hEhFwLu7xjxLBjkOYSmg8Ya/w=</span><br><span class="line">github.com/jacksonyoudi/gomodone/v2 v2.0.0/go.mod h1:L8uFPSZNHoAhpaePWUfKmGinjufYdw9c2i70xtBorSw=</span><br></pre></td></tr></table></figure><p>这个内容是下面的，需要操作执行的结果</p><p>go run main.go就可以运行了</p><h3 id="Making-a-bugfix-release"><a href="#Making-a-bugfix-release" class="headerlink" title="Making a bugfix release"></a>Making a bugfix release</h3><p>假如fix一个bug,我们在v1版本上进行修复</p><p>修改代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// say Hi to someone</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">-       <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s&quot;</span>, name)</span><br><span class="line">+       <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s!&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复好，我们开始push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;Emphasize our friendliness&quot;</span> say.go</span><br><span class="line">$ git tag v1.0.1</span><br><span class="line">$ git push --tags origin v1</span><br></pre></td></tr></table></figure><h4 id="Updating-modules"><a href="#Updating-modules" class="headerlink" title="Updating modules"></a>Updating modules</h4><p>刚才fix bug，所以要在我们使用项目中更新</p><p>这个需要我们手动执行更新module操作</p><p>我们通过使用我们的好朋友来做到这一点go get：</p><ul><li>运行  <code>go get -u</code> 以使用最新的  minor  版本或修补程序版本（即它将从1.0.0更新到例如1.0.1，或者，如果可用，则更新为1.1.0）</li><li>运行  go get -u=patch 以使用最新的  修补程序  版本（即，将更新为1.0.1但不更新  为1.1.0）</li><li>运行go get package@version 以更新到特定版本（例如<a href="https://links.jianshu.com/go?to=http://github.com/jacksonyoudi/gomodone@v1.0.1">github.com/jacksonyoudi/gomodone@v1.0.1</a>）</li></ul><p>目前module最新的也是v1.0.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 更新最新</span><br><span class="line"><span class="variable">$go</span> get -u</span><br><span class="line"><span class="variable">$go</span> get -u=patch</span><br><span class="line">//指定包，指定版本</span><br><span class="line"><span class="variable">$go</span> get github.com/jacksonyoudi/gomodone@v1.0.1</span><br></pre></td></tr></table></figure><p>操作完，go.mod文件会修改如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/jacksonyoudi/gomodone v1<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Major-versions"><a href="#Major-versions" class="headerlink" title="Major versions"></a>Major versions</h4><p>根据语义版本语义，主要版本与次要版本  不同。主要版本可能会破坏向后兼容性。从Go模块的角度来看，主要版本是  完全不同的软件包。乍一看这听起来很奇怪，但这是有道理的：两个不兼容的库版本是两个不同的库。<br> 比如下面修改，完全破坏了兼容性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gomodone</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hi returns a friendly greeting</span></span><br><span class="line"><span class="comment">// Hi returns a friendly greeting in language lang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(name, lang <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lang &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;en&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pt&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Oi, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;es&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;¡Hola, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;fr&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Bonjour, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;unknown language&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们需要不同的大版本，这种情况下</p><p>修改 go.mod如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/jacksonyoudi/gomodone/v2</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后，重新tag，push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit say.go -m <span class="string">&quot;Change Hi to allow multilang&quot;</span></span><br><span class="line">$ git checkout -b v2 <span class="comment"># 用于v2版本，后续修复v2</span></span><br><span class="line">$ git commit go.mod -m <span class="string">&quot;Bump version to v2&quot;</span></span><br><span class="line">$ git tag v2.0.0</span><br><span class="line">$ git push --tags origin v2 </span><br></pre></td></tr></table></figure><h3 id="Updating-to-a-major-version"><a href="#Updating-to-a-major-version" class="headerlink" title="Updating to a major version"></a>Updating to a major version</h3><p>即使发布了库的新不兼容版本，现有软件 也不会中断，因为它将继续使用现有版本1.0.1。go get -u 将不会获得版本2.0.0。<br> 如果想使用v2.0.0,代码改成如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jacksonyoudi/gomodone/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g, err := gomodone.SayHi(<span class="string">&quot;Roberto&quot;</span>, <span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 go mod tidy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go: finding module <span class="keyword">for</span> package github.com/jacksonyoudi/gomodone/v2</span><br><span class="line">go: downloading github.com/jacksonyoudi/gomodone/v2 v2.0.0</span><br><span class="line">go: found github.com/jacksonyoudi/gomodone/v2 <span class="keyword">in</span> github.com/jacksonyoudi/gomodone/v2 v2.0.0</span><br></pre></td></tr></table></figure><p>当然，两个版本都可以同时使用, 使用别名<br> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jacksonyoudi/gomodone&quot;</span></span><br><span class="line">    mv2 <span class="string">&quot;github.com/jacksonyoudi/gomodone/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g, err := mv2.SayHi(<span class="string">&quot;Roberto&quot;</span>, <span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line"></span><br><span class="line">    fmt.Println(gomodone.SayHi(<span class="string">&quot;Roberto&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下 <code>go mod tidy</code></p><h3 id="Vendoring"><a href="#Vendoring" class="headerlink" title="Vendoring"></a>Vendoring</h3><p>默认是忽略vendor的，如果想在项目目录下有vendor可以执行下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> vendor</span><br></pre></td></tr></table></figure><p>当然，如果构建程序的时候，希望使用vendor中的依赖，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build -mod vendor</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的浅拷贝和深拷贝</title>
      <link href="/2021/11/29/go%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2021/11/29/go%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="go的浅拷贝和深拷贝"><a href="#go的浅拷贝和深拷贝" class="headerlink" title="go的浅拷贝和深拷贝"></a>go的浅拷贝和深拷贝</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>拷贝的是数据本身，创建一个新对象，新创建的对象与源对象不共享内存，新创建的对象在内存中开启一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。</p><p>值类型的数据，默认是深拷贝，Array，Int，String，Struct，Float，Bool。<br> <span id="more"></span></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>拷贝的是数据地址，只复制指向对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会发生变化。释放内存地址时，同时释放。</p><p>引用类型的数据，默认全部都是浅拷贝，Slice，Map。</p><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><p>是否真正获取对象数据，而不是引用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora历史版本下载地址</title>
      <link href="/2021/11/29/Typora%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
      <url>/2021/11/29/Typora%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora历史版本下载地址"><a href="#Typora历史版本下载地址" class="headerlink" title="Typora历史版本下载地址"></a>Typora历史版本下载地址</h1><p>Typora开始收费了</p><p><a href="https://typora.io/windows/dev_release.html">Typora for windows — beta version release</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git生成ssh</title>
      <link href="/2021/11/29/git%E7%94%9F%E6%88%90ssh/"/>
      <url>/2021/11/29/git%E7%94%9F%E6%88%90ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="git生成ssh"><a href="#git生成ssh" class="headerlink" title="git生成ssh"></a>git生成ssh</h1><p>输入 ssh 命令，查看本机是否安装 SSH：</p><p><img src="/images/v2-b4792b227defc69aa7927ca9b73e4316_720w.jpg" alt="img"><br> <span id="more"></span><br>如上图所示，即已安装 SSH. 然后，输入 ssh-keygen -t rsa 命令<em><strong>（注意空格）</strong></em>，表示我们指定 RSA 算法生成密钥，然后敲四次回车键，之后就就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub. ***（注意：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和 Shift+insert.）***文件的位置在 Git Bash 上面都有显示，默认生成在以下目录：</p><ul><li>Linux 系统：~/.ssh</li><li>Mac 系统：~/.ssh</li><li>Windows 10 ：C:/Users/ASUS/.ssh</li></ul><p>接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，你可以通过目录找到 id_rsa.pub 文件的位置，用记事本打开文件复制。如果你实在找不到文件也没有关系，按照以下步骤直接在 Git Bash 上打开就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh </span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="/images/v2-692b1cd8e719dac8012afe6fda775209_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在gin框架中使用gorilla实现websocket</title>
      <link href="/2021/11/29/%E5%9C%A8gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8gorilla%E5%AE%9E%E7%8E%B0websocket/"/>
      <url>/2021/11/29/%E5%9C%A8gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8gorilla%E5%AE%9E%E7%8E%B0websocket/</url>
      
        <content type="html"><![CDATA[<h1 id="在gin框架中使用gorilla实现websocket"><a href="#在gin框架中使用gorilla实现websocket" class="headerlink" title="在gin框架中使用gorilla实现websocket"></a>在gin框架中使用gorilla实现websocket</h1><h2 id="go代码"><a href="#go代码" class="headerlink" title="go代码"></a>go代码</h2><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gorilla/websocket&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//用来记录连接的cone</span></span><br><span class="line"><span class="keyword">var</span> wsargs []*websocket.Conn</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置websocket</span></span><br><span class="line"><span class="comment">//CheckOrigin防止跨站点的请求伪造</span></span><br><span class="line"><span class="keyword">var</span> upGrader = websocket.Upgrader&#123;</span><br><span class="line">CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//升级get请求为webSocket协议</span></span><br><span class="line">ws, err := upGrader.Upgrade(c.Writer, c.Request, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ws.Close() <span class="comment">//返回前关闭</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> wsargs &#123;</span><br><span class="line"><span class="keyword">if</span> v == ws &#123;</span><br><span class="line">wsargs = <span class="built_in">append</span>(wsargs[:k], wsargs[k+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()<span class="comment">//返回前在集合中删除对应的cone</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;删除&quot;</span>)</span><br><span class="line">wsargs = <span class="built_in">append</span>(wsargs, ws)</span><br><span class="line">fmt.Println(wsargs)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//读取ws中的数据</span></span><br><span class="line">mt, message, err := ws.ReadMessage()</span><br><span class="line">fmt.Println(mt)</span><br><span class="line">fmt.Println(message)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入ws数据</span></span><br><span class="line">err = ws.WriteMessage(mt, message)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> wsargs &#123;</span><br><span class="line">err := v.WriteMessage(<span class="number">1</span>, []<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, ping)</span><br><span class="line">r.GET(<span class="string">&quot;/ping2&quot;</span>, ping2)</span><br><span class="line">r.Run(<span class="string">&quot;:12345&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:12345/ping&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//连接打开时触发 </span></span></span><br><span class="line"><span class="javascript">    ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>);</span></span><br><span class="line"><span class="javascript">      ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//接收到消息时触发  </span></span></span><br><span class="line"><span class="javascript">    ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Received Message: &quot;</span> + evt.data);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//连接关闭时触发  </span></span></span><br><span class="line"><span class="javascript">    ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="websocket在线测试网址"><a href="#websocket在线测试网址" class="headerlink" title="websocket在线测试网址"></a>websocket在线测试网址</h2><p><a href="http://coolaf.com/tool/chattest">在线websocket测试-online tool-postjson (coolaf.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo数据库连接问题</title>
      <link href="/2021/11/26/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/26/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="mongo数据库连接问题"><a href="#mongo数据库连接问题" class="headerlink" title="mongo数据库连接问题"></a>mongo数据库连接问题</h1><p>在服务器设置好mongo的账号密码后</p><p><img src="/images/image-20211126144037696.png" alt="image-20211126144037696"><br> <span id="more"></span><br>直接输入mongo，进入操作时。会发现无法展示自己的数据库了。</p><p>这个其实是没有登录的原因</p><p><img src="/images/image-20211126144208185.png" alt="image-20211126144208185"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.auth(&quot;账号&quot;,&quot;密码&quot;)</span><br></pre></td></tr></table></figure><p>返回值为1代表登录成功</p><p><img src="/images/image-20211126144308939.png" alt="image-20211126144308939"></p><p>现在便可以正常的操作mongo了</p>]]></content>
      
      
      <categories>
          
          <category> mongo连接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/11/25/%E9%97%AD%E5%8C%85/"/>
      <url>/2021/11/25/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h3 id="“官方”的解释是："><a href="#“官方”的解释是：" class="headerlink" title="“官方”的解释是："></a>“官方”的解释是：</h3><p>所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br> <span id="more"></span></p><h3 id="维基百科讲"><a href="#维基百科讲" class="headerlink" title="维基百科讲"></a>维基百科讲</h3><p>闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p><p>解析：</p><p>使用闭包主要是为了设计私有的方法和变量。</p><p>闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在JavaScript中，函数即闭包，只有函数才会产生作用域。<br>闭包有3个特性：</p><p>（1）函数嵌套函数。<br>（2）在函数内部可以引用外部的参数和变量。<br>（3）参数和变量不会以垃圾回收机制回收。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang发送邮件</title>
      <link href="/2021/11/25/golang%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2021/11/25/golang%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="golang发送邮件"><a href="#golang发送邮件" class="headerlink" title="golang发送邮件"></a>golang发送邮件</h1><p>电子邮件在网络中传输和网页一样需要遵从特定的协议，常用的电子邮件协议包括 SMTP，POP3，IMAP。其中邮件的创建和发送只需要用到 SMTP协议，所以本文也只会涉及到SMTP协议。SMTP 是 Simple Mail Transfer Protocol 的简称，即简单邮件传输协议。<br> <span id="more"></span></p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>发件人，收件人，密件抄送和抄送字段</p></li><li><p>文字和HTML邮件正文</p></li><li><p>附件</p></li><li><p>阅读收据</p></li><li><p>自定义标题</p></li><li><p>首先我们登录QQ邮箱，设置-&gt;账户 找到图片的位置开启<code>POP3/SMTP/IMAP</code>并且按照要求生产授权码</p></li></ul><p><img src="/images/image_3.png" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/smtp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jordan-wright/email&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">e := email.NewEmail()</span><br><span class="line"><span class="comment">//设置发送方的邮箱</span></span><br><span class="line">e.From = <span class="string">&quot;dj &lt;2061529596@qq.com&gt;&quot;</span></span><br><span class="line"><span class="comment">// 设置接收方的邮箱</span></span><br><span class="line">e.To = []<span class="keyword">string</span>&#123;<span class="string">&quot;1264646904@qq.com&quot;</span>,<span class="string">&quot;3161362058@qq.com&quot;</span>&#125;</span><br><span class="line"><span class="comment">//设置主题</span></span><br><span class="line">e.Subject = <span class="string">&quot;这是主题&quot;</span></span><br><span class="line"><span class="comment">//设置文件发送的内容</span></span><br><span class="line">e.Text = []<span class="keyword">byte</span>(<span class="string">&quot;www.topgoer.com是个不错的go语言中文文档&quot;</span>)</span><br><span class="line"><span class="comment">//设置服务器相关的配置</span></span><br><span class="line">err := e.Send(<span class="string">&quot;smtp.qq.com:25&quot;</span>, smtp.PlainAuth(<span class="string">&quot;&quot;</span>, <span class="string">&quot;2061529596@qq.com&quot;</span>, <span class="string">&quot;zmawrrwtiyfxcgcc&quot;</span>, <span class="string">&quot;smtp.qq.com&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在服务器中使用"><a href="#在服务器中使用" class="headerlink" title="在服务器中使用"></a>在服务器中使用</h3><p>将”smtp.qq.com:25”换成”smtp.qq.com:587”</p><blockquote><p>云服务器基本都关闭了25端口。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC概念</title>
      <link href="/2021/11/24/gRPC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/11/24/gRPC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC概念"><a href="#gRPC概念" class="headerlink" title="gRPC概念"></a>gRPC概念</h1><h2 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h2><p>在 gRPC 里<em>客户端</em>应用可以像调用本地对象一样直接调用另一台不同的机器上<em>服务端</em>应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个<em>服务</em>，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个<em>存根</em>能够像服务端一样的方法。</p><p><img src="/images/grpc_concept_diagram_00.png" alt="图1"><br> <span id="more"></span></p><h3 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h3><p>gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 <em>proto files</em> 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。你可以在 <a href="http://doc.oschina.net/https%EF%BC%9A//developers.google.com/protocol-buffers/docs/overview">Protocol Buffers 文档</a>找到更多关于 Protocol Buffers 的资料。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h3><p>正如其他 RPC 系统，gRPC 基于如下思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 作为接口定义语言，来描述服务接口和有效载荷消息结构。如果有需要的话，可以使用其他替代方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service HelloService &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  required string greeting = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">  required string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gRPC 允许你定义四类服务方法：</p><ul><li>单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns (stream HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-API-接口"><a href="#使用-API-接口" class="headerlink" title="使用 API 接口"></a>使用 API 接口</h3><p>gRPC 提供 protocol buffer 编译插件，能够从一个服务定义的 .proto 文件生成客户端和服务端代码。通常 gRPC 用户可以在服务端实现这些API，并从客户端调用它们。</p><ul><li>在服务侧，服务端实现服务接口，运行一个 gRPC 服务器来处理客户端调用。gRPC 底层架构会解码传入的请求，执行服务方法，编码服务应答。</li><li>在客户侧，客户端有一个<em>存根</em>实现了服务端同样的方法。客户端可以在本地存根调用这些方法，用合适的 protocol buffer 消息类型封装这些参数— gRPC 来负责发送请求给服务端并返回服务端 protocol buffer 响应。</li></ul><h3 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h3><p>同步 RPC 调用一直会阻塞直到从服务端获得一个应答，这与 RPC 希望的抽象最为接近。另一方面网络内部是异步的，并且在许多场景下能够在不阻塞当前线程的情况下启动 RPC 是非常有用的。</p><p>在多数语言里，gRPC 编程接口同时支持同步和异步的特点。你可以从每个语言教程和参考文档里找到更多内容(很快就会有完整文档)。</p><h2 id="RPC-生命周期"><a href="#RPC-生命周期" class="headerlink" title="RPC 生命周期"></a>RPC 生命周期</h2><p>现在让我们来仔细了解一下当 gRPC 客户端调用 gRPC 服务端的方法时到底发生了什么。我们不究其实现细节，关于实现细节的部分，你可以在我们的特定语言页面里找到更为详尽的内容。</p><h3 id="单项-RPC"><a href="#单项-RPC" class="headerlink" title="单项 RPC"></a>单项 RPC</h3><p>首先我们来了解一下最简单的 RPC 形式：客户端发出单个请求，获得单个响应。</p><ul><li>一旦客户端通过桩调用一个方法，服务端会得到相关通知 ，通知包括客户端的元数据，方法名，允许的响应期限（如果可以的话）</li><li>服务端既可以在任何响应之前直接发送回初始的元数据，也可以等待客户端的请求信息，到底哪个先发生，取决于具体的应用。</li><li>一旦服务端获得客户端的请求信息，就会做所需的任何工作来创建或组装对应的响应。如果成功的话，这个响应会和包含状态码以及可选的状态信息等状态明细及可选的追踪信息返回给客户端 。</li><li>假如状态是 OK 的话，客户端会得到应答，这将结束客户端的调用。</li></ul><h3 id="服务端流式-RPC"><a href="#服务端流式-RPC" class="headerlink" title="服务端流式 RPC"></a>服务端流式 RPC</h3><p>服务端流式 RPC 除了在得到客户端请求信息后发送回一个应答流之外，与我们的简单例子一样。在发送完所有应答后，服务端的状态详情(状态码和可选的状态信息)和可选的跟踪元数据被发送回客户端，以此来完成服务端的工作。客户端在接收到所有服务端的应答后也完成了工作。</p><h3 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h3><p>客户端流式 RPC 也基本与我们的简单例子一样，区别在于客户端通过发送一个请求流给服务端，取代了原先发送的单个请求。服务端通常（但并不必须）会在接收到客户端所有的请求后发送回一个应答，其中附带有它的状态详情和可选的跟踪数据。</p><h3 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h3><p>双向流式 RPC ，调用由客户端调用方法来初始化，而服务端则接收到客户端的元数据，方法名和截止时间。服务端可以选择发送回它的初始元数据或等待客户端发送请求。 下一步怎样发展取决于应用，因为客户端和服务端能在任意顺序上读写 - 这些流的操作是完全独立的。例如服务端可以一直等直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像”乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。</p><h3 id="截止时间"><a href="#截止时间" class="headerlink" title="截止时间"></a>截止时间</h3><p>gRPC 允许客户端在调用一个远程方法前指定一个最后期限值。这个值指定了在客户端可以等待服务端多长时间来应答，超过这个时间值 RPC 将结束并返回<code>DEADLINE_EXCEEDED</code>错误。在服务端可以查询这个期限值来看是否一个特定的方法已经过期，或者还剩多长时间来完成这个方法。 各语言来指定一个截止时间的方式是不同的 - 比如在 Python 里一个截止时间值总是必须的，但并不是所有语言都有一个默认的截止时间。</p><h3 id="RPC-终止"><a href="#RPC-终止" class="headerlink" title="RPC 终止"></a>RPC 终止</h3><p>在 gRPC 里，客户端和服务端对调用成功的判断是独立的、本地的，他们的结论可能不一致。这意味着，比如你有一个 RPC 在服务端成功结束(“我已经返回了所有应答!”)，到那时在客户端可能是失败的(“应答在最后期限后才来到!”)。也可能在客户端把所有请求发送完前，服务端却判断调用已经完成了。</p><h3 id="取消-RPC"><a href="#取消-RPC" class="headerlink" title="取消 RPC"></a>取消 RPC</h3><p>无论客户端还是服务端均可以再任何时间取消一个 RPC 。一个取消会立即终止 RPC 这样可以避免更多操作被执行。它<em>不是</em>一个”撤销”， 在取消前已经完成的不会被回滚。当然，通过同步调用的 RPC 不能被取消，因为直到 RPC 结束前，程序控制权还没有交还给应用。</p><h3 id="元数据集"><a href="#元数据集" class="headerlink" title="元数据集"></a>元数据集</h3><p>元数据是一个特殊 RPC 调用对应的信息(<a href="http://doc.oschina.net/docs/guides/auth.html">授权详情</a>]) ，这些信息以键值对的形式存在，一般键的类型是字符串，值的类型一般也是字符串(当然也可以是二进制数据)。元数据对 gRPC 本事来说是不透明的 - 它让客户端提供调用相关的信息给服务端，反之亦然。 对于元数据的访问是语言相关的。</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>TBD</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>TBD</p><h3 id="频道"><a href="#频道" class="headerlink" title="频道"></a>频道</h3><p>在创建客户端存根时，一个 gRPC 频道提供一个特定主机和端口服务端的连接。客户端可以通过指定频道参数来修改 gRPC 的默认行为，比如打开关闭消息压缩。一个频道具有状态，包含<code>已连接</code>和<code>空闲</code> 。 gRPC 如何处理关闭频道是语言相关的。有些语言可允许询问频道状态。</p>]]></content>
      
      
      <categories>
          
          <category> gRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB逻辑操作符$or, $and,$not,$nor</title>
      <link href="/2021/11/23/MongoDB%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6$or,%20$and,$not,$nor/"/>
      <url>/2021/11/23/MongoDB%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6$or,%20$and,$not,$nor/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB逻辑操作符-or-and-not-nor"><a href="#MongoDB逻辑操作符-or-and-not-nor" class="headerlink" title="MongoDB逻辑操作符$or, $and,$not,$nor"></a>MongoDB逻辑操作符$or, $and,$not,$nor</h1><h2 id="or"><a href="#or" class="headerlink" title="$or"></a>$or</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">$match</span>: &#123; <span class="attr">$or</span>: [&#123; <span class="attr">name</span>: &#123; <span class="attr">$regex</span>: params.str &#125; &#125;, &#123; <span class="attr">class</span>: &#123; <span class="attr">$regex</span>: params.str &#125; &#125;, &#123; <span class="attr">studentId</span>: &#123; <span class="attr">$regex</span>: params.str &#125; &#125;] &#125; &#125;,</span><br></pre></td></tr></table></figure><p>是一个逻辑or操作符操作在一个数据或者多个表达式并且需要选择至少一个满足条件的表达式，$or有至少以下表达式：<br> <span id="more"></span><br>{ $or: [ { <expression1> }, { <expression2> }, … , { <expressionN> } ] }<br>考虑下面的例子：</p><p>db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } )<br>上面的例子会查询集合inventory中所有字段quantity小于20或者price等于10的所有文档。</p><p>使用$or条件评估条款，MongoDB会扫描整个文档集合，如果所有的条件支持索引，MongoDB进行索引扫描，因此MongoDB使用索引执行$or表达式，$or中的所有表达式必须支持索引，否则的话MongoDB就会扫描整个集合。</p><p>当使用$or查询并且使用索引时，每个$or的条件表达式都可以使用自己的索引，考虑下面的查询：</p><p>db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } )<br>支持上面的查询你不需要创建一个符合索引，而是在字段quantity上创建一个索引，在price上创建一个索引。<br>db.inventory.createIndex( { quantity: 1 } )<br>db.inventory.createIndex( { price: 1 } )<br>$or和sort()操作<br>当使用$or执行sort()查询时，MongoDB可以使用支持$or查询条件的索引。之前的版本不支持索引。</p><h2 id="or与-in"><a href="#or与-in" class="headerlink" title="$or与$in"></a>$or与$in</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">$match</span>: &#123; <span class="attr">role</span>: &#123; <span class="attr">$in</span>: IDs &#125; &#125; &#125;,</span><br></pre></td></tr></table></figure><p>使用$or操作比较字段的值是否等于某个值时可以使用$in替换$or操作；例如查询集合inventory中字段quantity的值等于20或者50的所有文档，使用$in操作：</p><p>db.inventory.find ( { quantity: { $in: [20, 50] } } )</p><p>$and逻辑表达式</p><p>语法：{ $and: [ { <expression1> }, { <expression2> } , … , {<expressionN> } ] }</p><p>$and执行一个逻辑and操作在一个或者多个表达式上，并且查询数组中指定的所有表达式指定的文档document,$and使用短路求值，如果第一个表达式的结果是false，MongoDB将不会执行剩余的表达式；</p><p>例如：and查询指定同一个字段的多个查询条件</p><p>db.inventory.find( { $and: [ { price: { $ne: 1.99 } }, { price: { $exists: true } } ] } )<br>这个查询会选择集合inventory中的所有文档，条件是price不等于1.99并且price字段存在；<br>以上查询还可以使用隐式AND操作，如下：</p><p>db.inventory.find( { price: { $ne: 1.99, $exists: true } } )<br>AND查询使用多个表达式指定相同的操作：</p><p>db.inventory.find( {<br>    $and : [<br>        { $or : [ { price : 0.99 }, { price : 1.99 } ] },<br>        { $or : [ { sale : true }, { qty : { $lt : 20 } } ] }<br>    ]<br>} )<br>以上字段将会查询price字段值等于0.99或1.99并且sale字段值为true或者qty小于20的所有文档；<br>使用隐式AND操作无法构建此查询，因为它不止一次使用$or操作；</p><h2 id="not"><a href="#not" class="headerlink" title="$not"></a>$not</h2><p>语法： { field: { $not: { <operator-expression> } } }</p><p>$not执行一个逻辑not操作在指定的表达式并查询到不匹配表达式的文档，这包含不包括字段的文档；</p><p>考虑如下操作：</p><p>db.inventory.find( { price: { $not: { $gt: 1.99 } } } )<br>此查询将会查询inventory集合中的文档，条件如下： price字段小于等于1.99或者price不存在。<br>{ $not: { $gt: 1.99 } } 不同于$lte操作，{ $lte: 1.99 }操作只会返回price字段存在并且小于等于1.99的字段。</p><p>记住$not操作符只会影响其他操作符不能独立检查字段和文档，因此使用$not做逻辑析取和$ne操作测试字段内容；</p><p>使用$not操作时考虑如下操作：</p><p>操作$not操作符和其它操作符一致但是会产生一些意想不到的结果，比如数组之类的数据类型；</p><p>$not操作符不支持$regex正则表达式操作，使用//或者你的驱动接口代替，使用语言的正则表达式功能创建正则表达式对象；</p><p>考虑下面的例子使用模式匹配//:</p><p>db.inventory.find( { item: { $not: /^p.*/ } } )</p><p>此查询将会查询inventory集合中item字段不是以p开头的所有文档；</p><h2 id="nor"><a href="#nor" class="headerlink" title="$nor"></a>$nor</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">$match</span>: &#123; <span class="attr">$nor</span>: [&#123; <span class="string">&quot;weeklyreport.submissionWeek&quot;</span>: &#123; <span class="attr">$gte</span>: params.week &#125; &#125;] &#125; &#125;,</span><br></pre></td></tr></table></figure><p>{ $nor: [ { <expression1> }, { <expression2> }, …  { <expressionN> } ] }<br>考虑如下操作：</p><p>db.inventory.find( { $nor: [ { price: 1.99 }, { sale: true } ]  } )<br>查询返回所有的文档，条件是：</p><p>包含字段price值不等于1.99，包含字段sale值不等于true,或者包含字段price值不等于1.99，不包含字段sale；或者不包含字段price,包含字段sale值不等于true;或者不包含字段price，不包含字段sale;</p><p>$nor额外比较</p><p>考虑入校操作：</p><p>db.inventory.find( { $nor: [ { price: 1.99 }, { qty: { $lt: 20 } }, { sale: true } ] }<br>inventory集合查询所有的文档，条件如下：<br>字段price不等于1.99，字段qty不小于20，字段sale不等于true;查询的结果包含不存在的字段；</p>]]></content>
      
      
      <categories>
          
          <category> mongo聚合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中BSON的使用方法</title>
      <link href="/2021/11/19/golang%E4%B8%ADBSON%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2021/11/19/golang%E4%B8%ADBSON%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="golang中BSON的使用方法"><a href="#golang中BSON的使用方法" class="headerlink" title="golang中BSON的使用方法"></a>golang中BSON的使用方法</h1><p>关于mongodb-go-driver这个包里面的BSOM</p><p>bson是一种类似json的二进制存储形式，它就是mongodb的存储结构，它的数据结构要比json多，如 int, long, date, floating point, and decimal128。<br> <span id="more"></span><br>我在mongodb官网找到一个blog里面也写了我用的go的mongodb拓展中bson的介绍( <a href="https://www.oschina.net/action/GoToLink?url=https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial">https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial</a> ),他是这样写的。</p><p> The Go Driver has two families of types for representing BSON data: The <code>D</code> types and the <code>Raw</code> types.</p><p>The <code>D</code> family of types is used to concisely build BSON objects using native Go types. This can be particularly useful for constructing commands passed to MongoDB. The <code>D</code> family consists of four types:</p><ul><li><code>D</code>: A BSON document. This type should be used in situations where order matters, such as MongoDB commands.</li><li><code>M</code>: An unordered map. It is the same as <code>D</code>, except it does not preserve order.</li><li><code>A</code>: A BSON array.</li><li><code>E</code>: A single element inside a <code>D</code>.</li></ul><p>The <code>Raw</code> family of types is used for validating a slice of bytes. You can also retrieve single elements from Raw types using a <a href="https://www.oschina.net/action/GoToLink?url=https://godoc.org/go.mongodb.org/mongo-driver/bson%23Raw.Lookup"><code>Lookup()</code></a>. This is useful if you don’t want the overhead of having to unmarshall the BSON into another type. </p><p>大概意思是：这个mongodb GO版的拓展有两种族来使用bosn数据，一个D还有一个是RAW。</p><p>D族是使用原生GO的形式来简单的构造一个BSON对象。这个对于使用命令来操作mongodb是十分有用的。D()由下面4种类型：</p><p>D:一个BSON文档，这个类型应该被用在顺序比较重要的场合（言外之意就是有序的），比如说mongodb的命令。</p><p>M:一个无序的map。它除了无序之外和D是一样的（可以理解为map和bson是可以转换）。</p><p>A:一个BSON形式的数组。</p><p>E:一个D里面的单独元素。(就是文档里的一个元素)</p><p>RAW族是被用来判断是否为bytes的一个slice。你也可以用look up()方法从RAW取得一个元素。这可以在你将BSON转化为另一个形式的数据时是十分有用的(原文大概意思是可以节省你转化数据时的开销)。</p><p>下面简单说下在操作D族时会有使用到一些条件参数。</p><p>不等于!=($ne)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$ne&quot;: &quot;Tom&quot;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>大于&gt;($gt)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$gt&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>小于&lt;($lt)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$lt&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>大于等于&gt;=($gte)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$gte&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>小于等于&lt;=($lte)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$lte&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>in($in)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$in&quot;: []string&#123;&quot;Tom&quot;, &quot;Jerry&quot;&#125;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>no in(nin)同<em>n<strong>i</strong>n</em>)同in</p><p>是否包含这个键($exists)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$exists&quot;: true&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>查询键值为null的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$in&quot;:[]interface&#123;&#125;&#123;null&#125;, &quot;$exists&quot;: true&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>正则匹配($regex)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$regex&quot;: &quot;^[0-9]+&quot;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>$all查询所有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$all&quot;: []int&#123;10,11,12&#125;&#125;&#125;).All(&amp;users</span><br></pre></td></tr></table></figure><p>$or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;$or&quot;: []bson.M&#123;bson.M&#123;&quot;age&quot;: 11&#125;, bson.M&#123;&quot;sex&quot;: 1&#125;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>修改$set</p><p>增加值$incr</p><p>向数组增加一个元素$push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.D&#123;&#123;&quot;name&quot;, &quot;Speike&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">update := bson.D&#123;</span><br><span class="line">   &#123;&quot;$push&quot;, bson.D&#123;</span><br><span class="line">      &#123;&quot;interests&quot;, &quot;sing&quot;&#125;,</span><br><span class="line">   &#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">updateResult, err := collection.UpdateOne(context.TODO(), filter, update)</span><br></pre></td></tr></table></figure><p>移除数组一个元素$pull</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.D&#123;&#123;&quot;name&quot;, &quot;Speike&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">update := bson.D&#123;</span><br><span class="line">   &#123;&quot;$pull&quot;, bson.D&#123;</span><br><span class="line">      &#123;&quot;interests&quot;, &quot;sing&quot;&#125;,</span><br><span class="line">   &#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">updateResult, err := collection.UpdateOne(context.TODO(), filter, update)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL（软件系统）总结</title>
      <link href="/2021/11/19/MySQL(%E7%AC%94%E8%AE%B0)/"/>
      <url>/2021/11/19/MySQL(%E7%AC%94%E8%AE%B0)/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL（软件系统）总结"><a href="#MySQL（软件系统）总结" class="headerlink" title="MySQL（软件系统）总结"></a>MySQL（软件系统）总结</h1><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>MySQL是C/S架构的软件</p><p>软件的架构有：B/S、C/S</p><p>——B/S：B:浏览器，S:服务器（网页上直接能运行，如京东，淘宝）</p><p>——C/S：C:客户端，S:服务器（需要安装或下载客户端的软件）<br> <span id="more"></span></p><h3 id="数据库的基本分类"><a href="#数据库的基本分类" class="headerlink" title="数据库的基本分类"></a>数据库的基本分类</h3><p>关系型数据库：MySQL、Oracle、DB2……</p><p>非关系型数据库：Mongo dB、Redis……</p><h3 id="SQL脚本"><a href="#SQL脚本" class="headerlink" title="SQL脚本"></a>SQL脚本</h3><p>1、一堆SQL代码，后缀为.sql的文件</p><p>DB、DBMS、SQL</p><p>DB： Database 数据库</p><p>​        主要是表，表是数据库基本组成单元</p><p>DBMS： Database Management System，数据库管理系统</p><p>SQL：结构化查询语言，标准的关系型数据库语言</p><p>三者的关系：DBMS—执行–&gt;SQL–操作–&gt;DB</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>（1）行：记录/数据，存储一条完整的信息</p><p>​        —-数据</p><p>​        —-数据类型</p><p>​        —-数据约束</p><p>（2）列：列名，存储列的相关信息</p><h3 id="SQL，操作或控制数据库（DB）"><a href="#SQL，操作或控制数据库（DB）" class="headerlink" title="SQL，操作或控制数据库（DB）"></a>SQL，操作或控制数据库（DB）</h3><p>​        —-DQL（数据查询语言）：主要是对SELECT操作的支持</p><p>​        —-DML（数据操作语言）：数据库对增（INSERT）删（DELETE）改（UPDATE）</p><p>​        —-TCL（事务控制语言）：提交（COMMIT）回滚（ROLLBACK）</p><p>​        —-DCL（数据控制语言）：授权（GRANT）等</p><p>​        —-DDL（数据定义语言）：创建（CREATE）删除（DROP）修改（ALTER）等支持</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>SELECT————-查询</p><p>FROM—————来自</p><p>DISTINCT———-去除重复（行）</p><h3 id="子句的概念"><a href="#子句的概念" class="headerlink" title="子句的概念"></a>子句的概念</h3><p>​        关键字+后面写的代码</p><h3 id="子句的作用"><a href="#子句的作用" class="headerlink" title="子句的作用"></a>子句的作用</h3><p>SELECT子句：控制列的显示，有的时候也可称之为“数据投影”</p><p>FROM子句：确定数据的来源</p><h3 id="子句的书写顺序"><a href="#子句的书写顺序" class="headerlink" title="子句的书写顺序"></a>子句的书写顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>……<span class="keyword">FROM</span>……</span><br></pre></td></tr></table></figure><h3 id="子句的执行顺序"><a href="#子句的执行顺序" class="headerlink" title="子句的执行顺序"></a>子句的执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>……<span class="keyword">SELECT</span>……</span><br></pre></td></tr></table></figure><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>显示所有</p><p>​        面试题</p><p>​            问题：使用*号好还是使用所有列名好？——-要能自圆其说</p><p>​            目的：二者谁的执行效率高？———————列名</p><p>四则运算</p><p>​        注意空值参与运算    如果没有处理，结果一定是空值</p><p>别名的使用</p><p>​        表名+空格+表别名</p><p>数据排序（新的子句）</p><p>​        关键字：ORDER BY</p><p>​        子句：ORDER BY 子句</p><p>​        子句的作用：按指定的列或者多个列进行排序</p><p>​        子句的书写顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT……FROM……ORDER BY……</span><br></pre></td></tr></table></figure><p>​        子句执行顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM……SELECT……ORDER BY……</span><br></pre></td></tr></table></figure><p>​        注意：排序</p><p>​            数字，字典……</p><p>​            升序、降序</p><p>​                升序：ASC</p><p>​                降序：DESC</p><p>​        面试题：</p><p>​            （1）可以使用列别名排序吗？——可以</p><p><img src="/images/image-20210102140918977.png" alt="image-20210102140918977"></p><p>​            （2）可以使用序号排序吗？———可以</p><p><img src="/images/image-20210102140841660.png" alt="image-20210102140841660"></p><h3 id="命令和关键字的区别"><a href="#命令和关键字的区别" class="headerlink" title="命令和关键字的区别"></a>命令和关键字的区别</h3><p>功能作用：</p><p>​    DESC：作为关键字是降序，作为命令是查询表结构。</p><p>是否可以缩写：</p><p>​    命令是可以缩写的，如：DESC全命令是DESCRIBE</p><p>​    关键字是不能缩写的</p><h1 id="增删改-DML操作"><a href="#增删改-DML操作" class="headerlink" title="增删改(DML操作)"></a>增删改(DML操作)</h1><h2 id="增-INSERT"><a href="#增-INSERT" class="headerlink" title="增(INSERT)"></a>增(INSERT)</h2><p>关键字：INSERT INTO,VALUES</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><h3 id="增加表列"><a href="#增加表列" class="headerlink" title="增加表列"></a>增加表列</h3><h3 id="增加数据-INSERT-INTO"><a href="#增加数据-INSERT-INTO" class="headerlink" title="增加数据(INSERT INTO)"></a>增加数据(INSERT INTO)</h3><p>方法一：列名与value一一对应，能自定义列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2,列名3……)</span><br><span class="line">VALUES(values1,values2,values3……)</span><br></pre></td></tr></table></figure><p>方法二：省略列名但，需要按表中列的顺序一一写上数据，不能少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名</span><br><span class="line">VALUES(values1,values2,values3……);</span><br></pre></td></tr></table></figure><h2 id="删-DELETE"><a href="#删-DELETE" class="headerlink" title="删(DELETE)"></a>删(DELETE)</h2><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><h3 id="删除表列"><a href="#删除表列" class="headerlink" title="删除表列"></a>删除表列</h3><h3 id="删除数据-危险操作-带上条件"><a href="#删除数据-危险操作-带上条件" class="headerlink" title="删除数据[危险操作-带上条件]"></a>删除数据[危险操作-带上条件]</h3><p>关键字：DELETE,FROM,WHERE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 </span><br><span class="line">WHERE 条件</span><br></pre></td></tr></table></figure><blockquote><p>注意：删除操作，一定带上条件，否则删除表中所有数据</p></blockquote><h2 id="改-UPDATE"><a href="#改-UPDATE" class="headerlink" title="改(UPDATE)"></a>改(UPDATE)</h2><h3 id="修改数据库名"><a href="#修改数据库名" class="headerlink" title="修改数据库名"></a>修改数据库名</h3><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>关键字：UPDATE,SET,WHERE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名</span><br><span class="line">SET column1=value1,column2=value2,...</span><br><span class="line">WHERE 条件</span><br></pre></td></tr></table></figure><blockquote><p>注意：更新操作，一定带上条件，否则更新表中所有数据</p></blockquote><h1 id="查-SELECT"><a href="#查-SELECT" class="headerlink" title="查(SELECT)"></a>查(SELECT)</h1><p>SELECT语句完整语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(7)  SELECT </span><br><span class="line">(8)  DISTINCT &lt;select_list&gt;</span><br><span class="line">(1)  FROM &lt;left_table&gt;</span><br><span class="line">(3)  &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(2)  ON &lt;join_condition&gt;</span><br><span class="line">(4)  WHERE &lt;where_condition&gt;</span><br><span class="line">(5)  GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(6)  HAVING &lt;having_condition&gt;</span><br><span class="line">(9)  ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">(10) LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><p>执行顺序</p><p>FROM—&gt;ON—&gt;JOIN—&gt;WHERE—&gt;GROUP BY—&gt;HAVING—&gt;SELECT—&gt;DISTINCT—&gt;ORDER BY—&gt;LIMIT</p><h3 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC emp(表名)</span><br></pre></td></tr></table></figure><h3 id="无条件查询"><a href="#无条件查询" class="headerlink" title="无条件查询"></a>无条件查询</h3><p>1.查询表的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  *</span><br><span class="line">FROM 表名(表别名);</span><br></pre></td></tr></table></figure><p>2.查询表对应列的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名1(表别名1)、列名2(表别名2)、列名3(表别名3)……</span><br><span class="line">FROM 表名(表别名);</span><br></pre></td></tr></table></figure><p>3.无重复的查询表的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  DISTINCT *</span><br><span class="line">FROM 表名(表别名);</span><br></pre></td></tr></table></figure><p>2.无重复的查询表对应列的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名1(列别名1)、列名2(列别名2)、列名3(列别名3)……</span><br><span class="line">FROM 表名(列别名);</span><br></pre></td></tr></table></figure><h3 id="条件查询（WHERE）"><a href="#条件查询（WHERE）" class="headerlink" title="条件查询（WHERE）"></a>条件查询（WHERE）</h3><h4 id="1-基本语句："><a href="#1-基本语句：" class="headerlink" title="1.基本语句："></a>1.基本语句：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT……</span><br><span class="line">FROM……</span><br><span class="line">WHERE 条件</span><br></pre></td></tr></table></figure><p>关键字</p><p>​    SELECT、FROM、WHERE</p><p>子句</p><p>​    </p><p>子句的作用</p><p>子句的书写顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT……FROM……WHERE……</span><br></pre></td></tr></table></figure><p>子句的执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM……WHERE……SELECT……</span><br></pre></td></tr></table></figure><h4 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h4><p>​    基本比较运算符</p><blockquote><p>​        &lt;、&gt;、=、!=(不等于)、&lt;&gt;(不等于)、&gt;=、&lt;=</p></blockquote><p>​    基本逻辑运算符</p><p>​        能够进行多个条件的连接，这些条件之间构成一定的逻辑关系</p><blockquote><p>​        与    AND</p><p>​        或    OR</p><p>​        非    NOT</p></blockquote><p>特殊的比较运算符</p><p>​    基本空值判断</p><p>​        判断是NULL的情况：列名：列名(字段名) IS NULL;</p><p><img src="/images/image-20210102145040748.png" alt="image-20210102145040748"></p><h6 id="错误情况："><a href="#错误情况：" class="headerlink" title="错误情况："></a>错误情况：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名(字段名) = NULL;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20210102145055883.png" alt="image-20210102145055883"></p><p>​        判断不是NULL的情况：列名：列名(字段名) IS NOT NULL;</p><h4 id="BETWEEN……AND……"><a href="#BETWEEN……AND……" class="headerlink" title="BETWEEN……AND……"></a>BETWEEN……AND……</h4><p>在value1到value2之间(包含这两个值，即[value1,value2])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名(字段名) BETWEEN value1 AND value2;</span><br></pre></td></tr></table></figure><p>​            等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名(字段名) &gt;= value1 AND 列名(字段名) &lt;= value2;</span><br></pre></td></tr></table></figure><p>​        可以对日期进行比较</p><p><img src="/images/image-20210102145449359.png" alt="image-20210102145449359"></p><h4 id="模糊查询（LIKE）"><a href="#模糊查询（LIKE）" class="headerlink" title="模糊查询（LIKE）"></a>模糊查询（LIKE）</h4><p>​            关键字like</p><p>​            重要的符号（通配符）：</p><blockquote><p>​                ‘_’：代表一个字符</p><p>​                ‘%’：代表的是任意个字符（包含0个）</p></blockquote><p>​            如查询倒数第二个字为A的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名 LIKE &#x27;%A_&#x27;;</span><br></pre></td></tr></table></figure><p><code>注意：这两个字符可以重复使用</code></p><h4 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h4><p>数据中不等于value1或value2……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名 NOT IN (value1,value2……)</span><br></pre></td></tr></table></figure><p>数据中等于value1或value2……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名 IN (value1,value2……)</span><br></pre></td></tr></table></figure><p>数据为NULL时有问题（看子查询）</p><h3 id="分页查询（LIMIT）"><a href="#分页查询（LIMIT）" class="headerlink" title="分页查询（LIMIT）"></a>分页查询（LIMIT）</h3><p>显示查询结果的前number条数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">LIMIT number;</span><br></pre></td></tr></table></figure><p>显示前指定页数的数据，size1是页数，number2是一页中的数据条数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">LIMIT size1,number2;</span><br></pre></td></tr></table></figure><h3 id="子查询（SELECT嵌套）"><a href="#子查询（SELECT嵌套）" class="headerlink" title="子查询（SELECT嵌套）"></a>子查询（SELECT嵌套）</h3><p>​    子查询顾名思义一个查询（主查询，外部查询）中包含其他查询。</p><p>​    单行子查询（简单子查询）</p><blockquote><p>子查询需要使用( )括起来</p><p>单行子查询可以使用基本比较运算符</p><p>子查询是可以脱离外部查询独立执行</p><p>子查询的书写位置</p><p>​    1.SELECT子句（罕见）</p><p>​    2.FROM子句（可以用，注意别名）</p><p>这样写会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1248 - Every derived table must have its own alias</span><br></pre></td></tr></table></figure><p>错误原因 没有给子查询出来的表起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM (SELECT * FROM EMP WHERE DEPTNO=&#x27;20&#x27;)</span><br><span class="line">where sal&gt;1500;</span><br></pre></td></tr></table></figure><p>正确写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT temp.*</span><br><span class="line">FROM (SELECT * FROM EMP WHERE DEPTNO=&#x27;20&#x27;) temp</span><br><span class="line">where temp.sal&gt;1500;</span><br></pre></td></tr></table></figure><p>​    3.WHERE子句（常用）</p><p>​    4.HAVING子句</p></blockquote><p>​    多行子查询</p><blockquote><p>多行子查询不能使基本比较运算符</p><p>能使用</p><p>IN</p><p>NOT IN</p><p>​    注意事项：( )里如果有NULL，相当于=NULL，无结果(返回值)。</p><p>ALL：所有</p><p>ANY：任何一个</p><p>​    注意事项：使用ALL或ANY的效率比使用组函数，如MAX()和MIN()更高</p></blockquote><h3 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h3><p>我们需要的数据不可能都来自于一张表中</p><p>交叉连接（笛卡尔积）（CROSS JOIM）</p><blockquote><p>笛卡尔积：是指数学中两个集合的乘积</p><p>注意：多表查询的时候需要避免笛卡尔积（产生大量冗余数据）</p><p>避免方法：一定要写多表连接的连接条件</p><p>关键字：CROSS JOIM</p></blockquote><p>等值连接(必须会且熟练)(INNER JOIN……ON)</p><blockquote><p>使用不同表中的具有相同意义的字段(列)相等作为多表的连接条件</p><p>方式一：使用WHERE子句添加多表的连接条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1,表2……</span><br><span class="line">WHERE 表1.列名=表2.列名</span><br></pre></td></tr></table></figure><p>方式二(通用):使用INNER JOIN……ON(等价于 JOIN……ON)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">INNER JOIN 表2 ON (表1.列名=表2.列名);</span><br></pre></td></tr></table></figure><p>注意：1.可以使用表的别名，使用方式和列一样    </p><p>​            2.如果不同表中的字段名一致，使用的时候需要区分</p></blockquote><p>不等值连接</p><blockquote><p>等值连接以外的那部分数据</p></blockquote><p>外连接</p><blockquote><p>左外连接:主要显示的是左边表所有行的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">LEFT JOIN 表2 ON(表1.列名=表2.列名);</span><br></pre></td></tr></table></figure><p>右外连接:主要显示的是右边表所有行的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">RIGHT JOIN 表2 ON(表1.列名=表2.列名);</span><br></pre></td></tr></table></figure><p>全外连接(MYSQL不支持,但Oracle支持):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">FULL JOIN 表2 ON(表1.列名=表2.列名);</span><br></pre></td></tr></table></figure></blockquote><p>自连接</p><blockquote><p>自己连接自己(表中的A列和B列实际意义相同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.ENAME,e.EMPNO,m.ENAME,m.EMPNO</span><br><span class="line">FROM emp e,emp m</span><br><span class="line">WHERE e.MGR=m.EMPNO</span><br></pre></td></tr></table></figure></blockquote><h3 id="分组查询（GROUP-BY）"><a href="#分组查询（GROUP-BY）" class="headerlink" title="分组查询（GROUP BY）"></a>分组查询（GROUP BY）</h3><p>​    显然用于进行统计时5个常用函数</p><p>关键字group by（按照……分组）</p><p>子句：GROUP BY+按照分组的列名（字段名）</p><p>书写顺序：</p><p>SELECT—&gt;FROM—&gt;WHERE—&gt;GROUP BY—&gt;ORDER BY</p><blockquote><p>注意：</p><p>SELECT中可以有GROUP BY的对象</p><p>mysql（5.x版本）中执行顺序</p><p>FROM—&gt;WHERE—&gt;SELECT—&gt;GROUP BY—&gt;ORDER BY</p><p>即分组查询可以使用列别名（只限于目前）</p></blockquote><h4 id="分组条件-HAVING"><a href="#分组条件-HAVING" class="headerlink" title="分组条件(HAVING)"></a>分组条件(HAVING)</h4><p>​    关键字：HAVING</p><p>​    子句：HAVING + 分组条件</p><p>​    子句作用：添加分组条件（WHERE语句中不支持分组函数的分组条件）</p><p>​    书写顺序：SELECT—&gt;FROM—&gt;WHERE—&gt;GROUP BY—&gt;ORDER BY</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>​        函数：在计算机中通常称为方法、函数</p><blockquote><p>​        函数之间可以嵌套使用</p></blockquote><p>单行函数</p><p>​    处理NULL值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(value1, value2)</span><br></pre></td></tr></table></figure><blockquote><p>​    如果value1为NULL，则返回值为value2</p><p>​    如果value1不为NULL，则返回值为value1</p></blockquote><p>​    日期类型</p><blockquote><p>​        获取当前日期：CURDATE()</p><p>​        获取当前时间：CURTIME()</p><p>​        获取当前的日期+时间：NOW()</p><p><img src="/images/image-20210102162950812.png" alt="image-20210102162950812"></p></blockquote><p>​    数值类型</p><blockquote><p>​        四舍五入：ROUND()</p><p>​        向下取整：FLOOR()</p><p>​        向上取整：CEIL()</p><p><img src="/images/image-20210102162858473.png" alt="image-20210102162858473"></p><p>面试时注意负数</p><p><img src="/images/image-20210102163034641.png" alt="image-20210102163034641"></p></blockquote><p>​    字符串类型</p><blockquote><p>​    字符串拼接：CONCAT(string1，string2)–将string1与string2拼接</p><p>​    字符串长度：LENGTAH(string)</p><p>​    去除前后空格：TRIM(string)</p><p>​    转成大写字母：UPPER(string)</p><p>​    转成小写字母：LOWER(string)</p></blockquote><p>多行函数（分组函数）</p><blockquote><p>​    统计数据总条数：COUNT()</p><p>注意：COUNT()括号中为数字或*</p><p>面试题：</p><p>​    给你一个陌生的数据库，有一张陌生的表，第一件事你干啥？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）SELECT * FROM 表名</span><br><span class="line">（2）SELECT COUNT(*) FORM 表名</span><br></pre></td></tr></table></figure><p>​    选（2）由于这个表的数据量可能会很大，（2）查询数据量更快</p><p>​    统计平均数：AVG()</p><p>​    统计总和：SUM()</p><p>​    统计最大值：MAX()</p><p>​    统计最小值：MIN()</p></blockquote><h2 id="DDL操作"><a href="#DDL操作" class="headerlink" title="DDL操作"></a>DDL操作</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/2021/11/19/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/11/19/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言文件操作"><a href="#C语言文件操作" class="headerlink" title="C语言文件操作"></a>C语言文件操作</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p> <strong>fopen( )</strong> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fopen( const char * filename, const char * mode );</span><br></pre></td></tr></table></figure> <span id="more"></span><p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">打开一个已有的文本文件，允许读取文件。</td></tr><tr><td align="left">w</td><td align="left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td align="left">a</td><td align="left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文本文件，允许读写文件。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fclose( FILE *fp );</span><br></pre></td></tr></table></figure><p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装指定版本minio</title>
      <link href="/2021/11/19/docker%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACminio/"/>
      <url>/2021/11/19/docker%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACminio/</url>
      
        <content type="html"><![CDATA[<h1 id="docker安装指定版本minio"><a href="#docker安装指定版本minio" class="headerlink" title="docker安装指定版本minio"></a><a href="https://www.cnblogs.com/jiqing9006/p/15272722.html">docker安装指定版本minio</a></h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio:RELEASE.2020-12-03T00-03-10Z</span><br></pre></td></tr></table></figure> <span id="more"></span><h3 id="启动，也要加上指定版本"><a href="#启动，也要加上指定版本" class="headerlink" title="启动，也要加上指定版本"></a>启动，也要加上指定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 --name minio -d --restart=always -e &quot;MINIO_ACCESS_KEY=admin&quot; -e &quot;MINIO_SECRET_KEY=admin123&quot; -v /opt/data:/data -v /opt/config:/root/.minio minio/minio:RELEASE.2020-12-03T00-03-10Z server /data</span><br></pre></td></tr></table></figure><p>node上传文件方法</p><p>安装npm插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save minio</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Minio = require(&#x27;minio&#x27;)</span><br><span class="line">async index() &#123;</span><br><span class="line">const &#123; ctx &#125; = this;</span><br><span class="line">let file = ctx.request.files[0] // file包含了文件名，文件类型，大小，路径等信息，可以自己打印下看看</span><br><span class="line">//使用端点实例化minio客户端</span><br><span class="line">//和访问键，如下所示。</span><br><span class="line">    var minioClient = new Minio.Client(&#123;</span><br><span class="line">    endPoint: &#x27;101.200.87.232&#x27;,</span><br><span class="line">    port: 9000,</span><br><span class="line">    useSSL: false,</span><br><span class="line">    accessKey: &#x27;admin&#x27;,</span><br><span class="line">    secretKey: &#x27;admin123&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    var metaData = &#123;</span><br><span class="line">    &#x27;Content-Type&#x27;: &#x27;application/octet-stream&#x27;,</span><br><span class="line">    &#x27;X-Amz-Meta-Testing&#x27;: 1234,</span><br><span class="line">    &#x27;example&#x27;: 5678</span><br><span class="line">    &#125;</span><br><span class="line">    minioClient.fPutObject(&#x27;test&#x27;, file.filename, file.filepath, metaData, function (err, etag) &#123;</span><br><span class="line">    if (err) return console.log(err)</span><br><span class="line">    console.log(&#x27;File uploaded successfully.&#x27;)</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用egg操作minio，实现文件上传下载</title>
      <link href="/2021/11/19/%E4%BD%BF%E7%94%A8egg%E6%93%8D%E4%BD%9Cminio%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2021/11/19/%E4%BD%BF%E7%94%A8egg%E6%93%8D%E4%BD%9Cminio%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="使用egg操作minio，实现文件上传下载"><a href="#使用egg操作minio，实现文件上传下载" class="headerlink" title="使用egg操作minio，实现文件上传下载"></a>使用egg操作minio，实现文件上传下载</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Minio = require(&#x27;minio&#x27;);//引用npm Minio包</span><br><span class="line">const bucket = &quot;test&quot;//使用的桶（test是公有的）（browse是私有的）</span><br><span class="line">//其中公有的能使用文件地址直接下载，私有的需要通过自己的下载接口</span><br><span class="line">const minioClient = new Minio.Client(&#123;//minio的参数</span><br><span class="line">    endPoint: &#x27;101.200.87.232&#x27;,</span><br><span class="line">    port: 9000,</span><br><span class="line">    useSSL: false,</span><br><span class="line">    accessKey: &#x27;账号&#x27;,</span><br><span class="line">    secretKey: &#x27;密码&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const metaData = &#123;//上传中的数据格式，根据文件类型，可能会有变化</span><br><span class="line">    &#x27;Content-Type&#x27;: &#x27;application/octet-stream&#x27;,</span><br><span class="line">    &#x27;X-Amz-Meta-Testing&#x27;: 1234,</span><br><span class="line">    example: 5678,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h3><p>上传方式是POST请求，数据使用file</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">index</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; ctx &#125; = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> file = ctx.request.files[<span class="number">0</span>]; <span class="comment">// file包含了文件名，文件类型，大小，路径等信息，可以自己打印下看看</span></span><br><span class="line">            <span class="keyword">const</span> params = ctx.query; <span class="comment">// file包含了文件名，文件类型，大小，路径等信息，可以自己打印下看看，由于编码问题，使用postman上传的文件名中的中文会被转换成乱码。但使用elelmentUI则不会。</span></span><br><span class="line">            params.filename = params.filename || file.filename</span><br><span class="line">            <span class="keyword">let</span> errmsg = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            minioClient.fPutObject(bucket, params.filename, file.filepath, metaData, <span class="function"><span class="keyword">function</span> (<span class="params">err, etag</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    errmsg = err.message;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (errmsg != <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.error(errmsg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.success(<span class="string">&#x27;http://101.200.87.232:9000/test/&#x27;</span> + params.filename);</span><br><span class="line">            <span class="comment">//返回给前端一个url，由于我的test仓库是公有的，访问此url，能直接下载或展示文件。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.error(error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><p>把桶设置成公有的，在上传接口中返回的url就是下载链接</p><p>下面是私有情况下的下载方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">indexget</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// minioClient.fGetObject(&#x27;test&#x27;, &#x27;111.png&#x27;, &#x27;D:\\222.png&#x27;, function (err, etag) &#123;</span></span><br><span class="line">        <span class="comment">//     if (err) &#123;</span></span><br><span class="line">        <span class="comment">//         return console.log(err);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     console.log(&#x27;done&#x27;);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">//fGetObject：会把文件保存在本地</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> &#123; ctx &#125; = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> params = ctx.query;<span class="comment">//接受下载文件在minio中的文件名</span></span><br><span class="line">        <span class="keyword">const</span> kkk = <span class="keyword">await</span> minioClient.getObject(bucket, params.filename)</span><br><span class="line">        <span class="comment">//此方法是官方提供，会返回，文件相关数据。</span></span><br><span class="line">        <span class="comment">//由于官方的方法是异步的，不能通过阻塞线程的方式等待此方法调用完毕后，返回文件。必须使用await</span></span><br><span class="line">        ctx.attachment(params.filename);<span class="comment">//下载的文件名</span></span><br><span class="line">        ctx.set(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/octet-stream&#x27;</span>);</span><br><span class="line">        ctx.body = kkk</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="另外上传文件出现问题-413-Request-Entity-Too-Large"><a href="#另外上传文件出现问题-413-Request-Entity-Too-Large" class="headerlink" title="另外上传文件出现问题 413 Request Entity Too Large"></a>另外上传文件出现问题 413 Request Entity Too Large</h3><p>这个是由于Nginx默认的request body为1M</p><blockquote><p>解决方案<br>找到自己主机的nginx.conf配置文件，打开<br>在http{}中加入 client_max_body_size 10m;<br>然后重启nginx</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中判断数组中是否包含某元素的方法</title>
      <link href="/2021/11/19/js%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/11/19/js%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="js中判断数组中是否包含某元素的方法"><a href="#js中判断数组中是否包含某元素的方法" class="headerlink" title="js中判断数组中是否包含某元素的方法"></a><a href="https://www.cnblogs.com/yunshangwuyou/p/10539090.html">js中判断数组中是否包含某元素的方法</a></h1><h3 id="方法一：array-indexOf-item-start-："><a href="#方法一：array-indexOf-item-start-：" class="headerlink" title="方法一：array.indexOf(item,start)："></a><strong>方法一：array.indexOf(item,start)：</strong></h3><p><strong>元素在数组中的位置,如果没与搜索到则返回 -1。</strong><br> <span id="more"></span></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>item</td><td>必须。查找的元素。</td></tr><tr><td>start</td><td>可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</td></tr></tbody></table><p>实际用法：if(arr.indexOf(某元素) &gt; -1){//则包含该元素}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line"></span><br><span class="line">var a = fruits.indexOf(&quot;Apple&quot;); // 2//以上输出结果意味着 &quot;Apple&quot; 元素位于数组中的第 3 个位置。</span><br></pre></td></tr></table></figure><p>　var fruits=[“Banana”,”Orange”,”Apple”,”Mango”,”Banana”,”Orange”,”Apple”];</p><p>　var a = fruits.indexOf(“Apple”,4); //6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//以上输出结果意味在数组的第四个位置开始检索：</span><br></pre></td></tr></table></figure><p>　　注：string.indexOf()返回某个指定的字符串值在字符串中首次出现的位置。</p><p>1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定 fromindex 时）。如果找到一个 searchvalue，则返回 searchvalue 的第一次出现的位置。</p><p>\2. stringObject 中的字符位置是从 0 开始的。</p><p>\3. 查找字符串最后出现的位置，使用 lastIndexOf() 方法。</p><p><strong>JavaScript Array filter() 方法有类似的检索功能：</strong></p><p>　　filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><p>　　<strong>注意：</strong> filter() 不会对空数组进行检测。</p><p>　　<strong>注意：</strong> filter() 不会改变原始数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var ages = [32, 33, 16, 40];</span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age == 16;</span><br><span class="line">&#125;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    ages.filter(checkAdult);</span><br><span class="line">  console.log(ages.filter(checkAdult))</span><br><span class="line">&#125;</span><br><span class="line">myFunction()</span><br><span class="line"></span><br><span class="line">//[16]</span><br><span class="line"></span><br><span class="line">var ages = [32, 33, 16, 40];</span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age &lt;= 14;</span><br><span class="line">&#125;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    ages.filter(checkAdult);</span><br><span class="line">  console.log(ages.filter(checkAdult))</span><br><span class="line">&#125;</span><br><span class="line">myFunction()</span><br><span class="line">//[]</span><br></pre></td></tr></table></figure><h3 id="方法二：array-find"><a href="#方法二：array-find" class="headerlink" title="方法二：array.find()"></a><strong>方法二：array.find()</strong></h3><p>数组实例的find()用于找出第一个符合条件的数组元素。它的参数是一个回调函数，所有数组元素依次遍历该回调函数，直到找出第一个返回值为true的元素，然后返回该元素，否则返回undefined。</p><p>find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。</p><p>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回 <em>true</em> 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</li><li>如果没有符合条件的元素返回 undefined</li></ul><p><strong>注意:</strong> find() 对于空数组，函数是不会执行的。</p><p><strong>注意:</strong> find() 并没有改变数组的原始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line">return value &gt; 9;</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">// 10</span><br><span class="line"></span><br><span class="line">//实际用法：</span><br><span class="line"></span><br><span class="line">arr.find(function(value) &#123;</span><br><span class="line"></span><br><span class="line">if(value === 要查找的值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法三：array-findIndex"><a href="#方法三：array-findIndex" class="headerlink" title="方法三：array.findIndex()"></a><strong>方法三：array.findIndex()</strong></h3><p>array.findIndex()和array.find()十分类似，返回第一个符合条件的数组元素的位置，如果所有元素都不符合条件，则返回-1。<br>findIndex() 方法为数组中的每个元素都调用一次函数执行：</p><p>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 -1</p><p>注意: findIndex() 对于空数组，函数是不会执行的。<br>注意: findIndex() 并没有改变数组的原始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ages = [3, 10, 18, 20];</span><br><span class="line"> </span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age &gt;= 18;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    console.log(ages.findIndex(checkAdult)) ;</span><br><span class="line">&#125;</span><br><span class="line">myFunction()</span><br><span class="line"></span><br><span class="line">//2</span><br></pre></td></tr></table></figure><p>方法二和方法三，这两个方法都可以发现NaN，弥补了方法一IndexOf()的不足。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[NaN].2.dexOf(NaN) </span><br><span class="line">//-1</span><br><span class="line"></span><br><span class="line">[Na3..findIndex(y =&gt; Object.is(NaN, y))</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><h3 id="方法四：for-循环"><a href="#方法四：for-循环" class="headerlink" title="方法四：for()循环"></a><strong>方法四：for()循环</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">遍历数组，然后 if 判断</span><br><span class="line"></span><br><span class="line">var arr = [1, 5, 10, 15];</span><br><span class="line"></span><br><span class="line">//传统for</span><br><span class="line"></span><br><span class="line">for(let i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">if(arr[i] === 查找值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// for...of</span><br><span class="line"></span><br><span class="line">for(v of arr) &#123;</span><br><span class="line"></span><br><span class="line">if(v === 查找值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//forEach</span><br><span class="line"></span><br><span class="line">arr.forEach(v=&gt;&#123;</span><br><span class="line"></span><br><span class="line">if(v === 查找值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法五：就是使用jquery的inArray方法"><a href="#方法五：就是使用jquery的inArray方法" class="headerlink" title="方法五：就是使用jquery的inArray方法"></a><strong>方法五：就是使用jquery的inArray方法</strong></h3><p><strong>该方法返回元素在数组中的下标，如果不存在与数组中，那么返回－１，代码如下所示：</strong></p><p>/**<br>* 使用jquery的inArray方法判断元素是否存在于数组中<br>* @param {Object} arr 数组<br>* @param {Object} value 元素值<br>*/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function isInArray2(arr,value)&#123;</span><br><span class="line">var index = $.inArray(value,arr);</span><br><span class="line">if(index &gt;= 0)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法六、include-方法："><a href="#方法六、include-方法：" class="headerlink" title="方法六、include()方法："></a><strong>方法六、include()方法：</strong></h3><p>arr.includes(searchElement)方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。searchElement:必须。需要查找的元素值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let site = [&#x27;runoob&#x27;, &#x27;google&#x27;, &#x27;taobao&#x27;];</span><br><span class="line"> </span><br><span class="line">site.includes(&#x27;runoob&#x27;); </span><br><span class="line">// true </span><br><span class="line"> </span><br><span class="line">site.includes(&#x27;baidu&#x27;); </span><br><span class="line">// false</span><br></pre></td></tr></table></figure><table><thead><tr><th>例子</th><th>结果</th></tr></thead><tbody><tr><td>[1, 2, 3].includes(2);</td><td>//true</td></tr><tr><td>[1, 2, 3].includes(4);</td><td>// false</td></tr><tr><td>[1, 2, 3].includes(3, 3);</td><td>// false</td></tr><tr><td>[1, 2, 3].includes(3, -1);</td><td>//true</td></tr><tr><td>[1, 2, NaN].includes(NaN);</td><td>//true</td></tr></tbody></table><p>arr.includes(searchElement, fromIndex).fromIndex:可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">注意：如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索 </span><br><span class="line">arr.includes(&#x27;c&#x27;, 3);   //false</span><br><span class="line">arr.includes(&#x27;c&#x27;, 100); // false</span><br><span class="line"></span><br><span class="line">注意：如果 fromIndex 为负值，计算出的索引将作为开始搜索searchElement的位置。如果计算出的索引小于 0，则整个数组都会被搜索。</span><br><span class="line">// 数组长度是3</span><br><span class="line">// fromIndex 是 -100</span><br><span class="line">// computed index 是 3 + (-100) = -97</span><br><span class="line">arr.includes(&#x27;a&#x27;, -100); // true</span><br><span class="line">arr.includes(&#x27;b&#x27;, -100); // true</span><br><span class="line">arr.includes(&#x27;c&#x27;, -100); // true</span><br></pre></td></tr></table></figure><h3 id="方法七-Array-some-方法，类似于filter"><a href="#方法七-Array-some-方法，类似于filter" class="headerlink" title="方法七.Array some() 方法，类似于filter()"></a><strong>方法七.Array some() 方法，类似于filter()</strong></h3><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p><p>some() 方法会依次执行数组的每个元素：</p><p>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。<br>如果没有满足条件的元素，则返回false。<br>注意： some() 不会对空数组进行检测。</p><p>注意： some() 不会改变原始数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ages = [3, 10, 18, 20];</span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age == 18;</span><br><span class="line">&#125;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    console.log(ages.some(checkAdult));</span><br><span class="line">&#125;</span><br><span class="line">myFunction() </span><br><span class="line"></span><br><span class="line">//true</span><br></pre></td></tr></table></figure><h3 id="方法八、Jquery的-each"><a href="#方法八、Jquery的-each" class="headerlink" title="方法八、Jquery的$.each()"></a>方法八、Jquery的$.each()</h3><p><strong>each() 方法为每个匹配元素规定要运行的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var anArray = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];</span><br><span class="line">      $.each(anArray,function(n,value)&#123;</span><br><span class="line">          if(value==&quot;one&quot;)&#123;</span><br><span class="line">           console.log(&quot;one存在于数组中&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>//one存在于数组中</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq RPC模式实例</title>
      <link href="/2021/11/19/rabbitmq%20RPC%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
      <url>/2021/11/19/rabbitmq%20RPC%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="rabbitmq-RPC模式实例"><a href="#rabbitmq-RPC模式实例" class="headerlink" title="rabbitmq RPC模式实例"></a>rabbitmq RPC模式实例</h1><p>rabbitmq RPC模式实例</p><p>（由生产者发送斐波那契数列的个数，消费者回复对应个数的斐波那契数列的数字）</p> <span id="more"></span><p>server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err error, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法连接到RabbitMQ&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">        ch, err := conn.Channel()</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法打开频道&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">        q, err := ch.QueueDeclare(</span><br><span class="line">                <span class="string">&quot;rpc_queue&quot;</span>, <span class="comment">// name</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// durable</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// delete when unused</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,         <span class="comment">// arguments</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能声明队列&quot;</span>)</span><br><span class="line"></span><br><span class="line">        err = ch.Qos(</span><br><span class="line">                <span class="number">1</span>,     <span class="comment">// prefetch count</span></span><br><span class="line">                <span class="number">0</span>,     <span class="comment">// prefetch size</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// global</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法设置QoS&quot;</span>)</span><br><span class="line"></span><br><span class="line">        msgs, err := ch.Consume(</span><br><span class="line">                q.Name, <span class="comment">// queue</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// auto-ack</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能注册消费者&quot;</span>)</span><br><span class="line"></span><br><span class="line">        forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">                        n, err := strconv.Atoi(<span class="keyword">string</span>(d.Body))</span><br><span class="line">                        failOnError(err, <span class="string">&quot;Failed to convert body to integer&quot;</span>)</span><br><span class="line"></span><br><span class="line">                        log.Printf(<span class="string">&quot; [.] fib(%d)&quot;</span>, n)</span><br><span class="line">                        response := fib(n)</span><br><span class="line"></span><br><span class="line">                        err = ch.Publish(</span><br><span class="line">                                <span class="string">&quot;&quot;</span>,        <span class="comment">// exchange</span></span><br><span class="line">                                d.ReplyTo, <span class="comment">// routing key</span></span><br><span class="line">                                <span class="literal">false</span>,     <span class="comment">// mandatory</span></span><br><span class="line">                                <span class="literal">false</span>,     <span class="comment">// immediate</span></span><br><span class="line">                                amqp.Publishing&#123;</span><br><span class="line">                                        ContentType:   <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">                                        CorrelationId: d.CorrelationId,</span><br><span class="line">                                        Body:          []<span class="keyword">byte</span>(strconv.Itoa(response)),</span><br><span class="line">                                &#125;)</span><br><span class="line">                        failOnError(err, <span class="string">&quot;未能发布消息&quot;</span>)</span><br><span class="line"></span><br><span class="line">                        d.Ack(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot; [*] 正在等待RPC请求&quot;</span>)</span><br><span class="line">        &lt;-forever</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">        <span class="string">&quot;os&quot;</span></span><br><span class="line">        <span class="string">&quot;strconv&quot;</span></span><br><span class="line">        <span class="string">&quot;strings&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err error, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomString</span><span class="params">(l <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">                bytes[i] = <span class="keyword">byte</span>(randInt(<span class="number">65</span>, <span class="number">90</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">string</span>(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randInt</span><span class="params">(min <span class="keyword">int</span>, max <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min + rand.Intn(max-min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacciRPC</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">        conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法连接到RabbitMQ&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">        ch, err := conn.Channel()</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法打开通道&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">        q, err := ch.QueueDeclare(</span><br><span class="line">                <span class="string">&quot;&quot;</span>,    <span class="comment">// name</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// durable</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// delete when unused</span></span><br><span class="line">                <span class="literal">true</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// noWait</span></span><br><span class="line">                <span class="literal">nil</span>,   <span class="comment">// arguments</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能声明队列&quot;</span>)</span><br><span class="line"></span><br><span class="line">        msgs, err := ch.Consume(</span><br><span class="line">                q.Name, <span class="comment">// queue</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// auto-ack</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能注册消费者&quot;</span>)</span><br><span class="line"></span><br><span class="line">        corrId := randomString(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">        err = ch.Publish(</span><br><span class="line">                <span class="string">&quot;&quot;</span>,          <span class="comment">// exchange</span></span><br><span class="line">                <span class="string">&quot;rpc_queue&quot;</span>, <span class="comment">// routing key</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// mandatory</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// immediate</span></span><br><span class="line">                amqp.Publishing&#123;</span><br><span class="line">                        ContentType:   <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">                        CorrelationId: corrId,</span><br><span class="line">                        ReplyTo:       q.Name,</span><br><span class="line">                        Body:          []<span class="keyword">byte</span>(strconv.Itoa(n)),</span><br><span class="line">                &#125;)</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能发布消息&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">                <span class="keyword">if</span> corrId == d.CorrelationId &#123;</span><br><span class="line">                        res, err = strconv.Atoi(<span class="keyword">string</span>(d.Body))</span><br><span class="line">                        failOnError(err, <span class="string">&quot;无法将正文转换为整数&quot;</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">        n := bodyFrom(os.Args)</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot; [x] Requesting fib(%d)&quot;</span>, n)</span><br><span class="line">        res, err := fibonacciRPC(n)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法处理RPC请求&quot;</span>)</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot; [.] Got %d&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bodyFrom</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(args) &lt; <span class="number">2</span>) || os.Args[<span class="number">1</span>] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                s = <span class="string">&quot;30&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s = strings.Join(args[<span class="number">1</span>:], <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        n, err := strconv.Atoi(s)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法将arg转换为整数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>egg npm安装列表</title>
      <link href="/2021/11/19/egg%20npm%E5%AE%89%E8%A3%85%E5%88%97%E8%A1%A8/"/>
      <url>/2021/11/19/egg%20npm%E5%AE%89%E8%A3%85%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="egg-npm安装列表"><a href="#egg-npm安装列表" class="headerlink" title="egg npm安装列表"></a>egg npm安装列表</h1><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mongoose</span><br></pre></td></tr></table></figure> <span id="more"></span><p>plugin.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mongoose: &#123;</span><br><span class="line">    enable: true,</span><br><span class="line">    package: &#x27;egg-mongoose&#x27;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>config.default.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//mongodb配置</span><br><span class="line">  config.mongoose = &#123;</span><br><span class="line">    url:</span><br><span class="line">      &quot;mongodb://127.0.0.1:27017/attendance&quot;,</span><br><span class="line">    options: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i egg-cors --save</span><br></pre></td></tr></table></figure><h1 id="csprng"><a href="#csprng" class="headerlink" title="csprng"></a>csprng</h1><p>生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install csprng</span><br></pre></td></tr></table></figure><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><p>实现md5加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i crypto --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/18/hello-world/"/>
      <url>/2021/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br> <span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
