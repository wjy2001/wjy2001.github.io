<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>github绑定自己的域名</title>
      <link href="/2021/12/01/github%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/"/>
      <url>/2021/12/01/github%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="github绑定自己的域名"><a href="#github绑定自己的域名" class="headerlink" title="github绑定自己的域名"></a>github绑定自己的域名</h1><h3 id="1-在项目里新建文件CNAME"><a href="#1-在项目里新建文件CNAME" class="headerlink" title="1.在项目里新建文件CNAME"></a>1.在项目里新建文件CNAME</h3><p><img src="D:\WorkSpace\github\hexo\themes\next\source\images\image-20211201143231682.png" alt="image-20211201143231682"></p><p>里面写要绑定的域名</p><p>使用代码上传</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure> <span id="more"></span><h3 id="2-在github项目里面设置"><a href="#2-在github项目里面设置" class="headerlink" title="2.在github项目里面设置"></a>2.在github项目里面设置</h3><p><img src="D:\WorkSpace\github\hexo\themes\next\source\images\image-20211201143437940.png" alt="image-20211201143437940"></p><p><img src="D:\WorkSpace\github\hexo\themes\next\source\images\image-20211201143454351.png" alt="image-20211201143454351"></p><p><img src="D:\WorkSpace\github\hexo\themes\next\source\images\image-20211201143505650.png" alt="image-20211201143505650"></p><h2 id="3-添加域名解析"><a href="#3-添加域名解析" class="headerlink" title="3 添加域名解析"></a>3 添加域名解析</h2><p>ping你的<a href="https://link.zhihu.com/?target=http://github.io">http://github.io</a>域名，得到一个IP；</p><p><img src="D:\WorkSpace\github\hexo\themes\next\source\images\image-20211201143654499.png" alt="image-20211201143654499"></p><blockquote><p>ping 后面的-4是为了ipv4 的格式</p></blockquote><p><strong>向你的 DNS 配置中添加 2 条记录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@          A             185.199.108.153（ping出来的）</span><br><span class="line">www      CNAME           username.github.io.</span><br></pre></td></tr></table></figure><p><img src="D:\WorkSpace\github\hexo\themes\next\source\images\image-20211201143818395.png" alt="image-20211201143818395"></p><p><strong>4. 启用 HTTPS</strong></p><p>自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了。</p><p>配置也相当简单，只需要更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。</p><ul><li>185.199.108.153（不知道为何和我ping出来的地址一样）</li><li>185.199.109.153</li><li>185.199.110.153</li><li>185.199.111.153</li></ul>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>结构体的理解</title>
      <link href="/2021/12/01/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/12/01/%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体的理解"><a href="#结构体的理解" class="headerlink" title="结构体的理解"></a>结构体的理解</h1><p>Go语言中没有“类”的概念，也不支持“类”的继承等面向对象的概念。Go语言中通过结构体的内嵌再配合接口比面向对象具有更高的扩展性和灵活性。</p><h2 id="1-1-类型别名和自定义类型"><a href="#1-1-类型别名和自定义类型" class="headerlink" title="1.1. 类型别名和自定义类型"></a>1.1. 类型别名和自定义类型</h2><h3 id="1-1-1-自定义类型"><a href="#1-1-1-自定义类型" class="headerlink" title="1.1.1. 自定义类型"></a>1.1.1. 自定义类型</h3><p>在Go语言中有一些基本的数据类型，如string、整型、浮点型、布尔等数据类型，Go语言中可以使用type关键字来定义自定义类型。</p><p>自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//将MyInt定义为int类型</span><br><span class="line">type MyInt int</span><br></pre></td></tr></table></figure> <span id="more"></span><p>通过Type关键字的定义，MyInt就是一种新的类型，它具有int的特性。</p><h3 id="1-1-2-类型别名"><a href="#1-1-2-类型别名" class="headerlink" title="1.1.2. 类型别名"></a>1.1.2. 类型别名</h3><p>类型别名是Go1.9版本添加的新功能。</p><p>类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type TypeAlias = Type</span><br></pre></td></tr></table></figure><p>我们之前见过的rune和byte就是类型别名，他们的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type byte = uint8</span><br><span class="line">type rune = int32</span><br></pre></td></tr></table></figure><h3 id="1-1-3-类型定义和类型别名的区别"><a href="#1-1-3-类型定义和类型别名的区别" class="headerlink" title="1.1.3. 类型定义和类型别名的区别"></a>1.1.3. 类型定义和类型别名的区别</h3><p>类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">type</span> NewInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> MyInt = <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a NewInt</span><br><span class="line">    <span class="keyword">var</span> b MyInt</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a:%T\n&quot;</span>, a) <span class="comment">//type of a:main.NewInt</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of b:%T\n&quot;</span>, b) <span class="comment">//type of b:int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果显示a的类型是main.NewInt，表示main包下定义的NewInt类型。b的类型是int。MyInt类型只会在代码中存在，编译完成时并不会有MyInt类型。</p><h2 id="1-2-结构体"><a href="#1-2-结构体" class="headerlink" title="1.2. 结构体"></a>1.2. 结构体</h2><p>Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称struct。 也就是我们可以通过struct来定义自己的类型了。</p><p>Go语言中通过struct来实现面向对象。</p><h3 id="1-2-1-结构体的定义"><a href="#1-2-1-结构体的定义" class="headerlink" title="1.2.1. 结构体的定义"></a>1.2.1. 结构体的定义</h3><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type 类型名 struct &#123;</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    字段名 字段类型</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.类型名：标识自定义结构体的名称，在同一个包内不能重复。</span><br><span class="line">2.字段名：表示结构体字段名。结构体中的字段名必须唯一。</span><br><span class="line">3.字段类型：表示结构体字段的具体类型。</span><br></pre></td></tr></table></figure><p>举个例子，我们定义一个Person（人）结构体，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type person struct &#123;</span><br><span class="line">    name string</span><br><span class="line">    city string</span><br><span class="line">    age  int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样类型的字段也可以写在一行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type person1 struct &#123;</span><br><span class="line">    name, city string</span><br><span class="line">    age        int8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就拥有了一个person的自定义类型，它有name、city、age三个字段，分别表示姓名、城市和年龄。这样我们使用这个person结构体就能够很方便的在程序中表示和存储人信息了。</p><p>语言内置的基础数据类型是用来描述一个值的，而结构体是用来描述一组值的。比如一个人有名字、年龄和居住城市等，本质上是一种聚合型的数据类型</p><h3 id="1-2-2-结构体实例化"><a href="#1-2-2-结构体实例化" class="headerlink" title="1.2.2. 结构体实例化"></a>1.2.2. 结构体实例化</h3><p>只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。</p><p>结构体本身也是一种类型，我们可以像声明内置类型一样使用var关键字声明结构体类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 结构体实例 结构体类型</span><br></pre></td></tr></table></figure><h3 id="1-2-3-基本实例化"><a href="#1-2-3-基本实例化" class="headerlink" title="1.2.3. 基本实例化"></a>1.2.3. 基本实例化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p1 person</span><br><span class="line">    p1.name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    p1.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">    p1.age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%v\n&quot;</span>, p1)  <span class="comment">//p1=&#123;pprof.cn 北京 18&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;p1=%#v\n&quot;</span>, p1) <span class="comment">//p1=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过.来访问结构体的字段（成员变量）,例如p1.name和p1.age等。</p><h2 id="1-3-匿名结构体"><a href="#1-3-匿名结构体" class="headerlink" title="1.3. 匿名结构体"></a>1.3. 匿名结构体</h2><p>在定义一些临时数据结构等场景下还可以使用匿名结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user <span class="keyword">struct</span>&#123;Name <span class="keyword">string</span>; Age <span class="keyword">int</span>&#125;</span><br><span class="line">    user.Name = <span class="string">&quot;pprof.cn&quot;</span></span><br><span class="line">    user.Age = <span class="number">18</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-1-创建指针类型结构体"><a href="#1-3-1-创建指针类型结构体" class="headerlink" title="1.3.1. 创建指针类型结构体"></a>1.3.1. 创建指针类型结构体</h3><p>我们还可以通过使用new关键字对结构体进行实例化，得到的是结构体的地址。 格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p2 = new(person)</span><br><span class="line">fmt.Printf(&quot;%T\n&quot;, p2)     //*main.person</span><br><span class="line">fmt.Printf(&quot;p2=%#v\n&quot;, p2) //p2=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span><br></pre></td></tr></table></figure><p>从打印的结果中我们可以看出p2是一个结构体指针。</p><p>需要注意的是在Go语言中支持对结构体指针直接使用.来访问结构体的成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">new</span>(person)</span><br><span class="line">p2.name = <span class="string">&quot;测试&quot;</span></span><br><span class="line">p2.age = <span class="number">18</span></span><br><span class="line">p2.city = <span class="string">&quot;北京&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2=%#v\n&quot;</span>, p2) <span class="comment">//p2=&amp;main.person&#123;name:&quot;测试&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-取结构体的地址实例化"><a href="#1-3-2-取结构体的地址实例化" class="headerlink" title="1.3.2. 取结构体的地址实例化"></a>1.3.2. 取结构体的地址实例化</h3><p>使用&amp;对结构体进行取地址操作相当于对该结构体类型进行了一次new实例化操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p3 := &amp;person&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, p3)     <span class="comment">//*main.person</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">p3.name = <span class="string">&quot;博客&quot;</span></span><br><span class="line">p3.age = <span class="number">30</span></span><br><span class="line">p3.city = <span class="string">&quot;成都&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p3=%#v\n&quot;</span>, p3) <span class="comment">//p3=&amp;main.person&#123;name:&quot;博客&quot;, city:&quot;成都&quot;, age:30&#125;</span></span><br></pre></td></tr></table></figure><p>p3.name = “博客”其实在底层是(*p3).name = “博客”，这是Go语言帮我们实现的语法糖。</p><h3 id="1-3-3-结构体初始化"><a href="#1-3-3-结构体初始化" class="headerlink" title="1.3.3. 结构体初始化"></a>1.3.3. 结构体初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    city <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p4 person</span><br><span class="line">    fmt.Printf(<span class="string">&quot;p4=%#v\n&quot;</span>, p4) <span class="comment">//p4=main.person&#123;name:&quot;&quot;, city:&quot;&quot;, age:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-4-使用键值对初始化"><a href="#1-3-4-使用键值对初始化" class="headerlink" title="1.3.4. 使用键值对初始化"></a>1.3.4. 使用键值对初始化</h3><p>使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p5 := person&#123;</span><br><span class="line">    name: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p5=%#v\n&quot;</span>, p5) <span class="comment">//p5=main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>也可以对结构体指针进行键值对初始化，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p6 := &amp;person&#123;</span><br><span class="line">    name: <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    age:  <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p6=%#v\n&quot;</span>, p6) <span class="comment">//p6=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>当某些字段没有初始值的时候，该字段可以不写。此时，没有指定初始值的字段的值就是该字段类型的零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p7 := &amp;person&#123;</span><br><span class="line">    city: <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p7=%#v\n&quot;</span>, p7) <span class="comment">//p7=&amp;main.person&#123;name:&quot;&quot;, city:&quot;北京&quot;, age:0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-5-使用值的列表初始化"><a href="#1-3-5-使用值的列表初始化" class="headerlink" title="1.3.5. 使用值的列表初始化"></a>1.3.5. 使用值的列表初始化</h3><p>初始化结构体的时候可以简写，也就是初始化的时候不写键，直接写值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p8 := &amp;person&#123;</span><br><span class="line">    <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;p8=%#v\n&quot;</span>, p8) <span class="comment">//p8=&amp;main.person&#123;name:&quot;pprof.cn&quot;, city:&quot;北京&quot;, age:18&#125;</span></span><br></pre></td></tr></table></figure><p>使用这种格式初始化时，需要注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.必须初始化结构体的所有字段。</span><br><span class="line">2.初始值的填充顺序必须与字段在结构体中的声明顺序一致。</span><br><span class="line">3.该方式不能和键值初始化方式混用。</span><br></pre></td></tr></table></figure><h3 id="1-3-6-结构体内存布局"><a href="#1-3-6-结构体内存布局" class="headerlink" title="1.3.6. 结构体内存布局"></a>1.3.6. 结构体内存布局</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">int8</span></span><br><span class="line">    b <span class="keyword">int8</span></span><br><span class="line">    c <span class="keyword">int8</span></span><br><span class="line">    d <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line">n := test&#123;</span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.a %p\n&quot;</span>, &amp;n.a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.b %p\n&quot;</span>, &amp;n.b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.c %p\n&quot;</span>, &amp;n.c)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n.d %p\n&quot;</span>, &amp;n.d)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n.a 0xc0000a0060</span><br><span class="line">n.b 0xc0000a0061</span><br><span class="line">n.c 0xc0000a0062</span><br><span class="line">n.d 0xc0000a0063</span><br></pre></td></tr></table></figure><h3 id="1-3-7-面试题"><a href="#1-3-7-面试题" class="headerlink" title="1.3.7. 面试题"></a>1.3.7. 面试题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*student)</span><br><span class="line">    stus := []student&#123;</span><br><span class="line">        &#123;name: <span class="string">&quot;pprof.cn&quot;</span>, age: <span class="number">18</span>&#125;,</span><br><span class="line">        &#123;name: <span class="string">&quot;测试&quot;</span>, age: <span class="number">23</span>&#125;,</span><br><span class="line">        &#123;name: <span class="string">&quot;博客&quot;</span>, age: <span class="number">28</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, stu := <span class="keyword">range</span> stus &#123;</span><br><span class="line">        m[stu.name] = &amp;stu</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, <span class="string">&quot;=&gt;&quot;</span>, v.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-8-构造函数"><a href="#1-3-8-构造函数" class="headerlink" title="1.3.8. 构造函数"></a>1.3.8. 构造函数</h3><p>Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个person的构造函数。 因为struct是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPerson</span><span class="params">(name, city <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        city: city,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p9 := newPerson(<span class="string">&quot;pprof.cn&quot;</span>, <span class="string">&quot;测试&quot;</span>, <span class="number">90</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p9)</span><br></pre></td></tr></table></figure><h3 id="1-3-9-方法和接收者"><a href="#1-3-9-方法和接收者" class="headerlink" title="1.3.9. 方法和接收者"></a>1.3.9. 方法和接收者</h3><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this或者 self。</p><p>方法的定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名的第一个小写字母，而不是self、this之类的命名。例如，Person类型的接收者变量应该命名为 p，Connector类型的接收者变量应该命名为c等。</span><br><span class="line">2.接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</span><br><span class="line">3.方法名、参数列表、返回参数：具体格式与函数定义相同。</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NewPerson 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int8</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dream Person做梦的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Dream</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s的梦想是学好Go语言！\n&quot;</span>, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法与函数的区别是，函数不属于任何类型，方法属于特定的类型。</p><h3 id="1-3-10-指针类型的接收者"><a href="#1-3-10-指针类型的接收者" class="headerlink" title="1.3.10. 指针类型的接收者"></a>1.3.10. 指针类型的接收者</h3><p>指针类型的接收者由一个结构体的指针组成，由于指针的特性，调用方法时修改接收者指针的任意成员变量，在方法结束后，修改都是有效的。这种方式就十分接近于其他语言中面向对象中的this或者self。 例如我们为Person添加一个SetAge方法，来修改实例变量的年龄。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SetAge 设置p的年龄</span><br><span class="line">// 使用指针接收者</span><br><span class="line">func (p *Person) SetAge(newAge int8) &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1.SetAge(<span class="number">30</span>)</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-11-值类型的接收者"><a href="#1-3-11-值类型的接收者" class="headerlink" title="1.3.11. 值类型的接收者"></a>1.3.11. 值类型的接收者</h3><p>当方法作用于值类型接收者时，Go语言会在代码运行时将接收者的值复制一份。在值类型接收者的方法中可以获取接收者的成员值，但修改操作只是针对副本，无法修改接收者变量本身。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SetAge2 设置p的年龄</span></span><br><span class="line"><span class="comment">// 使用值接收者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">SetAge2</span><span class="params">(newAge <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line">    p.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := NewPerson(<span class="string">&quot;测试&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    p1.Dream()</span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">    p1.SetAge2(<span class="number">30</span>) <span class="comment">// (*p1).SetAge2(30)</span></span><br><span class="line">    fmt.Println(p1.age) <span class="comment">// 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-12-什么时候应该使用指针类型接收者"><a href="#1-3-12-什么时候应该使用指针类型接收者" class="headerlink" title="1.3.12. 什么时候应该使用指针类型接收者"></a>1.3.12. 什么时候应该使用指针类型接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.需要修改接收者中的值</span><br><span class="line">2.接收者是拷贝代价比较大的大对象</span><br><span class="line">3.保证一致性，如果有某个方法使用了指针接收者，那么其他的方法也应该使用指针接收者。</span><br></pre></td></tr></table></figure><h3 id="1-3-13-任意类型添加方法"><a href="#1-3-13-任意类型添加方法" class="headerlink" title="1.3.13. 任意类型添加方法"></a>1.3.13. 任意类型添加方法</h3><p>在Go语言中，接收者的类型可以是任何类型，不仅仅是结构体，任何类型都可以拥有方法。 举个例子，我们基于内置的int类型使用type关键字可以定义新的自定义类型，然后为我们的自定义类型添加方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyInt 将int定义为自定义MyInt类型</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SayHello 为MyInt添加一个SayHello的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyInt)</span> <span class="title">SayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, 我是一个int。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m1 MyInt</span><br><span class="line">    m1.SayHello() <span class="comment">//Hello, 我是一个int。</span></span><br><span class="line">    m1 = <span class="number">100</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v  %T\n&quot;</span>, m1, m1) <span class="comment">//100  main.MyInt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项： 非本地类型不能定义方法，也就是说我们不能给别的包的类型定义方法。</p><h3 id="1-3-14-结构体的匿名字段"><a href="#1-3-14-结构体的匿名字段" class="headerlink" title="1.3.14. 结构体的匿名字段"></a>1.3.14. 结构体的匿名字段</h3><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p1 := Person&#123;</span><br><span class="line">        <span class="string">&quot;pprof.cn&quot;</span>,</span><br><span class="line">        <span class="number">18</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, p1)        <span class="comment">//main.Person&#123;string:&quot;pprof.cn&quot;, int:18&#125;</span></span><br><span class="line">    fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//pprof.cn 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h3 id="1-3-15-嵌套结构体"><a href="#1-3-15-嵌套结构体" class="headerlink" title="1.3.15. 嵌套结构体"></a>1.3.15. 嵌套结构体</h3><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    user1 := User&#123;</span><br><span class="line">        Name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        Address: Address&#123;</span><br><span class="line">            Province: <span class="string">&quot;黑龙江&quot;</span>,</span><br><span class="line">            City:     <span class="string">&quot;哈尔滨&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;user1=%#v\n&quot;</span>, user1)<span class="comment">//user1=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-16-嵌套匿名结构体"><a href="#1-3-16-嵌套匿名结构体" class="headerlink" title="1.3.16. 嵌套匿名结构体"></a>1.3.16. 嵌套匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province <span class="keyword">string</span></span><br><span class="line">    City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Gender  <span class="keyword">string</span></span><br><span class="line">    Address <span class="comment">//匿名结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user2 User</span><br><span class="line">    user2.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user2.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    user2.Address.Province = <span class="string">&quot;黑龙江&quot;</span>    <span class="comment">//通过匿名结构体.字段名访问</span></span><br><span class="line">    user2.City = <span class="string">&quot;哈尔滨&quot;</span>                <span class="comment">//直接访问匿名结构体的字段名</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;user2=%#v\n&quot;</span>, user2) <span class="comment">//user2=main.User&#123;Name:&quot;pprof&quot;, Gender:&quot;女&quot;, Address:main.Address&#123;Province:&quot;黑龙江&quot;, City:&quot;哈尔滨&quot;&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。</p><h3 id="1-3-17-嵌套结构体的字段名冲突"><a href="#1-3-17-嵌套结构体的字段名冲突" class="headerlink" title="1.3.17. 嵌套结构体的字段名冲突"></a>1.3.17. 嵌套结构体的字段名冲突</h3><p>嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Province   <span class="keyword">string</span></span><br><span class="line">    City       <span class="keyword">string</span></span><br><span class="line">    CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Email 邮箱结构体</span></span><br><span class="line"><span class="keyword">type</span> Email <span class="keyword">struct</span> &#123;</span><br><span class="line">    Account    <span class="keyword">string</span></span><br><span class="line">    CreateTime <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">    Gender <span class="keyword">string</span></span><br><span class="line">    Address</span><br><span class="line">    Email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user3 User</span><br><span class="line">    user3.Name = <span class="string">&quot;pprof&quot;</span></span><br><span class="line">    user3.Gender = <span class="string">&quot;女&quot;</span></span><br><span class="line">    <span class="comment">// user3.CreateTime = &quot;2019&quot; //ambiguous selector user3.CreateTime</span></span><br><span class="line">    user3.Address.CreateTime = <span class="string">&quot;2000&quot;</span> <span class="comment">//指定Address结构体中的CreateTime</span></span><br><span class="line">    user3.Email.CreateTime = <span class="string">&quot;2000&quot;</span>   <span class="comment">//指定Email结构体中的CreateTime</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-18-结构体的“继承”"><a href="#1-3-18-结构体的“继承”" class="headerlink" title="1.3.18. 结构体的“继承”"></a>1.3.18. 结构体的“继承”</h3><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会动！\n&quot;</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Feet    <span class="keyword">int8</span></span><br><span class="line">    *Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    d1 := &amp;Dog&#123;</span><br><span class="line">        Feet: <span class="number">4</span>,</span><br><span class="line">        Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">            name: <span class="string">&quot;乐乐&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">    d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-19-结构体字段的可见性"><a href="#1-3-19-结构体字段的可见性" class="headerlink" title="1.3.19. 结构体字段的可见性"></a>1.3.19. 结构体字段的可见性</h3><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h3 id="1-3-20-结构体与JSON序列化"><a href="#1-3-20-结构体与JSON序列化" class="headerlink" title="1.3.20. 结构体与JSON序列化"></a>1.3.20. 结构体与JSON序列化</h3><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号””包裹，使用冒号:分隔，然后紧接着值；多个键值之间使用英文,分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span></span><br><span class="line">    Gender <span class="keyword">string</span></span><br><span class="line">    Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title    <span class="keyword">string</span></span><br><span class="line">    Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := &amp;Class&#123;</span><br><span class="line">        Title:    <span class="string">&quot;101&quot;</span>,</span><br><span class="line">        Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        stu := &amp;Student&#123;</span><br><span class="line">            Name:   fmt.Sprintf(<span class="string">&quot;stu%02d&quot;</span>, i),</span><br><span class="line">            Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">            ID:     i,</span><br><span class="line">        &#125;</span><br><span class="line">        c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">    data, err := json.Marshal(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json:%s\n&quot;</span>, data)</span><br><span class="line">    <span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">    str := <span class="string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;,&#123;&quot;ID&quot;:3,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu03&quot;&#125;,&#123;&quot;ID&quot;:4,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu04&quot;&#125;,&#123;&quot;ID&quot;:5,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu05&quot;&#125;,&#123;&quot;ID&quot;:6,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu06&quot;&#125;,&#123;&quot;ID&quot;:7,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu07&quot;&#125;,&#123;&quot;ID&quot;:8,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu08&quot;&#125;,&#123;&quot;ID&quot;:9,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu09&quot;&#125;]&#125;`</span></span><br><span class="line">    c1 := &amp;Class&#123;&#125;</span><br><span class="line">    err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json unmarshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-21-结构体标签（Tag）"><a href="#1-3-21-结构体标签（Tag）" class="headerlink" title="1.3.21. 结构体标签（Tag）"></a>1.3.21. 结构体标签（Tag）</h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。</p><p>Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`key1:&quot;value1&quot; key2:&quot;value2&quot;`</span><br></pre></td></tr></table></figure><p>结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。 注意事项： 为结构体编写Tag时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值。例如不要在key和value之间添加空格。</p><p>例如我们为Student结构体的每个字段定义json序列化时使用的Tag：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID     <span class="keyword">int</span>    <span class="string">`json:&quot;id&quot;`</span> <span class="comment">//通过指定tag实现json序列化该字段时的key</span></span><br><span class="line">    Gender <span class="keyword">string</span> <span class="comment">//json序列化是默认使用字段名作为key</span></span><br><span class="line">    name   <span class="keyword">string</span> <span class="comment">//私有不能被json包访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := Student&#123;</span><br><span class="line">        ID:     <span class="number">1</span>,</span><br><span class="line">        Gender: <span class="string">&quot;女&quot;</span>,</span><br><span class="line">        name:   <span class="string">&quot;pprof&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    data, err := json.Marshal(s1)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;json marshal failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;json str:%s\n&quot;</span>, data) <span class="comment">//json str:&#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;女&quot;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-22-小练习："><a href="#1-3-22-小练习：" class="headerlink" title="1.3.22. 小练习："></a>1.3.22. 小练习：</h3><p>猜一下下列代码运行的结果是什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(ce []student)</span></span> &#123;</span><br><span class="line">    <span class="comment">//切片是引用传递，是可以改变值的</span></span><br><span class="line">    ce[<span class="number">1</span>].age = <span class="number">999</span></span><br><span class="line">    <span class="comment">// ce = append(ce, student&#123;3, &quot;xiaowang&quot;, 56&#125;)</span></span><br><span class="line">    <span class="comment">// return ce</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ce []student  <span class="comment">//定义一个切片类型的结构体</span></span><br><span class="line">    ce = []student&#123;</span><br><span class="line">        student&#123;<span class="number">1</span>, <span class="string">&quot;xiaoming&quot;</span>, <span class="number">22</span>&#125;,</span><br><span class="line">        student&#123;<span class="number">2</span>, <span class="string">&quot;xiaozhang&quot;</span>, <span class="number">33</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">    demo(ce)</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-23-删除map类型的结构体"><a href="#1-3-23-删除map类型的结构体" class="headerlink" title="1.3.23. 删除map类型的结构体"></a>1.3.23. 删除map类型的结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    id   <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ce := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]student)</span><br><span class="line">    ce[<span class="number">1</span>] = student&#123;<span class="number">1</span>, <span class="string">&quot;xiaolizi&quot;</span>, <span class="number">22</span>&#125;</span><br><span class="line">    ce[<span class="number">2</span>] = student&#123;<span class="number">2</span>, <span class="string">&quot;wang&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">    <span class="built_in">delete</span>(ce, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(ce)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-24-实现map有序输出-面试经常问到"><a href="#1-3-24-实现map有序输出-面试经常问到" class="headerlink" title="1.3.24. 实现map有序输出(面试经常问到)"></a>1.3.24. 实现map有序输出(面试经常问到)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line">    map1[<span class="number">1</span>] = <span class="string">&quot;www.topgoer.com&quot;</span></span><br><span class="line">    map1[<span class="number">2</span>] = <span class="string">&quot;rpc.topgoer.com&quot;</span></span><br><span class="line">    map1[<span class="number">5</span>] = <span class="string">&quot;ceshi&quot;</span></span><br><span class="line">    map1[<span class="number">3</span>] = <span class="string">&quot;xiaohong&quot;</span></span><br><span class="line">    map1[<span class="number">4</span>] = <span class="string">&quot;xiaohuang&quot;</span></span><br><span class="line">    sli := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, _ := <span class="keyword">range</span> map1 &#123;</span><br><span class="line">        sli = <span class="built_in">append</span>(sli, k)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(sli)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(map1); i++ &#123;</span><br><span class="line">        fmt.Println(map1[sli[i]])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-25-小案例"><a href="#1-3-25-小案例" class="headerlink" title="1.3.25. 小案例"></a>1.3.25. 小案例</h3><p>采用切片类型的结构体接受查询数据库信息返回的参数</p><p>地址：<a href="https://github.com/lu569368/struct">https://github.com/lu569368/struct</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的浅拷贝和深拷贝</title>
      <link href="/2021/12/01/Slice(%E5%88%87%E7%89%87)%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2021/12/01/Slice(%E5%88%87%E7%89%87)%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Slice-切片-的理解"><a href="#Slice-切片-的理解" class="headerlink" title="Slice(切片)的理解"></a>Slice(切片)的理解</h1><p>slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 切片：切片是数组的一个引用，因此切片是引用类型。但自身是结构体，值拷贝传递。（存疑）</span><br><span class="line">  2. 切片的长度可以改变，因此，切片是一个可变的数组。</span><br><span class="line">  3. 切片遍历方式和数组一样，可以用len()求长度。表示可用元素数量，读写操作不能超过该限制。 </span><br><span class="line">  4. cap可以求出slice最大扩张容量，不能超出数组限制。0 &lt;= len(slice) &lt;= len(array)，其中array是slice引用的数组。</span><br><span class="line">  5. 切片的定义：var 变量名 []类型，比如 var str []string  var arr []int。</span><br><span class="line">  6. 如果 slice == nil，那么 len、cap 结果都等于 0。</span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go mod 的用法</title>
      <link href="/2021/11/30/go%20mod%20%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2021/11/30/go%20mod%20%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="go-mod-的用法"><a href="#go-mod-的用法" class="headerlink" title="go mod 的用法"></a>go mod 的用法</h1><h3 id="go-mod介绍"><a href="#go-mod介绍" class="headerlink" title="go mod介绍"></a>go mod介绍</h3><p>go modules 是 golang 1.11 新加的特性。现在1.12 已经发布了，是时候用起来了。Modules官方定义为：</p><blockquote><p>模块是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。<br> <span id="more"></span></p></blockquote><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>GO111MODULE 有三个值：off, on和auto（默认值）。</p><p>GO111MODULE=off，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。<br> GO111MODULE=on，go命令行会使用modules，而一点也不会去GOPATH目录下查找。<br> GO111MODULE=auto，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前目录在GOPATH/src之外且该目录包含<span class="keyword">go</span>.mod文件</span><br><span class="line">当前文件在包含<span class="keyword">go</span>.mod文件的目录下面。</span><br></pre></td></tr></table></figure><p>当modules功能启用时，依赖包的存放位置变更为$GOPATH/pkg，允许同一个package多个版本并存，且多个项目可以共享缓存的 module</p><h3 id="go-mod命令"><a href="#go-mod命令" class="headerlink" title="go mod命令"></a>go mod命令</h3><p>golang 提供了 <code>go mod</code>命令来管理包。</p><p>go help mod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Go mod provides access to operations on modules.</span><br><span class="line"></span><br><span class="line">Note that support <span class="keyword">for</span> modules is built into all the go commands,</span><br><span class="line">not just <span class="string">&#x27;go mod&#x27;</span>. For example, day-to-day adding, removing, upgrading,</span><br><span class="line">and downgrading of dependencies should be <span class="keyword">done</span> using <span class="string">&#x27;go get&#x27;</span>.</span><br><span class="line">See <span class="string">&#x27;go help modules&#x27;</span> <span class="keyword">for</span> an overview of module functionality.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">    go mod &lt;<span class="built_in">command</span>&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">    download    download modules to <span class="built_in">local</span> cache</span><br><span class="line">    edit        edit go.mod from tools or scripts</span><br><span class="line">    graph       <span class="built_in">print</span> module requirement graph</span><br><span class="line">    init        initialize new module <span class="keyword">in</span> current directory</span><br><span class="line">    tidy        add missing and remove unused modules</span><br><span class="line">    vendor      make vendored copy of dependencies</span><br><span class="line">    verify      verify dependencies have expected content</span><br><span class="line">    why         explain why packages or modules are needed</span><br><span class="line"></span><br><span class="line">Use <span class="string">&quot;go help mod &lt;command&gt;&quot;</span> <span class="keyword">for</span> more information about a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure><p>go mod 有以下命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>download</td><td>download modules to local cache(下载依赖包)</td></tr><tr><td>edit</td><td>edit go.mod from tools or scripts（编辑go.mod)</td></tr><tr><td>graph</td><td>print module requirement graph (打印模块依赖图)</td></tr><tr><td>verify</td><td>initialize new module in current directory（在当前目录初始化mod）</td></tr><tr><td>tidy</td><td>add missing and remove unused modules(拉取缺少的模块，移除不用的模块)</td></tr><tr><td>vendor</td><td>make vendored copy of dependencies(将依赖复制到vendor下)</td></tr><tr><td>verify</td><td>verify dependencies have expected content (验证依赖是否正确）</td></tr><tr><td>why</td><td>explain why packages or modules are needed(解释为什么需要依赖)</td></tr></tbody></table><p>比较常用的是 <code>init</code>,<code>tidy</code>, <code>edit</code></p><h3 id="使用go-mod管理一个新项目"><a href="#使用go-mod管理一个新项目" class="headerlink" title="使用go mod管理一个新项目"></a>使用go mod管理一个新项目</h3><h4 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a>1. 初始化项目</h4><p>可以随便找一个目录创建项目，我使用习惯用IDEA进行创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir Gone</span><br><span class="line"><span class="built_in">cd</span> Gone</span><br><span class="line">go mod init Gone</span><br></pre></td></tr></table></figure><p>查看一下 go.mod文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。</p><p>go.mod 提供了module, require、replace和exclude 四个命令</p><ul><li><code>module</code> 语句指定包的名字（路径）</li><li><code>require</code> 语句指定的依赖项模块</li><li><code>replace</code> 语句可以替换依赖项模块</li><li><code>exclude</code> 语句可以忽略依赖项模块</li></ul><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2. 添加依赖"></a>2. 添加依赖</h4><p>创建 main.go文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    r.Run() <span class="comment">// listen and serve on 0.0.0.0:8080 (for windows &quot;localhost:8080&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 go run main.go 运行代码会发现 go mod 会自动查找依赖自动下载<br> 再查看 <code>go.mod</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require github.com/gin-gonic/gin v1.6.3</span><br></pre></td></tr></table></figure><p>go module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit</p><p>go 会自动生成一个 go.sum 文件来记录 dependency tree</p><p><img src="https://upload-images.jianshu.io/upload_images/1293367-6d16a0d961653490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>再次执行脚本 go run main.go发现跳过了检查并安装依赖的步骤。</p><p>可以使用命令 go list -m -u all 来检查可以升级的package，使用go get -u need-upgrade-package 升级后会将新的依赖版本更新到go.mod * 也可以使用 go get -u 升级所有依赖</p><h3 id="go-get升级"><a href="#go-get升级" class="headerlink" title="go get升级"></a>go get升级</h3><ul><li>运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li><li>运行 go get -u=patch 将会升级到最新的修订版本</li><li>运行 go get package@version 将会升级到指定的版本号version</li><li>运行go get如果有版本的更改，那么go.mod文件也会更改</li></ul><h3 id="使用replace替换无法直接获取的package"><a href="#使用replace替换无法直接获取的package" class="headerlink" title="使用replace替换无法直接获取的package"></a>使用replace替换无法直接获取的package</h3><p>由于某些已知的原因，并不是所有的package都能成功下载，比如：golang.org下的包。</p><p>modules 可以通过在 go.mod 文件中使用 replace 指令替换成github上对应的库，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replace (</span><br><span class="line">    golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="go-mod发布和使用"><a href="#go-mod发布和使用" class="headerlink" title="go mod发布和使用"></a>go mod发布和使用</h3><p>参考Roberto Selbach写的go mod入门文章，文末，我给出链接</p><h3 id="Creating-a-Module"><a href="#Creating-a-Module" class="headerlink" title="Creating a Module"></a>Creating a Module</h3><p>如果你设置好go mod了，那你就可以在任何目录下随便创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> gomodone</span><br><span class="line"><span class="variable">$cd</span> gomodone</span><br></pre></td></tr></table></figure><p>在这个目录下创建一个文件<code>say.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gomodone</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// say Hi to someone</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化一个 <code>go.mod</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init github.com/jacksonyoudi/gomodone</span><br><span class="line">go: creating new go.mod: module github.com/jacksonyoudi/gomodone</span><br></pre></td></tr></table></figure><p>查看 go.mod内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">github.com/jacksonyoudi/gomodone</span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>下面我们要将这个module发布到github上，然后在另外一个程序使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> init</span><br><span class="line"><span class="variable">$vim</span> .gitiiignore</span><br><span class="line"><span class="variable">$git</span> commit -am <span class="string">&quot;init&quot;</span></span><br><span class="line">// github创建对应的repo</span><br><span class="line"><span class="variable">$git</span> remote add origin git@github.com:jacksonyoudi/gomodone.git</span><br><span class="line"><span class="variable">$git</span> push -u origin master</span><br></pre></td></tr></table></figure><p>执行完，上面我们就相当于发布完了。</p><p>如果有人需要使用，就可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/jacksonyoudi/gomodone</span><br></pre></td></tr></table></figure><p>这个时候没有加tag，所以，没有版本的控制。默认是v0.0.0后面接上时间和commitid。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gomodone@v0.0.0-20200517004046-ee882713fd1e</span><br></pre></td></tr></table></figure><p>官方不建议这样做，没有进行版本控制管理。</p><h3 id="module-versioning"><a href="#module-versioning" class="headerlink" title="module versioning"></a>module versioning</h3><p>使用tag，进行版本控制</p><h4 id="making-a-release"><a href="#making-a-release" class="headerlink" title="making a release"></a>making a release</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>操作完，我们的module就发布了一个v1.0.0的版本了。</p><p>推荐在这个状态下，再切出一个分支，用于后续v1.0.0的修复推送,不要直接在master分支修复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> checkout -b v1</span><br><span class="line"><span class="variable">$git</span> push -u origin v1</span><br></pre></td></tr></table></figure><h3 id="use-our-module"><a href="#use-our-module" class="headerlink" title="use our module"></a>use our module</h3><p>上面已经发布了一个v1.0.0的版本，我们可以在另一个项目中使用，创建一个go的项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> Gone</span><br><span class="line"><span class="variable">$cd</span> Gone</span><br><span class="line"><span class="variable">$vim</span> main.go</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jacksonyoudi/gomodone&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(gomodone.SayHi(<span class="string">&quot;Roberto&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码写好了，我们生成 go mod文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init Gone</span><br></pre></td></tr></table></figure><p>上面命令执行完，会生成 go mod文件<br> 看下mod文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line">go 1.14</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/jacksonyoudi/gomodone v1.0.0</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> package github.com/jacksonyoudi/gomodone</span><br><span class="line">go: found github.com/jacksonyoudi/gomodone <span class="keyword">in</span> github.com/jacksonyoudi/gomodone v1.0.0</span><br></pre></td></tr></table></figure><p>同时还生成了go.sum, 其中包含软件包的哈希值，以确保我们具有正确的版本和文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">github.com/jacksonyoudi/gomodone v1.0.1 h1:jFd+qZlAB0R3zqrC9kwO8IgPrAdayMUS0rSHMDc/uG8=</span><br><span class="line">github.com/jacksonyoudi/gomodone v1.0.1/go.mod h1:XWi+BLbuiuC2YM8Qz4yQzTSPtHt3T3hrlNN2pNlyA94=</span><br><span class="line">github.com/jacksonyoudi/gomodone/v2 v2.0.0 h1:GpzGeXCx/Xv2ueiZJ8hEhFwLu7xjxLBjkOYSmg8Ya/w=</span><br><span class="line">github.com/jacksonyoudi/gomodone/v2 v2.0.0/go.mod h1:L8uFPSZNHoAhpaePWUfKmGinjufYdw9c2i70xtBorSw=</span><br></pre></td></tr></table></figure><p>这个内容是下面的，需要操作执行的结果</p><p>go run main.go就可以运行了</p><h3 id="Making-a-bugfix-release"><a href="#Making-a-bugfix-release" class="headerlink" title="Making a bugfix release"></a>Making a bugfix release</h3><p>假如fix一个bug,我们在v1版本上进行修复</p><p>修改代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// say Hi to someone</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">-       <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s&quot;</span>, name)</span><br><span class="line">+       <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s!&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复好，我们开始push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;Emphasize our friendliness&quot;</span> say.go</span><br><span class="line">$ git tag v1.0.1</span><br><span class="line">$ git push --tags origin v1</span><br></pre></td></tr></table></figure><h4 id="Updating-modules"><a href="#Updating-modules" class="headerlink" title="Updating modules"></a>Updating modules</h4><p>刚才fix bug，所以要在我们使用项目中更新</p><p>这个需要我们手动执行更新module操作</p><p>我们通过使用我们的好朋友来做到这一点go get：</p><ul><li>运行  <code>go get -u</code> 以使用最新的  minor  版本或修补程序版本（即它将从1.0.0更新到例如1.0.1，或者，如果可用，则更新为1.1.0）</li><li>运行  go get -u=patch 以使用最新的  修补程序  版本（即，将更新为1.0.1但不更新  为1.1.0）</li><li>运行go get package@version 以更新到特定版本（例如<a href="https://links.jianshu.com/go?to=http://github.com/jacksonyoudi/gomodone@v1.0.1">github.com/jacksonyoudi/gomodone@v1.0.1</a>）</li></ul><p>目前module最新的也是v1.0.1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 更新最新</span><br><span class="line"><span class="variable">$go</span> get -u</span><br><span class="line"><span class="variable">$go</span> get -u=patch</span><br><span class="line">//指定包，指定版本</span><br><span class="line"><span class="variable">$go</span> get github.com/jacksonyoudi/gomodone@v1.0.1</span><br></pre></td></tr></table></figure><p>操作完，go.mod文件会修改如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module Gone</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">    github.com/jacksonyoudi/gomodone v1<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="Major-versions"><a href="#Major-versions" class="headerlink" title="Major versions"></a>Major versions</h4><p>根据语义版本语义，主要版本与次要版本  不同。主要版本可能会破坏向后兼容性。从Go模块的角度来看，主要版本是  完全不同的软件包。乍一看这听起来很奇怪，但这是有道理的：两个不兼容的库版本是两个不同的库。<br> 比如下面修改，完全破坏了兼容性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> gomodone</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hi returns a friendly greeting</span></span><br><span class="line"><span class="comment">// Hi returns a friendly greeting in language lang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SayHi</span><span class="params">(name, lang <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> lang &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;en&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Hi, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pt&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Oi, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;es&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;¡Hola, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;fr&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Bonjour, %s!&quot;</span>, name), <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;unknown language&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们需要不同的大版本，这种情况下</p><p>修改 go.mod如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module github.com/jacksonyoudi/gomodone/v2</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.14</span></span><br></pre></td></tr></table></figure><p>然后，重新tag，push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit say.go -m <span class="string">&quot;Change Hi to allow multilang&quot;</span></span><br><span class="line">$ git checkout -b v2 <span class="comment"># 用于v2版本，后续修复v2</span></span><br><span class="line">$ git commit go.mod -m <span class="string">&quot;Bump version to v2&quot;</span></span><br><span class="line">$ git tag v2.0.0</span><br><span class="line">$ git push --tags origin v2 </span><br></pre></td></tr></table></figure><h3 id="Updating-to-a-major-version"><a href="#Updating-to-a-major-version" class="headerlink" title="Updating to a major version"></a>Updating to a major version</h3><p>即使发布了库的新不兼容版本，现有软件 也不会中断，因为它将继续使用现有版本1.0.1。go get -u 将不会获得版本2.0.0。<br> 如果想使用v2.0.0,代码改成如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jacksonyoudi/gomodone/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g, err := gomodone.SayHi(<span class="string">&quot;Roberto&quot;</span>, <span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 go mod tidy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go: finding module <span class="keyword">for</span> package github.com/jacksonyoudi/gomodone/v2</span><br><span class="line">go: downloading github.com/jacksonyoudi/gomodone/v2 v2.0.0</span><br><span class="line">go: found github.com/jacksonyoudi/gomodone/v2 <span class="keyword">in</span> github.com/jacksonyoudi/gomodone/v2 v2.0.0</span><br></pre></td></tr></table></figure><p>当然，两个版本都可以同时使用, 使用别名<br> 如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/jacksonyoudi/gomodone&quot;</span></span><br><span class="line">    mv2 <span class="string">&quot;github.com/jacksonyoudi/gomodone/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    g, err := mv2.SayHi(<span class="string">&quot;Roberto&quot;</span>, <span class="string">&quot;pt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(g)</span><br><span class="line"></span><br><span class="line">    fmt.Println(gomodone.SayHi(<span class="string">&quot;Roberto&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行一下 <code>go mod tidy</code></p><h3 id="Vendoring"><a href="#Vendoring" class="headerlink" title="Vendoring"></a>Vendoring</h3><p>默认是忽略vendor的，如果想在项目目录下有vendor可以执行下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> vendor</span><br></pre></td></tr></table></figure><p>当然，如果构建程序的时候，希望使用vendor中的依赖，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build -mod vendor</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go的浅拷贝和深拷贝</title>
      <link href="/2021/11/29/go%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2021/11/29/go%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="go的浅拷贝和深拷贝"><a href="#go的浅拷贝和深拷贝" class="headerlink" title="go的浅拷贝和深拷贝"></a>go的浅拷贝和深拷贝</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>拷贝的是数据本身，创建一个新对象，新创建的对象与源对象不共享内存，新创建的对象在内存中开启一个新的内存地址，新对象值修改时不会影响原对象值。既然内存地址不同，释放内存地址时，可分别释放。</p><p>值类型的数据，默认是深拷贝，Array，Int，String，Struct，Float，Bool。<br> <span id="more"></span></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>拷贝的是数据地址，只复制指向对象的指针，此时新对象和老对象指向的内存地址是一样的，新对象值修改时老对象也会发生变化。释放内存地址时，同时释放。</p><p>引用类型的数据，默认全部都是浅拷贝，Slice，Map。</p><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><p>是否真正获取对象数据，而不是引用。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora历史版本下载地址</title>
      <link href="/2021/11/29/Typora%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
      <url>/2021/11/29/Typora%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora历史版本下载地址"><a href="#Typora历史版本下载地址" class="headerlink" title="Typora历史版本下载地址"></a>Typora历史版本下载地址</h1><p>Typora开始收费了</p><p><a href="https://typora.io/windows/dev_release.html">Typora for windows — beta version release</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git生成ssh</title>
      <link href="/2021/11/29/git%E7%94%9F%E6%88%90ssh/"/>
      <url>/2021/11/29/git%E7%94%9F%E6%88%90ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="git生成ssh"><a href="#git生成ssh" class="headerlink" title="git生成ssh"></a>git生成ssh</h1><p>输入 ssh 命令，查看本机是否安装 SSH：</p><p><img src="/images/v2-b4792b227defc69aa7927ca9b73e4316_720w.jpg" alt="img"><br> <span id="more"></span><br>如上图所示，即已安装 SSH. 然后，输入 ssh-keygen -t rsa 命令<em><strong>（注意空格）</strong></em>，表示我们指定 RSA 算法生成密钥，然后敲四次回车键，之后就就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub. ***（注意：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和 Shift+insert.）***文件的位置在 Git Bash 上面都有显示，默认生成在以下目录：</p><ul><li>Linux 系统：~/.ssh</li><li>Mac 系统：~/.ssh</li><li>Windows 10 ：C:/Users/ASUS/.ssh</li></ul><p>接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，你可以通过目录找到 id_rsa.pub 文件的位置，用记事本打开文件复制。如果你实在找不到文件也没有关系，按照以下步骤直接在 Git Bash 上打开就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh </span><br><span class="line">$ ls</span><br><span class="line">$ cat id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="/images/v2-692b1cd8e719dac8012afe6fda775209_720w.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在gin框架中使用gorilla实现websocket</title>
      <link href="/2021/11/29/%E5%9C%A8gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8gorilla%E5%AE%9E%E7%8E%B0websocket/"/>
      <url>/2021/11/29/%E5%9C%A8gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8gorilla%E5%AE%9E%E7%8E%B0websocket/</url>
      
        <content type="html"><![CDATA[<h1 id="在gin框架中使用gorilla实现websocket"><a href="#在gin框架中使用gorilla实现websocket" class="headerlink" title="在gin框架中使用gorilla实现websocket"></a>在gin框架中使用gorilla实现websocket</h1><h2 id="go代码"><a href="#go代码" class="headerlink" title="go代码"></a>go代码</h2><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gorilla/websocket&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//用来记录连接的cone</span></span><br><span class="line"><span class="keyword">var</span> wsargs []*websocket.Conn</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置websocket</span></span><br><span class="line"><span class="comment">//CheckOrigin防止跨站点的请求伪造</span></span><br><span class="line"><span class="keyword">var</span> upGrader = websocket.Upgrader&#123;</span><br><span class="line">CheckOrigin: <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//websocket实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//升级get请求为webSocket协议</span></span><br><span class="line">ws, err := upGrader.Upgrade(c.Writer, c.Request, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ws.Close() <span class="comment">//返回前关闭</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> wsargs &#123;</span><br><span class="line"><span class="keyword">if</span> v == ws &#123;</span><br><span class="line">wsargs = <span class="built_in">append</span>(wsargs[:k], wsargs[k+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()<span class="comment">//返回前在集合中删除对应的cone</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;删除&quot;</span>)</span><br><span class="line">wsargs = <span class="built_in">append</span>(wsargs, ws)</span><br><span class="line">fmt.Println(wsargs)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//读取ws中的数据</span></span><br><span class="line">mt, message, err := ws.ReadMessage()</span><br><span class="line">fmt.Println(mt)</span><br><span class="line">fmt.Println(message)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写入ws数据</span></span><br><span class="line">err = ws.WriteMessage(mt, message)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ping2</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> wsargs &#123;</span><br><span class="line">err := v.WriteMessage(<span class="number">1</span>, []<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(<span class="string">&quot;/ping&quot;</span>, ping)</span><br><span class="line">r.GET(<span class="string">&quot;/ping2&quot;</span>, ping2)</span><br><span class="line">r.Run(<span class="string">&quot;:12345&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:12345/ping&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//连接打开时触发 </span></span></span><br><span class="line"><span class="javascript">    ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>);</span></span><br><span class="line"><span class="javascript">      ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//接收到消息时触发  </span></span></span><br><span class="line"><span class="javascript">    ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Received Message: &quot;</span> + evt.data);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//连接关闭时触发  </span></span></span><br><span class="line"><span class="javascript">    ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="websocket在线测试网址"><a href="#websocket在线测试网址" class="headerlink" title="websocket在线测试网址"></a>websocket在线测试网址</h2><p><a href="http://coolaf.com/tool/chattest">在线websocket测试-online tool-postjson (coolaf.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongo数据库连接问题</title>
      <link href="/2021/11/26/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/26/mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="mongo数据库连接问题"><a href="#mongo数据库连接问题" class="headerlink" title="mongo数据库连接问题"></a>mongo数据库连接问题</h1><p>在服务器设置好mongo的账号密码后</p><p><img src="/images/image-20211126144037696.png" alt="image-20211126144037696"><br> <span id="more"></span><br>直接输入mongo，进入操作时。会发现无法展示自己的数据库了。</p><p>这个其实是没有登录的原因</p><p><img src="/images/image-20211126144208185.png" alt="image-20211126144208185"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.auth(&quot;账号&quot;,&quot;密码&quot;)</span><br></pre></td></tr></table></figure><p>返回值为1代表登录成功</p><p><img src="/images/image-20211126144308939.png" alt="image-20211126144308939"></p><p>现在便可以正常的操作mongo了</p>]]></content>
      
      
      <categories>
          
          <category> mongo连接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2021/11/25/%E9%97%AD%E5%8C%85/"/>
      <url>/2021/11/25/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h3 id="“官方”的解释是："><a href="#“官方”的解释是：" class="headerlink" title="“官方”的解释是："></a>“官方”的解释是：</h3><p>所谓“闭包”，指的是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br> <span id="more"></span></p><h3 id="维基百科讲"><a href="#维基百科讲" class="headerlink" title="维基百科讲"></a>维基百科讲</h3><p>闭包（Closure），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p><p>解析：</p><p>使用闭包主要是为了设计私有的方法和变量。</p><p>闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在JavaScript中，函数即闭包，只有函数才会产生作用域。<br>闭包有3个特性：</p><p>（1）函数嵌套函数。<br>（2）在函数内部可以引用外部的参数和变量。<br>（3）参数和变量不会以垃圾回收机制回收。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang发送邮件</title>
      <link href="/2021/11/25/golang%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2021/11/25/golang%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="golang发送邮件"><a href="#golang发送邮件" class="headerlink" title="golang发送邮件"></a>golang发送邮件</h1><p>电子邮件在网络中传输和网页一样需要遵从特定的协议，常用的电子邮件协议包括 SMTP，POP3，IMAP。其中邮件的创建和发送只需要用到 SMTP协议，所以本文也只会涉及到SMTP协议。SMTP 是 Simple Mail Transfer Protocol 的简称，即简单邮件传输协议。<br> <span id="more"></span></p><h3 id="1-1-2-特征"><a href="#1-1-2-特征" class="headerlink" title="1.1.2. 特征"></a>1.1.2. 特征</h3><ul><li><p>发件人，收件人，密件抄送和抄送字段</p></li><li><p>文字和HTML邮件正文</p></li><li><p>附件</p></li><li><p>阅读收据</p></li><li><p>自定义标题</p></li><li><p>首先我们登录QQ邮箱，设置-&gt;账户 找到图片的位置开启<code>POP3/SMTP/IMAP</code>并且按照要求生产授权码</p></li></ul><p><img src="/images/image_3.png" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/smtp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jordan-wright/email&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">e := email.NewEmail()</span><br><span class="line"><span class="comment">//设置发送方的邮箱</span></span><br><span class="line">e.From = <span class="string">&quot;dj &lt;2061529596@qq.com&gt;&quot;</span></span><br><span class="line"><span class="comment">// 设置接收方的邮箱</span></span><br><span class="line">e.To = []<span class="keyword">string</span>&#123;<span class="string">&quot;1264646904@qq.com&quot;</span>,<span class="string">&quot;3161362058@qq.com&quot;</span>&#125;</span><br><span class="line"><span class="comment">//设置主题</span></span><br><span class="line">e.Subject = <span class="string">&quot;这是主题&quot;</span></span><br><span class="line"><span class="comment">//设置文件发送的内容</span></span><br><span class="line">e.Text = []<span class="keyword">byte</span>(<span class="string">&quot;www.topgoer.com是个不错的go语言中文文档&quot;</span>)</span><br><span class="line"><span class="comment">//设置服务器相关的配置</span></span><br><span class="line">err := e.Send(<span class="string">&quot;smtp.qq.com:25&quot;</span>, smtp.PlainAuth(<span class="string">&quot;&quot;</span>, <span class="string">&quot;2061529596@qq.com&quot;</span>, <span class="string">&quot;zmawrrwtiyfxcgcc&quot;</span>, <span class="string">&quot;smtp.qq.com&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC概念</title>
      <link href="/2021/11/24/gRPC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/11/24/gRPC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="gRPC概念"><a href="#gRPC概念" class="headerlink" title="gRPC概念"></a>gRPC概念</h1><h2 id="gRPC-是什么？"><a href="#gRPC-是什么？" class="headerlink" title="gRPC 是什么？"></a>gRPC 是什么？</h2><p>在 gRPC 里<em>客户端</em>应用可以像调用本地对象一样直接调用另一台不同的机器上<em>服务端</em>应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个<em>服务</em>，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个<em>存根</em>能够像服务端一样的方法。</p><p><img src="/images/grpc_concept_diagram_00.png" alt="图1"><br> <span id="more"></span></p><h3 id="使用-protocol-buffers"><a href="#使用-protocol-buffers" class="headerlink" title="使用 protocol buffers"></a>使用 protocol buffers</h3><p>gRPC 默认使用 <em>protocol buffers</em>，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。正如你将在下方例子里所看到的，你用 <em>proto files</em> 创建 gRPC 服务，用 protocol buffers 消息类型来定义方法参数和返回类型。你可以在 <a href="http://doc.oschina.net/https%EF%BC%9A//developers.google.com/protocol-buffers/docs/overview">Protocol Buffers 文档</a>找到更多关于 Protocol Buffers 的资料。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h3><p>正如其他 RPC 系统，gRPC 基于如下思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 <a href="https://developers.google.com/protocol-buffers/">protocol buffers</a> 作为接口定义语言，来描述服务接口和有效载荷消息结构。如果有需要的话，可以使用其他替代方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service HelloService &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  required string greeting = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">  required string reply = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gRPC 允许你定义四类服务方法：</p><ul><li>单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns (stream HelloResponse)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-API-接口"><a href="#使用-API-接口" class="headerlink" title="使用 API 接口"></a>使用 API 接口</h3><p>gRPC 提供 protocol buffer 编译插件，能够从一个服务定义的 .proto 文件生成客户端和服务端代码。通常 gRPC 用户可以在服务端实现这些API，并从客户端调用它们。</p><ul><li>在服务侧，服务端实现服务接口，运行一个 gRPC 服务器来处理客户端调用。gRPC 底层架构会解码传入的请求，执行服务方法，编码服务应答。</li><li>在客户侧，客户端有一个<em>存根</em>实现了服务端同样的方法。客户端可以在本地存根调用这些方法，用合适的 protocol buffer 消息类型封装这些参数— gRPC 来负责发送请求给服务端并返回服务端 protocol buffer 响应。</li></ul><h3 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h3><p>同步 RPC 调用一直会阻塞直到从服务端获得一个应答，这与 RPC 希望的抽象最为接近。另一方面网络内部是异步的，并且在许多场景下能够在不阻塞当前线程的情况下启动 RPC 是非常有用的。</p><p>在多数语言里，gRPC 编程接口同时支持同步和异步的特点。你可以从每个语言教程和参考文档里找到更多内容(很快就会有完整文档)。</p><h2 id="RPC-生命周期"><a href="#RPC-生命周期" class="headerlink" title="RPC 生命周期"></a>RPC 生命周期</h2><p>现在让我们来仔细了解一下当 gRPC 客户端调用 gRPC 服务端的方法时到底发生了什么。我们不究其实现细节，关于实现细节的部分，你可以在我们的特定语言页面里找到更为详尽的内容。</p><h3 id="单项-RPC"><a href="#单项-RPC" class="headerlink" title="单项 RPC"></a>单项 RPC</h3><p>首先我们来了解一下最简单的 RPC 形式：客户端发出单个请求，获得单个响应。</p><ul><li>一旦客户端通过桩调用一个方法，服务端会得到相关通知 ，通知包括客户端的元数据，方法名，允许的响应期限（如果可以的话）</li><li>服务端既可以在任何响应之前直接发送回初始的元数据，也可以等待客户端的请求信息，到底哪个先发生，取决于具体的应用。</li><li>一旦服务端获得客户端的请求信息，就会做所需的任何工作来创建或组装对应的响应。如果成功的话，这个响应会和包含状态码以及可选的状态信息等状态明细及可选的追踪信息返回给客户端 。</li><li>假如状态是 OK 的话，客户端会得到应答，这将结束客户端的调用。</li></ul><h3 id="服务端流式-RPC"><a href="#服务端流式-RPC" class="headerlink" title="服务端流式 RPC"></a>服务端流式 RPC</h3><p>服务端流式 RPC 除了在得到客户端请求信息后发送回一个应答流之外，与我们的简单例子一样。在发送完所有应答后，服务端的状态详情(状态码和可选的状态信息)和可选的跟踪元数据被发送回客户端，以此来完成服务端的工作。客户端在接收到所有服务端的应答后也完成了工作。</p><h3 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h3><p>客户端流式 RPC 也基本与我们的简单例子一样，区别在于客户端通过发送一个请求流给服务端，取代了原先发送的单个请求。服务端通常（但并不必须）会在接收到客户端所有的请求后发送回一个应答，其中附带有它的状态详情和可选的跟踪数据。</p><h3 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h3><p>双向流式 RPC ，调用由客户端调用方法来初始化，而服务端则接收到客户端的元数据，方法名和截止时间。服务端可以选择发送回它的初始元数据或等待客户端发送请求。 下一步怎样发展取决于应用，因为客户端和服务端能在任意顺序上读写 - 这些流的操作是完全独立的。例如服务端可以一直等直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像”乒乓球”一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。</p><h3 id="截止时间"><a href="#截止时间" class="headerlink" title="截止时间"></a>截止时间</h3><p>gRPC 允许客户端在调用一个远程方法前指定一个最后期限值。这个值指定了在客户端可以等待服务端多长时间来应答，超过这个时间值 RPC 将结束并返回<code>DEADLINE_EXCEEDED</code>错误。在服务端可以查询这个期限值来看是否一个特定的方法已经过期，或者还剩多长时间来完成这个方法。 各语言来指定一个截止时间的方式是不同的 - 比如在 Python 里一个截止时间值总是必须的，但并不是所有语言都有一个默认的截止时间。</p><h3 id="RPC-终止"><a href="#RPC-终止" class="headerlink" title="RPC 终止"></a>RPC 终止</h3><p>在 gRPC 里，客户端和服务端对调用成功的判断是独立的、本地的，他们的结论可能不一致。这意味着，比如你有一个 RPC 在服务端成功结束(“我已经返回了所有应答!”)，到那时在客户端可能是失败的(“应答在最后期限后才来到!”)。也可能在客户端把所有请求发送完前，服务端却判断调用已经完成了。</p><h3 id="取消-RPC"><a href="#取消-RPC" class="headerlink" title="取消 RPC"></a>取消 RPC</h3><p>无论客户端还是服务端均可以再任何时间取消一个 RPC 。一个取消会立即终止 RPC 这样可以避免更多操作被执行。它<em>不是</em>一个”撤销”， 在取消前已经完成的不会被回滚。当然，通过同步调用的 RPC 不能被取消，因为直到 RPC 结束前，程序控制权还没有交还给应用。</p><h3 id="元数据集"><a href="#元数据集" class="headerlink" title="元数据集"></a>元数据集</h3><p>元数据是一个特殊 RPC 调用对应的信息(<a href="http://doc.oschina.net/docs/guides/auth.html">授权详情</a>]) ，这些信息以键值对的形式存在，一般键的类型是字符串，值的类型一般也是字符串(当然也可以是二进制数据)。元数据对 gRPC 本事来说是不透明的 - 它让客户端提供调用相关的信息给服务端，反之亦然。 对于元数据的访问是语言相关的。</p><h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><p>TBD</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>TBD</p><h3 id="频道"><a href="#频道" class="headerlink" title="频道"></a>频道</h3><p>在创建客户端存根时，一个 gRPC 频道提供一个特定主机和端口服务端的连接。客户端可以通过指定频道参数来修改 gRPC 的默认行为，比如打开关闭消息压缩。一个频道具有状态，包含<code>已连接</code>和<code>空闲</code> 。 gRPC 如何处理关闭频道是语言相关的。有些语言可允许询问频道状态。</p>]]></content>
      
      
      <categories>
          
          <category> gRPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB逻辑操作符$or, $and,$not,$nor</title>
      <link href="/2021/11/23/MongoDB%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6$or,%20$and,$not,$nor/"/>
      <url>/2021/11/23/MongoDB%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6$or,%20$and,$not,$nor/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB逻辑操作符-or-and-not-nor"><a href="#MongoDB逻辑操作符-or-and-not-nor" class="headerlink" title="MongoDB逻辑操作符$or, $and,$not,$nor"></a>MongoDB逻辑操作符$or, $and,$not,$nor</h1><h2 id="or"><a href="#or" class="headerlink" title="$or"></a>$or</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">$match</span>: &#123; <span class="attr">$or</span>: [&#123; <span class="attr">name</span>: &#123; <span class="attr">$regex</span>: params.str &#125; &#125;, &#123; <span class="attr">class</span>: &#123; <span class="attr">$regex</span>: params.str &#125; &#125;, &#123; <span class="attr">studentId</span>: &#123; <span class="attr">$regex</span>: params.str &#125; &#125;] &#125; &#125;,</span><br></pre></td></tr></table></figure><p>是一个逻辑or操作符操作在一个数据或者多个表达式并且需要选择至少一个满足条件的表达式，$or有至少以下表达式：<br> <span id="more"></span><br>{ $or: [ { <expression1> }, { <expression2> }, … , { <expressionN> } ] }<br>考虑下面的例子：</p><p>db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } )<br>上面的例子会查询集合inventory中所有字段quantity小于20或者price等于10的所有文档。</p><p>使用$or条件评估条款，MongoDB会扫描整个文档集合，如果所有的条件支持索引，MongoDB进行索引扫描，因此MongoDB使用索引执行$or表达式，$or中的所有表达式必须支持索引，否则的话MongoDB就会扫描整个集合。</p><p>当使用$or查询并且使用索引时，每个$or的条件表达式都可以使用自己的索引，考虑下面的查询：</p><p>db.inventory.find( { $or: [ { quantity: { $lt: 20 } }, { price: 10 } ] } )<br>支持上面的查询你不需要创建一个符合索引，而是在字段quantity上创建一个索引，在price上创建一个索引。<br>db.inventory.createIndex( { quantity: 1 } )<br>db.inventory.createIndex( { price: 1 } )<br>$or和sort()操作<br>当使用$or执行sort()查询时，MongoDB可以使用支持$or查询条件的索引。之前的版本不支持索引。</p><h2 id="or与-in"><a href="#or与-in" class="headerlink" title="$or与$in"></a>$or与$in</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">$match</span>: &#123; <span class="attr">role</span>: &#123; <span class="attr">$in</span>: IDs &#125; &#125; &#125;,</span><br></pre></td></tr></table></figure><p>使用$or操作比较字段的值是否等于某个值时可以使用$in替换$or操作；例如查询集合inventory中字段quantity的值等于20或者50的所有文档，使用$in操作：</p><p>db.inventory.find ( { quantity: { $in: [20, 50] } } )</p><p>$and逻辑表达式</p><p>语法：{ $and: [ { <expression1> }, { <expression2> } , … , {<expressionN> } ] }</p><p>$and执行一个逻辑and操作在一个或者多个表达式上，并且查询数组中指定的所有表达式指定的文档document,$and使用短路求值，如果第一个表达式的结果是false，MongoDB将不会执行剩余的表达式；</p><p>例如：and查询指定同一个字段的多个查询条件</p><p>db.inventory.find( { $and: [ { price: { $ne: 1.99 } }, { price: { $exists: true } } ] } )<br>这个查询会选择集合inventory中的所有文档，条件是price不等于1.99并且price字段存在；<br>以上查询还可以使用隐式AND操作，如下：</p><p>db.inventory.find( { price: { $ne: 1.99, $exists: true } } )<br>AND查询使用多个表达式指定相同的操作：</p><p>db.inventory.find( {<br>    $and : [<br>        { $or : [ { price : 0.99 }, { price : 1.99 } ] },<br>        { $or : [ { sale : true }, { qty : { $lt : 20 } } ] }<br>    ]<br>} )<br>以上字段将会查询price字段值等于0.99或1.99并且sale字段值为true或者qty小于20的所有文档；<br>使用隐式AND操作无法构建此查询，因为它不止一次使用$or操作；</p><h2 id="not"><a href="#not" class="headerlink" title="$not"></a>$not</h2><p>语法： { field: { $not: { <operator-expression> } } }</p><p>$not执行一个逻辑not操作在指定的表达式并查询到不匹配表达式的文档，这包含不包括字段的文档；</p><p>考虑如下操作：</p><p>db.inventory.find( { price: { $not: { $gt: 1.99 } } } )<br>此查询将会查询inventory集合中的文档，条件如下： price字段小于等于1.99或者price不存在。<br>{ $not: { $gt: 1.99 } } 不同于$lte操作，{ $lte: 1.99 }操作只会返回price字段存在并且小于等于1.99的字段。</p><p>记住$not操作符只会影响其他操作符不能独立检查字段和文档，因此使用$not做逻辑析取和$ne操作测试字段内容；</p><p>使用$not操作时考虑如下操作：</p><p>操作$not操作符和其它操作符一致但是会产生一些意想不到的结果，比如数组之类的数据类型；</p><p>$not操作符不支持$regex正则表达式操作，使用//或者你的驱动接口代替，使用语言的正则表达式功能创建正则表达式对象；</p><p>考虑下面的例子使用模式匹配//:</p><p>db.inventory.find( { item: { $not: /^p.*/ } } )</p><p>此查询将会查询inventory集合中item字段不是以p开头的所有文档；</p><h2 id="nor"><a href="#nor" class="headerlink" title="$nor"></a>$nor</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">$match</span>: &#123; <span class="attr">$nor</span>: [&#123; <span class="string">&quot;weeklyreport.submissionWeek&quot;</span>: &#123; <span class="attr">$gte</span>: params.week &#125; &#125;] &#125; &#125;,</span><br></pre></td></tr></table></figure><p>{ $nor: [ { <expression1> }, { <expression2> }, …  { <expressionN> } ] }<br>考虑如下操作：</p><p>db.inventory.find( { $nor: [ { price: 1.99 }, { sale: true } ]  } )<br>查询返回所有的文档，条件是：</p><p>包含字段price值不等于1.99，包含字段sale值不等于true,或者包含字段price值不等于1.99，不包含字段sale；或者不包含字段price,包含字段sale值不等于true;或者不包含字段price，不包含字段sale;</p><p>$nor额外比较</p><p>考虑入校操作：</p><p>db.inventory.find( { $nor: [ { price: 1.99 }, { qty: { $lt: 20 } }, { sale: true } ] }<br>inventory集合查询所有的文档，条件如下：<br>字段price不等于1.99，字段qty不小于20，字段sale不等于true;查询的结果包含不存在的字段；</p>]]></content>
      
      
      <categories>
          
          <category> mongo聚合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中BSON的使用方法</title>
      <link href="/2021/11/19/golang%E4%B8%ADBSON%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2021/11/19/golang%E4%B8%ADBSON%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="golang中BSON的使用方法"><a href="#golang中BSON的使用方法" class="headerlink" title="golang中BSON的使用方法"></a>golang中BSON的使用方法</h1><p>关于mongodb-go-driver这个包里面的BSOM</p><p>bson是一种类似json的二进制存储形式，它就是mongodb的存储结构，它的数据结构要比json多，如 int, long, date, floating point, and decimal128。<br> <span id="more"></span><br>我在mongodb官网找到一个blog里面也写了我用的go的mongodb拓展中bson的介绍( <a href="https://www.oschina.net/action/GoToLink?url=https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial">https://www.mongodb.com/blog/post/mongodb-go-driver-tutorial</a> ),他是这样写的。</p><p> The Go Driver has two families of types for representing BSON data: The <code>D</code> types and the <code>Raw</code> types.</p><p>The <code>D</code> family of types is used to concisely build BSON objects using native Go types. This can be particularly useful for constructing commands passed to MongoDB. The <code>D</code> family consists of four types:</p><ul><li><code>D</code>: A BSON document. This type should be used in situations where order matters, such as MongoDB commands.</li><li><code>M</code>: An unordered map. It is the same as <code>D</code>, except it does not preserve order.</li><li><code>A</code>: A BSON array.</li><li><code>E</code>: A single element inside a <code>D</code>.</li></ul><p>The <code>Raw</code> family of types is used for validating a slice of bytes. You can also retrieve single elements from Raw types using a <a href="https://www.oschina.net/action/GoToLink?url=https://godoc.org/go.mongodb.org/mongo-driver/bson%23Raw.Lookup"><code>Lookup()</code></a>. This is useful if you don’t want the overhead of having to unmarshall the BSON into another type. </p><p>大概意思是：这个mongodb GO版的拓展有两种族来使用bosn数据，一个D还有一个是RAW。</p><p>D族是使用原生GO的形式来简单的构造一个BSON对象。这个对于使用命令来操作mongodb是十分有用的。D()由下面4种类型：</p><p>D:一个BSON文档，这个类型应该被用在顺序比较重要的场合（言外之意就是有序的），比如说mongodb的命令。</p><p>M:一个无序的map。它除了无序之外和D是一样的（可以理解为map和bson是可以转换）。</p><p>A:一个BSON形式的数组。</p><p>E:一个D里面的单独元素。(就是文档里的一个元素)</p><p>RAW族是被用来判断是否为bytes的一个slice。你也可以用look up()方法从RAW取得一个元素。这可以在你将BSON转化为另一个形式的数据时是十分有用的(原文大概意思是可以节省你转化数据时的开销)。</p><p>下面简单说下在操作D族时会有使用到一些条件参数。</p><p>不等于!=($ne)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$ne&quot;: &quot;Tom&quot;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>大于&gt;($gt)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$gt&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>小于&lt;($lt)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$lt&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>大于等于&gt;=($gte)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$gte&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>小于等于&lt;=($lte)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;age&quot;: bson.M&#123;&quot;$lte&quot;: 10&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>in($in)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$in&quot;: []string&#123;&quot;Tom&quot;, &quot;Jerry&quot;&#125;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>no in(nin)同<em>n<strong>i</strong>n</em>)同in</p><p>是否包含这个键($exists)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$exists&quot;: true&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>查询键值为null的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$in&quot;:[]interface&#123;&#125;&#123;null&#125;, &quot;$exists&quot;: true&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>正则匹配($regex)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$regex&quot;: &quot;^[0-9]+&quot;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>$all查询所有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;name&quot;: bson.M&#123;&quot;$all&quot;: []int&#123;10,11,12&#125;&#125;&#125;).All(&amp;users</span><br></pre></td></tr></table></figure><p>$or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.Find(bson.M&#123;&quot;$or&quot;: []bson.M&#123;bson.M&#123;&quot;age&quot;: 11&#125;, bson.M&#123;&quot;sex&quot;: 1&#125;&#125;&#125;).All(&amp;users)</span><br></pre></td></tr></table></figure><p>修改$set</p><p>增加值$incr</p><p>向数组增加一个元素$push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.D&#123;&#123;&quot;name&quot;, &quot;Speike&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">update := bson.D&#123;</span><br><span class="line">   &#123;&quot;$push&quot;, bson.D&#123;</span><br><span class="line">      &#123;&quot;interests&quot;, &quot;sing&quot;&#125;,</span><br><span class="line">   &#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">updateResult, err := collection.UpdateOne(context.TODO(), filter, update)</span><br></pre></td></tr></table></figure><p>移除数组一个元素$pull</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter := bson.D&#123;&#123;&quot;name&quot;, &quot;Speike&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">update := bson.D&#123;</span><br><span class="line">   &#123;&quot;$pull&quot;, bson.D&#123;</span><br><span class="line">      &#123;&quot;interests&quot;, &quot;sing&quot;&#125;,</span><br><span class="line">   &#125;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">updateResult, err := collection.UpdateOne(context.TODO(), filter, update)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL（软件系统）总结</title>
      <link href="/2021/11/19/MySQL(%E7%AC%94%E8%AE%B0)/"/>
      <url>/2021/11/19/MySQL(%E7%AC%94%E8%AE%B0)/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL（软件系统）总结"><a href="#MySQL（软件系统）总结" class="headerlink" title="MySQL（软件系统）总结"></a>MySQL（软件系统）总结</h1><h2 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h2><p>MySQL是C/S架构的软件</p><p>软件的架构有：B/S、C/S</p><p>——B/S：B:浏览器，S:服务器（网页上直接能运行，如京东，淘宝）</p><p>——C/S：C:客户端，S:服务器（需要安装或下载客户端的软件）<br> <span id="more"></span></p><h3 id="数据库的基本分类"><a href="#数据库的基本分类" class="headerlink" title="数据库的基本分类"></a>数据库的基本分类</h3><p>关系型数据库：MySQL、Oracle、DB2……</p><p>非关系型数据库：Mongo dB、Redis……</p><h3 id="SQL脚本"><a href="#SQL脚本" class="headerlink" title="SQL脚本"></a>SQL脚本</h3><p>1、一堆SQL代码，后缀为.sql的文件</p><p>DB、DBMS、SQL</p><p>DB： Database 数据库</p><p>​        主要是表，表是数据库基本组成单元</p><p>DBMS： Database Management System，数据库管理系统</p><p>SQL：结构化查询语言，标准的关系型数据库语言</p><p>三者的关系：DBMS—执行–&gt;SQL–操作–&gt;DB</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>（1）行：记录/数据，存储一条完整的信息</p><p>​        —-数据</p><p>​        —-数据类型</p><p>​        —-数据约束</p><p>（2）列：列名，存储列的相关信息</p><h3 id="SQL，操作或控制数据库（DB）"><a href="#SQL，操作或控制数据库（DB）" class="headerlink" title="SQL，操作或控制数据库（DB）"></a>SQL，操作或控制数据库（DB）</h3><p>​        —-DQL（数据查询语言）：主要是对SELECT操作的支持</p><p>​        —-DML（数据操作语言）：数据库对增（INSERT）删（DELETE）改（UPDATE）</p><p>​        —-TCL（事务控制语言）：提交（COMMIT）回滚（ROLLBACK）</p><p>​        —-DCL（数据控制语言）：授权（GRANT）等</p><p>​        —-DDL（数据定义语言）：创建（CREATE）删除（DROP）修改（ALTER）等支持</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>SELECT————-查询</p><p>FROM—————来自</p><p>DISTINCT———-去除重复（行）</p><h3 id="子句的概念"><a href="#子句的概念" class="headerlink" title="子句的概念"></a>子句的概念</h3><p>​        关键字+后面写的代码</p><h3 id="子句的作用"><a href="#子句的作用" class="headerlink" title="子句的作用"></a>子句的作用</h3><p>SELECT子句：控制列的显示，有的时候也可称之为“数据投影”</p><p>FROM子句：确定数据的来源</p><h3 id="子句的书写顺序"><a href="#子句的书写顺序" class="headerlink" title="子句的书写顺序"></a>子句的书写顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>……<span class="keyword">FROM</span>……</span><br></pre></td></tr></table></figure><h3 id="子句的执行顺序"><a href="#子句的执行顺序" class="headerlink" title="子句的执行顺序"></a>子句的执行顺序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>……<span class="keyword">SELECT</span>……</span><br></pre></td></tr></table></figure><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><p>显示所有</p><p>​        面试题</p><p>​            问题：使用*号好还是使用所有列名好？——-要能自圆其说</p><p>​            目的：二者谁的执行效率高？———————列名</p><p>四则运算</p><p>​        注意空值参与运算    如果没有处理，结果一定是空值</p><p>别名的使用</p><p>​        表名+空格+表别名</p><p>数据排序（新的子句）</p><p>​        关键字：ORDER BY</p><p>​        子句：ORDER BY 子句</p><p>​        子句的作用：按指定的列或者多个列进行排序</p><p>​        子句的书写顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT……FROM……ORDER BY……</span><br></pre></td></tr></table></figure><p>​        子句执行顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM……SELECT……ORDER BY……</span><br></pre></td></tr></table></figure><p>​        注意：排序</p><p>​            数字，字典……</p><p>​            升序、降序</p><p>​                升序：ASC</p><p>​                降序：DESC</p><p>​        面试题：</p><p>​            （1）可以使用列别名排序吗？——可以</p><p><img src="/images/image-20210102140918977.png" alt="image-20210102140918977"></p><p>​            （2）可以使用序号排序吗？———可以</p><p><img src="/images/image-20210102140841660.png" alt="image-20210102140841660"></p><h3 id="命令和关键字的区别"><a href="#命令和关键字的区别" class="headerlink" title="命令和关键字的区别"></a>命令和关键字的区别</h3><p>功能作用：</p><p>​    DESC：作为关键字是降序，作为命令是查询表结构。</p><p>是否可以缩写：</p><p>​    命令是可以缩写的，如：DESC全命令是DESCRIBE</p><p>​    关键字是不能缩写的</p><h1 id="增删改-DML操作"><a href="#增删改-DML操作" class="headerlink" title="增删改(DML操作)"></a>增删改(DML操作)</h1><h2 id="增-INSERT"><a href="#增-INSERT" class="headerlink" title="增(INSERT)"></a>增(INSERT)</h2><p>关键字：INSERT INTO,VALUES</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><h3 id="增加表列"><a href="#增加表列" class="headerlink" title="增加表列"></a>增加表列</h3><h3 id="增加数据-INSERT-INTO"><a href="#增加数据-INSERT-INTO" class="headerlink" title="增加数据(INSERT INTO)"></a>增加数据(INSERT INTO)</h3><p>方法一：列名与value一一对应，能自定义列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名(列名1,列名2,列名3……)</span><br><span class="line">VALUES(values1,values2,values3……)</span><br></pre></td></tr></table></figure><p>方法二：省略列名但，需要按表中列的顺序一一写上数据，不能少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名</span><br><span class="line">VALUES(values1,values2,values3……);</span><br></pre></td></tr></table></figure><h2 id="删-DELETE"><a href="#删-DELETE" class="headerlink" title="删(DELETE)"></a>删(DELETE)</h2><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><h3 id="删除表列"><a href="#删除表列" class="headerlink" title="删除表列"></a>删除表列</h3><h3 id="删除数据-危险操作-带上条件"><a href="#删除数据-危险操作-带上条件" class="headerlink" title="删除数据[危险操作-带上条件]"></a>删除数据[危险操作-带上条件]</h3><p>关键字：DELETE,FROM,WHERE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 </span><br><span class="line">WHERE 条件</span><br></pre></td></tr></table></figure><blockquote><p>注意：删除操作，一定带上条件，否则删除表中所有数据</p></blockquote><h2 id="改-UPDATE"><a href="#改-UPDATE" class="headerlink" title="改(UPDATE)"></a>改(UPDATE)</h2><h3 id="修改数据库名"><a href="#修改数据库名" class="headerlink" title="修改数据库名"></a>修改数据库名</h3><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>关键字：UPDATE,SET,WHERE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名</span><br><span class="line">SET column1=value1,column2=value2,...</span><br><span class="line">WHERE 条件</span><br></pre></td></tr></table></figure><blockquote><p>注意：更新操作，一定带上条件，否则更新表中所有数据</p></blockquote><h1 id="查-SELECT"><a href="#查-SELECT" class="headerlink" title="查(SELECT)"></a>查(SELECT)</h1><p>SELECT语句完整语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(7)  SELECT </span><br><span class="line">(8)  DISTINCT &lt;select_list&gt;</span><br><span class="line">(1)  FROM &lt;left_table&gt;</span><br><span class="line">(3)  &lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">(2)  ON &lt;join_condition&gt;</span><br><span class="line">(4)  WHERE &lt;where_condition&gt;</span><br><span class="line">(5)  GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(6)  HAVING &lt;having_condition&gt;</span><br><span class="line">(9)  ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">(10) LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure><p>执行顺序</p><p>FROM—&gt;ON—&gt;JOIN—&gt;WHERE—&gt;GROUP BY—&gt;HAVING—&gt;SELECT—&gt;DISTINCT—&gt;ORDER BY—&gt;LIMIT</p><h3 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC emp(表名)</span><br></pre></td></tr></table></figure><h3 id="无条件查询"><a href="#无条件查询" class="headerlink" title="无条件查询"></a>无条件查询</h3><p>1.查询表的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  *</span><br><span class="line">FROM 表名(表别名);</span><br></pre></td></tr></table></figure><p>2.查询表对应列的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名1(表别名1)、列名2(表别名2)、列名3(表别名3)……</span><br><span class="line">FROM 表名(表别名);</span><br></pre></td></tr></table></figure><p>3.无重复的查询表的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  DISTINCT *</span><br><span class="line">FROM 表名(表别名);</span><br></pre></td></tr></table></figure><p>2.无重复的查询表对应列的全部信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 列名1(列别名1)、列名2(列别名2)、列名3(列别名3)……</span><br><span class="line">FROM 表名(列别名);</span><br></pre></td></tr></table></figure><h3 id="条件查询（WHERE）"><a href="#条件查询（WHERE）" class="headerlink" title="条件查询（WHERE）"></a>条件查询（WHERE）</h3><h4 id="1-基本语句："><a href="#1-基本语句：" class="headerlink" title="1.基本语句："></a>1.基本语句：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT……</span><br><span class="line">FROM……</span><br><span class="line">WHERE 条件</span><br></pre></td></tr></table></figure><p>关键字</p><p>​    SELECT、FROM、WHERE</p><p>子句</p><p>​    </p><p>子句的作用</p><p>子句的书写顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT……FROM……WHERE……</span><br></pre></td></tr></table></figure><p>子句的执行顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM……WHERE……SELECT……</span><br></pre></td></tr></table></figure><h4 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h4><p>​    基本比较运算符</p><blockquote><p>​        &lt;、&gt;、=、!=(不等于)、&lt;&gt;(不等于)、&gt;=、&lt;=</p></blockquote><p>​    基本逻辑运算符</p><p>​        能够进行多个条件的连接，这些条件之间构成一定的逻辑关系</p><blockquote><p>​        与    AND</p><p>​        或    OR</p><p>​        非    NOT</p></blockquote><p>特殊的比较运算符</p><p>​    基本空值判断</p><p>​        判断是NULL的情况：列名：列名(字段名) IS NULL;</p><p><img src="/images/image-20210102145040748.png" alt="image-20210102145040748"></p><h6 id="错误情况："><a href="#错误情况：" class="headerlink" title="错误情况："></a>错误情况：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名(字段名) = NULL;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20210102145055883.png" alt="image-20210102145055883"></p><p>​        判断不是NULL的情况：列名：列名(字段名) IS NOT NULL;</p><h4 id="BETWEEN……AND……"><a href="#BETWEEN……AND……" class="headerlink" title="BETWEEN……AND……"></a>BETWEEN……AND……</h4><p>在value1到value2之间(包含这两个值，即[value1,value2])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名(字段名) BETWEEN value1 AND value2;</span><br></pre></td></tr></table></figure><p>​            等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名(字段名) &gt;= value1 AND 列名(字段名) &lt;= value2;</span><br></pre></td></tr></table></figure><p>​        可以对日期进行比较</p><p><img src="/images/image-20210102145449359.png" alt="image-20210102145449359"></p><h4 id="模糊查询（LIKE）"><a href="#模糊查询（LIKE）" class="headerlink" title="模糊查询（LIKE）"></a>模糊查询（LIKE）</h4><p>​            关键字like</p><p>​            重要的符号（通配符）：</p><blockquote><p>​                ‘_’：代表一个字符</p><p>​                ‘%’：代表的是任意个字符（包含0个）</p></blockquote><p>​            如查询倒数第二个字为A的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名 LIKE &#x27;%A_&#x27;;</span><br></pre></td></tr></table></figure><p><code>注意：这两个字符可以重复使用</code></p><h4 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h4><p>数据中不等于value1或value2……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名 NOT IN (value1,value2……)</span><br></pre></td></tr></table></figure><p>数据中等于value1或value2……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE 列名 IN (value1,value2……)</span><br></pre></td></tr></table></figure><p>数据为NULL时有问题（看子查询）</p><h3 id="分页查询（LIMIT）"><a href="#分页查询（LIMIT）" class="headerlink" title="分页查询（LIMIT）"></a>分页查询（LIMIT）</h3><p>显示查询结果的前number条数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">LIMIT number;</span><br></pre></td></tr></table></figure><p>显示前指定页数的数据，size1是页数，number2是一页中的数据条数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表名</span><br><span class="line">LIMIT size1,number2;</span><br></pre></td></tr></table></figure><h3 id="子查询（SELECT嵌套）"><a href="#子查询（SELECT嵌套）" class="headerlink" title="子查询（SELECT嵌套）"></a>子查询（SELECT嵌套）</h3><p>​    子查询顾名思义一个查询（主查询，外部查询）中包含其他查询。</p><p>​    单行子查询（简单子查询）</p><blockquote><p>子查询需要使用( )括起来</p><p>单行子查询可以使用基本比较运算符</p><p>子查询是可以脱离外部查询独立执行</p><p>子查询的书写位置</p><p>​    1.SELECT子句（罕见）</p><p>​    2.FROM子句（可以用，注意别名）</p><p>这样写会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1248 - Every derived table must have its own alias</span><br></pre></td></tr></table></figure><p>错误原因 没有给子查询出来的表起别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM (SELECT * FROM EMP WHERE DEPTNO=&#x27;20&#x27;)</span><br><span class="line">where sal&gt;1500;</span><br></pre></td></tr></table></figure><p>正确写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT temp.*</span><br><span class="line">FROM (SELECT * FROM EMP WHERE DEPTNO=&#x27;20&#x27;) temp</span><br><span class="line">where temp.sal&gt;1500;</span><br></pre></td></tr></table></figure><p>​    3.WHERE子句（常用）</p><p>​    4.HAVING子句</p></blockquote><p>​    多行子查询</p><blockquote><p>多行子查询不能使基本比较运算符</p><p>能使用</p><p>IN</p><p>NOT IN</p><p>​    注意事项：( )里如果有NULL，相当于=NULL，无结果(返回值)。</p><p>ALL：所有</p><p>ANY：任何一个</p><p>​    注意事项：使用ALL或ANY的效率比使用组函数，如MAX()和MIN()更高</p></blockquote><h3 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h3><p>我们需要的数据不可能都来自于一张表中</p><p>交叉连接（笛卡尔积）（CROSS JOIM）</p><blockquote><p>笛卡尔积：是指数学中两个集合的乘积</p><p>注意：多表查询的时候需要避免笛卡尔积（产生大量冗余数据）</p><p>避免方法：一定要写多表连接的连接条件</p><p>关键字：CROSS JOIM</p></blockquote><p>等值连接(必须会且熟练)(INNER JOIN……ON)</p><blockquote><p>使用不同表中的具有相同意义的字段(列)相等作为多表的连接条件</p><p>方式一：使用WHERE子句添加多表的连接条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1,表2……</span><br><span class="line">WHERE 表1.列名=表2.列名</span><br></pre></td></tr></table></figure><p>方式二(通用):使用INNER JOIN……ON(等价于 JOIN……ON)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">INNER JOIN 表2 ON (表1.列名=表2.列名);</span><br></pre></td></tr></table></figure><p>注意：1.可以使用表的别名，使用方式和列一样    </p><p>​            2.如果不同表中的字段名一致，使用的时候需要区分</p></blockquote><p>不等值连接</p><blockquote><p>等值连接以外的那部分数据</p></blockquote><p>外连接</p><blockquote><p>左外连接:主要显示的是左边表所有行的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">LEFT JOIN 表2 ON(表1.列名=表2.列名);</span><br></pre></td></tr></table></figure><p>右外连接:主要显示的是右边表所有行的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">RIGHT JOIN 表2 ON(表1.列名=表2.列名);</span><br></pre></td></tr></table></figure><p>全外连接(MYSQL不支持,但Oracle支持):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 表1</span><br><span class="line">FULL JOIN 表2 ON(表1.列名=表2.列名);</span><br></pre></td></tr></table></figure></blockquote><p>自连接</p><blockquote><p>自己连接自己(表中的A列和B列实际意义相同)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.ENAME,e.EMPNO,m.ENAME,m.EMPNO</span><br><span class="line">FROM emp e,emp m</span><br><span class="line">WHERE e.MGR=m.EMPNO</span><br></pre></td></tr></table></figure></blockquote><h3 id="分组查询（GROUP-BY）"><a href="#分组查询（GROUP-BY）" class="headerlink" title="分组查询（GROUP BY）"></a>分组查询（GROUP BY）</h3><p>​    显然用于进行统计时5个常用函数</p><p>关键字group by（按照……分组）</p><p>子句：GROUP BY+按照分组的列名（字段名）</p><p>书写顺序：</p><p>SELECT—&gt;FROM—&gt;WHERE—&gt;GROUP BY—&gt;ORDER BY</p><blockquote><p>注意：</p><p>SELECT中可以有GROUP BY的对象</p><p>mysql（5.x版本）中执行顺序</p><p>FROM—&gt;WHERE—&gt;SELECT—&gt;GROUP BY—&gt;ORDER BY</p><p>即分组查询可以使用列别名（只限于目前）</p></blockquote><h4 id="分组条件-HAVING"><a href="#分组条件-HAVING" class="headerlink" title="分组条件(HAVING)"></a>分组条件(HAVING)</h4><p>​    关键字：HAVING</p><p>​    子句：HAVING + 分组条件</p><p>​    子句作用：添加分组条件（WHERE语句中不支持分组函数的分组条件）</p><p>​    书写顺序：SELECT—&gt;FROM—&gt;WHERE—&gt;GROUP BY—&gt;ORDER BY</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>​        函数：在计算机中通常称为方法、函数</p><blockquote><p>​        函数之间可以嵌套使用</p></blockquote><p>单行函数</p><p>​    处理NULL值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(value1, value2)</span><br></pre></td></tr></table></figure><blockquote><p>​    如果value1为NULL，则返回值为value2</p><p>​    如果value1不为NULL，则返回值为value1</p></blockquote><p>​    日期类型</p><blockquote><p>​        获取当前日期：CURDATE()</p><p>​        获取当前时间：CURTIME()</p><p>​        获取当前的日期+时间：NOW()</p><p><img src="/images/image-20210102162950812.png" alt="image-20210102162950812"></p></blockquote><p>​    数值类型</p><blockquote><p>​        四舍五入：ROUND()</p><p>​        向下取整：FLOOR()</p><p>​        向上取整：CEIL()</p><p><img src="/images/image-20210102162858473.png" alt="image-20210102162858473"></p><p>面试时注意负数</p><p><img src="/images/image-20210102163034641.png" alt="image-20210102163034641"></p></blockquote><p>​    字符串类型</p><blockquote><p>​    字符串拼接：CONCAT(string1，string2)–将string1与string2拼接</p><p>​    字符串长度：LENGTAH(string)</p><p>​    去除前后空格：TRIM(string)</p><p>​    转成大写字母：UPPER(string)</p><p>​    转成小写字母：LOWER(string)</p></blockquote><p>多行函数（分组函数）</p><blockquote><p>​    统计数据总条数：COUNT()</p><p>注意：COUNT()括号中为数字或*</p><p>面试题：</p><p>​    给你一个陌生的数据库，有一张陌生的表，第一件事你干啥？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（1）SELECT * FROM 表名</span><br><span class="line">（2）SELECT COUNT(*) FORM 表名</span><br></pre></td></tr></table></figure><p>​    选（2）由于这个表的数据量可能会很大，（2）查询数据量更快</p><p>​    统计平均数：AVG()</p><p>​    统计总和：SUM()</p><p>​    统计最大值：MAX()</p><p>​    统计最小值：MIN()</p></blockquote><h2 id="DDL操作"><a href="#DDL操作" class="headerlink" title="DDL操作"></a>DDL操作</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件操作</title>
      <link href="/2021/11/19/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/11/19/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言文件操作"><a href="#C语言文件操作" class="headerlink" title="C语言文件操作"></a>C语言文件操作</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p> <strong>fopen( )</strong> 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *fopen( const char * filename, const char * mode );</span><br></pre></td></tr></table></figure> <span id="more"></span><p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">打开一个已有的文本文件，允许读取文件。</td></tr><tr><td align="left">w</td><td align="left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td align="left">a</td><td align="left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文本文件，允许读写文件。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fclose( FILE *fp );</span><br></pre></td></tr></table></figure><p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装指定版本minio</title>
      <link href="/2021/11/19/docker%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACminio/"/>
      <url>/2021/11/19/docker%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%ACminio/</url>
      
        <content type="html"><![CDATA[<h1 id="docker安装指定版本minio"><a href="#docker安装指定版本minio" class="headerlink" title="docker安装指定版本minio"></a><a href="https://www.cnblogs.com/jiqing9006/p/15272722.html">docker安装指定版本minio</a></h1><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio:RELEASE.2020-12-03T00-03-10Z</span><br></pre></td></tr></table></figure> <span id="more"></span><h3 id="启动，也要加上指定版本"><a href="#启动，也要加上指定版本" class="headerlink" title="启动，也要加上指定版本"></a>启动，也要加上指定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 --name minio -d --restart=always -e &quot;MINIO_ACCESS_KEY=admin&quot; -e &quot;MINIO_SECRET_KEY=admin123&quot; -v /opt/data:/data -v /opt/config:/root/.minio minio/minio:RELEASE.2020-12-03T00-03-10Z server /data</span><br></pre></td></tr></table></figure><p>node上传文件方法</p><p>安装npm插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save minio</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const Minio = require(&#x27;minio&#x27;)</span><br><span class="line">async index() &#123;</span><br><span class="line">const &#123; ctx &#125; = this;</span><br><span class="line">let file = ctx.request.files[0] // file包含了文件名，文件类型，大小，路径等信息，可以自己打印下看看</span><br><span class="line">//使用端点实例化minio客户端</span><br><span class="line">//和访问键，如下所示。</span><br><span class="line">    var minioClient = new Minio.Client(&#123;</span><br><span class="line">    endPoint: &#x27;101.200.87.232&#x27;,</span><br><span class="line">    port: 9000,</span><br><span class="line">    useSSL: false,</span><br><span class="line">    accessKey: &#x27;admin&#x27;,</span><br><span class="line">    secretKey: &#x27;admin123&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    var metaData = &#123;</span><br><span class="line">    &#x27;Content-Type&#x27;: &#x27;application/octet-stream&#x27;,</span><br><span class="line">    &#x27;X-Amz-Meta-Testing&#x27;: 1234,</span><br><span class="line">    &#x27;example&#x27;: 5678</span><br><span class="line">    &#125;</span><br><span class="line">    minioClient.fPutObject(&#x27;test&#x27;, file.filename, file.filepath, metaData, function (err, etag) &#123;</span><br><span class="line">    if (err) return console.log(err)</span><br><span class="line">    console.log(&#x27;File uploaded successfully.&#x27;)</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用egg操作minio，实现文件上传下载</title>
      <link href="/2021/11/19/%E4%BD%BF%E7%94%A8egg%E6%93%8D%E4%BD%9Cminio%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2021/11/19/%E4%BD%BF%E7%94%A8egg%E6%93%8D%E4%BD%9Cminio%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="使用egg操作minio，实现文件上传下载"><a href="#使用egg操作minio，实现文件上传下载" class="headerlink" title="使用egg操作minio，实现文件上传下载"></a>使用egg操作minio，实现文件上传下载</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Minio = require(&#x27;minio&#x27;);//引用npm Minio包</span><br><span class="line">const bucket = &quot;test&quot;//使用的桶（test是公有的）（browse是私有的）</span><br><span class="line">//其中公有的能使用文件地址直接下载，私有的需要通过自己的下载接口</span><br><span class="line">const minioClient = new Minio.Client(&#123;//minio的参数</span><br><span class="line">    endPoint: &#x27;101.200.87.232&#x27;,</span><br><span class="line">    port: 9000,</span><br><span class="line">    useSSL: false,</span><br><span class="line">    accessKey: &#x27;账号&#x27;,</span><br><span class="line">    secretKey: &#x27;密码&#x27;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const metaData = &#123;//上传中的数据格式，根据文件类型，可能会有变化</span><br><span class="line">    &#x27;Content-Type&#x27;: &#x27;application/octet-stream&#x27;,</span><br><span class="line">    &#x27;X-Amz-Meta-Testing&#x27;: 1234,</span><br><span class="line">    example: 5678,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="上传代码"><a href="#上传代码" class="headerlink" title="上传代码"></a>上传代码</h3><p>上传方式是POST请求，数据使用file</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">index</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; ctx &#125; = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> file = ctx.request.files[<span class="number">0</span>]; <span class="comment">// file包含了文件名，文件类型，大小，路径等信息，可以自己打印下看看</span></span><br><span class="line">            <span class="keyword">const</span> params = ctx.query; <span class="comment">// file包含了文件名，文件类型，大小，路径等信息，可以自己打印下看看，由于编码问题，使用postman上传的文件名中的中文会被转换成乱码。但使用elelmentUI则不会。</span></span><br><span class="line">            params.filename = params.filename || file.filename</span><br><span class="line">            <span class="keyword">let</span> errmsg = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            minioClient.fPutObject(bucket, params.filename, file.filepath, metaData, <span class="function"><span class="keyword">function</span> (<span class="params">err, etag</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    errmsg = err.message;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (errmsg != <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.error(errmsg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">this</span>.success(<span class="string">&#x27;http://101.200.87.232:9000/test/&#x27;</span> + params.filename);</span><br><span class="line">            <span class="comment">//返回给前端一个url，由于我的test仓库是公有的，访问此url，能直接下载或展示文件。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">this</span>.error(error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h3><p>把桶设置成公有的，在上传接口中返回的url就是下载链接</p><p>下面是私有情况下的下载方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">indexget</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// minioClient.fGetObject(&#x27;test&#x27;, &#x27;111.png&#x27;, &#x27;D:\\222.png&#x27;, function (err, etag) &#123;</span></span><br><span class="line">        <span class="comment">//     if (err) &#123;</span></span><br><span class="line">        <span class="comment">//         return console.log(err);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     console.log(&#x27;done&#x27;);</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        <span class="comment">//fGetObject：会把文件保存在本地</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">const</span> &#123; ctx &#125; = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> params = ctx.query;<span class="comment">//接受下载文件在minio中的文件名</span></span><br><span class="line">        <span class="keyword">const</span> kkk = <span class="keyword">await</span> minioClient.getObject(bucket, params.filename)</span><br><span class="line">        <span class="comment">//此方法是官方提供，会返回，文件相关数据。</span></span><br><span class="line">        <span class="comment">//由于官方的方法是异步的，不能通过阻塞线程的方式等待此方法调用完毕后，返回文件。必须使用await</span></span><br><span class="line">        ctx.attachment(params.filename);<span class="comment">//下载的文件名</span></span><br><span class="line">        ctx.set(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/octet-stream&#x27;</span>);</span><br><span class="line">        ctx.body = kkk</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="另外上传文件出现问题-413-Request-Entity-Too-Large"><a href="#另外上传文件出现问题-413-Request-Entity-Too-Large" class="headerlink" title="另外上传文件出现问题 413 Request Entity Too Large"></a>另外上传文件出现问题 413 Request Entity Too Large</h3><p>这个是由于Nginx默认的request body为1M</p><blockquote><p>解决方案<br>找到自己主机的nginx.conf配置文件，打开<br>在http{}中加入 client_max_body_size 10m;<br>然后重启nginx</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中判断数组中是否包含某元素的方法</title>
      <link href="/2021/11/19/js%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2021/11/19/js%E4%B8%AD%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="js中判断数组中是否包含某元素的方法"><a href="#js中判断数组中是否包含某元素的方法" class="headerlink" title="js中判断数组中是否包含某元素的方法"></a><a href="https://www.cnblogs.com/yunshangwuyou/p/10539090.html">js中判断数组中是否包含某元素的方法</a></h1><h3 id="方法一：array-indexOf-item-start-："><a href="#方法一：array-indexOf-item-start-：" class="headerlink" title="方法一：array.indexOf(item,start)："></a><strong>方法一：array.indexOf(item,start)：</strong></h3><p><strong>元素在数组中的位置,如果没与搜索到则返回 -1。</strong><br> <span id="more"></span></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>item</td><td>必须。查找的元素。</td></tr><tr><td>start</td><td>可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</td></tr></tbody></table><p>实际用法：if(arr.indexOf(某元素) &gt; -1){//则包含该元素}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line"></span><br><span class="line">var a = fruits.indexOf(&quot;Apple&quot;); // 2//以上输出结果意味着 &quot;Apple&quot; 元素位于数组中的第 3 个位置。</span><br></pre></td></tr></table></figure><p>　var fruits=[“Banana”,”Orange”,”Apple”,”Mango”,”Banana”,”Orange”,”Apple”];</p><p>　var a = fruits.indexOf(“Apple”,4); //6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//以上输出结果意味在数组的第四个位置开始检索：</span><br></pre></td></tr></table></figure><p>　　注：string.indexOf()返回某个指定的字符串值在字符串中首次出现的位置。</p><p>1.该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定 fromindex 时）。如果找到一个 searchvalue，则返回 searchvalue 的第一次出现的位置。</p><p>\2. stringObject 中的字符位置是从 0 开始的。</p><p>\3. 查找字符串最后出现的位置，使用 lastIndexOf() 方法。</p><p><strong>JavaScript Array filter() 方法有类似的检索功能：</strong></p><p>　　filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><p>　　<strong>注意：</strong> filter() 不会对空数组进行检测。</p><p>　　<strong>注意：</strong> filter() 不会改变原始数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var ages = [32, 33, 16, 40];</span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age == 16;</span><br><span class="line">&#125;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    ages.filter(checkAdult);</span><br><span class="line">  console.log(ages.filter(checkAdult))</span><br><span class="line">&#125;</span><br><span class="line">myFunction()</span><br><span class="line"></span><br><span class="line">//[16]</span><br><span class="line"></span><br><span class="line">var ages = [32, 33, 16, 40];</span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age &lt;= 14;</span><br><span class="line">&#125;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    ages.filter(checkAdult);</span><br><span class="line">  console.log(ages.filter(checkAdult))</span><br><span class="line">&#125;</span><br><span class="line">myFunction()</span><br><span class="line">//[]</span><br></pre></td></tr></table></figure><h3 id="方法二：array-find"><a href="#方法二：array-find" class="headerlink" title="方法二：array.find()"></a><strong>方法二：array.find()</strong></h3><p>数组实例的find()用于找出第一个符合条件的数组元素。它的参数是一个回调函数，所有数组元素依次遍历该回调函数，直到找出第一个返回值为true的元素，然后返回该元素，否则返回undefined。</p><p>find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。</p><p>find() 方法为数组中的每个元素都调用一次函数执行：</p><ul><li>当数组中的元素在测试条件时返回 <em>true</em> 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</li><li>如果没有符合条件的元素返回 undefined</li></ul><p><strong>注意:</strong> find() 对于空数组，函数是不会执行的。</p><p><strong>注意:</strong> find() 并没有改变数组的原始值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line">return value &gt; 9;</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">// 10</span><br><span class="line"></span><br><span class="line">//实际用法：</span><br><span class="line"></span><br><span class="line">arr.find(function(value) &#123;</span><br><span class="line"></span><br><span class="line">if(value === 要查找的值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法三：array-findIndex"><a href="#方法三：array-findIndex" class="headerlink" title="方法三：array.findIndex()"></a><strong>方法三：array.findIndex()</strong></h3><p>array.findIndex()和array.find()十分类似，返回第一个符合条件的数组元素的位置，如果所有元素都不符合条件，则返回-1。<br>findIndex() 方法为数组中的每个元素都调用一次函数执行：</p><p>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。<br>如果没有符合条件的元素返回 -1</p><p>注意: findIndex() 对于空数组，函数是不会执行的。<br>注意: findIndex() 并没有改变数组的原始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ages = [3, 10, 18, 20];</span><br><span class="line"> </span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age &gt;= 18;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    console.log(ages.findIndex(checkAdult)) ;</span><br><span class="line">&#125;</span><br><span class="line">myFunction()</span><br><span class="line"></span><br><span class="line">//2</span><br></pre></td></tr></table></figure><p>方法二和方法三，这两个方法都可以发现NaN，弥补了方法一IndexOf()的不足。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[NaN].2.dexOf(NaN) </span><br><span class="line">//-1</span><br><span class="line"></span><br><span class="line">[Na3..findIndex(y =&gt; Object.is(NaN, y))</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure><h3 id="方法四：for-循环"><a href="#方法四：for-循环" class="headerlink" title="方法四：for()循环"></a><strong>方法四：for()循环</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">遍历数组，然后 if 判断</span><br><span class="line"></span><br><span class="line">var arr = [1, 5, 10, 15];</span><br><span class="line"></span><br><span class="line">//传统for</span><br><span class="line"></span><br><span class="line">for(let i=0; i&lt;arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">if(arr[i] === 查找值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// for...of</span><br><span class="line"></span><br><span class="line">for(v of arr) &#123;</span><br><span class="line"></span><br><span class="line">if(v === 查找值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//forEach</span><br><span class="line"></span><br><span class="line">arr.forEach(v=&gt;&#123;</span><br><span class="line"></span><br><span class="line">if(v === 查找值) &#123;</span><br><span class="line"></span><br><span class="line">//则包含该元素</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法五：就是使用jquery的inArray方法"><a href="#方法五：就是使用jquery的inArray方法" class="headerlink" title="方法五：就是使用jquery的inArray方法"></a><strong>方法五：就是使用jquery的inArray方法</strong></h3><p><strong>该方法返回元素在数组中的下标，如果不存在与数组中，那么返回－１，代码如下所示：</strong></p><p>/**<br>* 使用jquery的inArray方法判断元素是否存在于数组中<br>* @param {Object} arr 数组<br>* @param {Object} value 元素值<br>*/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function isInArray2(arr,value)&#123;</span><br><span class="line">var index = $.inArray(value,arr);</span><br><span class="line">if(index &gt;= 0)&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法六、include-方法："><a href="#方法六、include-方法：" class="headerlink" title="方法六、include()方法："></a><strong>方法六、include()方法：</strong></h3><p>arr.includes(searchElement)方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。searchElement:必须。需要查找的元素值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let site = [&#x27;runoob&#x27;, &#x27;google&#x27;, &#x27;taobao&#x27;];</span><br><span class="line"> </span><br><span class="line">site.includes(&#x27;runoob&#x27;); </span><br><span class="line">// true </span><br><span class="line"> </span><br><span class="line">site.includes(&#x27;baidu&#x27;); </span><br><span class="line">// false</span><br></pre></td></tr></table></figure><table><thead><tr><th>例子</th><th>结果</th></tr></thead><tbody><tr><td>[1, 2, 3].includes(2);</td><td>//true</td></tr><tr><td>[1, 2, 3].includes(4);</td><td>// false</td></tr><tr><td>[1, 2, 3].includes(3, 3);</td><td>// false</td></tr><tr><td>[1, 2, 3].includes(3, -1);</td><td>//true</td></tr><tr><td>[1, 2, NaN].includes(NaN);</td><td>//true</td></tr></tbody></table><p>arr.includes(searchElement, fromIndex).fromIndex:可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">注意：如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索 </span><br><span class="line">arr.includes(&#x27;c&#x27;, 3);   //false</span><br><span class="line">arr.includes(&#x27;c&#x27;, 100); // false</span><br><span class="line"></span><br><span class="line">注意：如果 fromIndex 为负值，计算出的索引将作为开始搜索searchElement的位置。如果计算出的索引小于 0，则整个数组都会被搜索。</span><br><span class="line">// 数组长度是3</span><br><span class="line">// fromIndex 是 -100</span><br><span class="line">// computed index 是 3 + (-100) = -97</span><br><span class="line">arr.includes(&#x27;a&#x27;, -100); // true</span><br><span class="line">arr.includes(&#x27;b&#x27;, -100); // true</span><br><span class="line">arr.includes(&#x27;c&#x27;, -100); // true</span><br></pre></td></tr></table></figure><h3 id="方法七-Array-some-方法，类似于filter"><a href="#方法七-Array-some-方法，类似于filter" class="headerlink" title="方法七.Array some() 方法，类似于filter()"></a><strong>方法七.Array some() 方法，类似于filter()</strong></h3><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p><p>some() 方法会依次执行数组的每个元素：</p><p>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。<br>如果没有满足条件的元素，则返回false。<br>注意： some() 不会对空数组进行检测。</p><p>注意： some() 不会改变原始数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var ages = [3, 10, 18, 20];</span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age == 18;</span><br><span class="line">&#125;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    console.log(ages.some(checkAdult));</span><br><span class="line">&#125;</span><br><span class="line">myFunction() </span><br><span class="line"></span><br><span class="line">//true</span><br></pre></td></tr></table></figure><h3 id="方法八、Jquery的-each"><a href="#方法八、Jquery的-each" class="headerlink" title="方法八、Jquery的$.each()"></a>方法八、Jquery的$.each()</h3><p><strong>each() 方法为每个匹配元素规定要运行的函数。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var anArray = [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;];</span><br><span class="line">      $.each(anArray,function(n,value)&#123;</span><br><span class="line">          if(value==&quot;one&quot;)&#123;</span><br><span class="line">           console.log(&quot;one存在于数组中&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>//one存在于数组中</p>]]></content>
      
      
      <categories>
          
          <category> 方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq RPC模式实例</title>
      <link href="/2021/11/19/rabbitmq%20RPC%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
      <url>/2021/11/19/rabbitmq%20RPC%E6%A8%A1%E5%BC%8F%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="rabbitmq-RPC模式实例"><a href="#rabbitmq-RPC模式实例" class="headerlink" title="rabbitmq RPC模式实例"></a>rabbitmq RPC模式实例</h1><p>rabbitmq RPC模式实例</p><p>（由生产者发送斐波那契数列的个数，消费者回复对应个数的斐波那契数列的数字）</p> <span id="more"></span><p>server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err error, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法连接到RabbitMQ&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">        ch, err := conn.Channel()</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法打开频道&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">        q, err := ch.QueueDeclare(</span><br><span class="line">                <span class="string">&quot;rpc_queue&quot;</span>, <span class="comment">// name</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// durable</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// delete when unused</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,         <span class="comment">// arguments</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能声明队列&quot;</span>)</span><br><span class="line"></span><br><span class="line">        err = ch.Qos(</span><br><span class="line">                <span class="number">1</span>,     <span class="comment">// prefetch count</span></span><br><span class="line">                <span class="number">0</span>,     <span class="comment">// prefetch size</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// global</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法设置QoS&quot;</span>)</span><br><span class="line"></span><br><span class="line">        msgs, err := ch.Consume(</span><br><span class="line">                q.Name, <span class="comment">// queue</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// auto-ack</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能注册消费者&quot;</span>)</span><br><span class="line"></span><br><span class="line">        forever := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">                        n, err := strconv.Atoi(<span class="keyword">string</span>(d.Body))</span><br><span class="line">                        failOnError(err, <span class="string">&quot;Failed to convert body to integer&quot;</span>)</span><br><span class="line"></span><br><span class="line">                        log.Printf(<span class="string">&quot; [.] fib(%d)&quot;</span>, n)</span><br><span class="line">                        response := fib(n)</span><br><span class="line"></span><br><span class="line">                        err = ch.Publish(</span><br><span class="line">                                <span class="string">&quot;&quot;</span>,        <span class="comment">// exchange</span></span><br><span class="line">                                d.ReplyTo, <span class="comment">// routing key</span></span><br><span class="line">                                <span class="literal">false</span>,     <span class="comment">// mandatory</span></span><br><span class="line">                                <span class="literal">false</span>,     <span class="comment">// immediate</span></span><br><span class="line">                                amqp.Publishing&#123;</span><br><span class="line">                                        ContentType:   <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">                                        CorrelationId: d.CorrelationId,</span><br><span class="line">                                        Body:          []<span class="keyword">byte</span>(strconv.Itoa(response)),</span><br><span class="line">                                &#125;)</span><br><span class="line">                        failOnError(err, <span class="string">&quot;未能发布消息&quot;</span>)</span><br><span class="line"></span><br><span class="line">                        d.Ack(<span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot; [*] 正在等待RPC请求&quot;</span>)</span><br><span class="line">        &lt;-forever</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">        <span class="string">&quot;os&quot;</span></span><br><span class="line">        <span class="string">&quot;strconv&quot;</span></span><br><span class="line">        <span class="string">&quot;strings&quot;</span></span><br><span class="line">        <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err error, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomString</span><span class="params">(l <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">        bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, l)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line">                bytes[i] = <span class="keyword">byte</span>(randInt(<span class="number">65</span>, <span class="number">90</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">string</span>(bytes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randInt</span><span class="params">(min <span class="keyword">int</span>, max <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min + rand.Intn(max-min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacciRPC</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">        conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法连接到RabbitMQ&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">        ch, err := conn.Channel()</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法打开通道&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">        q, err := ch.QueueDeclare(</span><br><span class="line">                <span class="string">&quot;&quot;</span>,    <span class="comment">// name</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// durable</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// delete when unused</span></span><br><span class="line">                <span class="literal">true</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>, <span class="comment">// noWait</span></span><br><span class="line">                <span class="literal">nil</span>,   <span class="comment">// arguments</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能声明队列&quot;</span>)</span><br><span class="line"></span><br><span class="line">        msgs, err := ch.Consume(</span><br><span class="line">                q.Name, <span class="comment">// queue</span></span><br><span class="line">                <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">                <span class="literal">true</span>,   <span class="comment">// auto-ack</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">                <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">                <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">        )</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能注册消费者&quot;</span>)</span><br><span class="line"></span><br><span class="line">        corrId := randomString(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">        err = ch.Publish(</span><br><span class="line">                <span class="string">&quot;&quot;</span>,          <span class="comment">// exchange</span></span><br><span class="line">                <span class="string">&quot;rpc_queue&quot;</span>, <span class="comment">// routing key</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// mandatory</span></span><br><span class="line">                <span class="literal">false</span>,       <span class="comment">// immediate</span></span><br><span class="line">                amqp.Publishing&#123;</span><br><span class="line">                        ContentType:   <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">                        CorrelationId: corrId,</span><br><span class="line">                        ReplyTo:       q.Name,</span><br><span class="line">                        Body:          []<span class="keyword">byte</span>(strconv.Itoa(n)),</span><br><span class="line">                &#125;)</span><br><span class="line">        failOnError(err, <span class="string">&quot;未能发布消息&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">                <span class="keyword">if</span> corrId == d.CorrelationId &#123;</span><br><span class="line">                        res, err = strconv.Atoi(<span class="keyword">string</span>(d.Body))</span><br><span class="line">                        failOnError(err, <span class="string">&quot;无法将正文转换为整数&quot;</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"></span><br><span class="line">        n := bodyFrom(os.Args)</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot; [x] Requesting fib(%d)&quot;</span>, n)</span><br><span class="line">        res, err := fibonacciRPC(n)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法处理RPC请求&quot;</span>)</span><br><span class="line"></span><br><span class="line">        log.Printf(<span class="string">&quot; [.] Got %d&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bodyFrom</span><span class="params">(args []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(args) &lt; <span class="number">2</span>) || os.Args[<span class="number">1</span>] == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                s = <span class="string">&quot;30&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s = strings.Join(args[<span class="number">1</span>:], <span class="string">&quot; &quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        n, err := strconv.Atoi(s)</span><br><span class="line">        failOnError(err, <span class="string">&quot;无法将arg转换为整数&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>egg npm安装列表</title>
      <link href="/2021/11/19/egg%20npm%E5%AE%89%E8%A3%85%E5%88%97%E8%A1%A8/"/>
      <url>/2021/11/19/egg%20npm%E5%AE%89%E8%A3%85%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="egg-npm安装列表"><a href="#egg-npm安装列表" class="headerlink" title="egg npm安装列表"></a>egg npm安装列表</h1><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install mongoose</span><br></pre></td></tr></table></figure> <span id="more"></span><p>plugin.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mongoose: &#123;</span><br><span class="line">    enable: true,</span><br><span class="line">    package: &#x27;egg-mongoose&#x27;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>config.default.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//mongodb配置</span><br><span class="line">  config.mongoose = &#123;</span><br><span class="line">    url:</span><br><span class="line">      &quot;mongodb://127.0.0.1:27017/attendance&quot;,</span><br><span class="line">    options: &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i egg-cors --save</span><br></pre></td></tr></table></figure><h1 id="csprng"><a href="#csprng" class="headerlink" title="csprng"></a>csprng</h1><p>生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install csprng</span><br></pre></td></tr></table></figure><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><p>实现md5加密</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i crypto --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> egg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/18/hello-world/"/>
      <url>/2021/11/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br> <span id="more"></span></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
